_Z14user_read_dataP14png_struct_defPhm:
   69|   127k|void user_read_data(png_structp png_ptr, png_bytep data, size_t length) {
   70|   127k|  BufState* buf_state = static_cast<BufState*>(png_get_io_ptr(png_ptr));
  ------------------
  |  |  291|   127k|#define png_get_io_ptr OSS_FUZZ_png_get_io_ptr
  ------------------
   71|   127k|  if (length > buf_state->bytes_left) {
  ------------------
  |  Branch (71:7): [True: 911, False: 126k]
  ------------------
   72|    911|    png_error(png_ptr, "read error");
  ------------------
  |  |  252|  1.82k|#define png_error OSS_FUZZ_png_error
  ------------------
   73|    911|  }
   74|   126k|  memcpy(data, buf_state->data, length);
   75|   126k|  buf_state->bytes_left -= length;
   76|   126k|  buf_state->data += length;
   77|   126k|}
_Z14limited_mallocP14png_struct_defm:
   79|  16.8k|void* limited_malloc(png_structp, png_alloc_size_t size) {
   80|       |  // libpng may allocate large amounts of memory that the fuzzer reports as
   81|       |  // an error. In order to silence these errors, make libpng fail when trying
   82|       |  // to allocate a large amount. This allocator used to be in the Chromium
   83|       |  // version of this fuzzer.
   84|       |  // This number is chosen to match the default png_user_chunk_malloc_max.
   85|  16.8k|  if (size > 8000000)
  ------------------
  |  Branch (85:7): [True: 2, False: 16.8k]
  ------------------
   86|      2|    return nullptr;
   87|       |
   88|  16.8k|  return malloc(size);
   89|  16.8k|}
_Z12default_freeP14png_struct_defPv:
   91|  22.9k|void default_free(png_structp, png_voidp ptr) {
   92|  22.9k|  return free(ptr);
   93|  22.9k|}
LLVMFuzzerTestOneInput:
  100|  2.05k|extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  101|  2.05k|  if (size < kPngHeaderSize) {
  ------------------
  |  Branch (101:7): [True: 1, False: 2.05k]
  ------------------
  102|      1|    return 0;
  103|      1|  }
  104|       |
  105|  2.05k|  std::vector<unsigned char> v(data, data + size);
  106|  2.05k|  if (png_sig_cmp(v.data(), 0, kPngHeaderSize)) {
  ------------------
  |  |  448|  2.05k|#define png_sig_cmp OSS_FUZZ_png_sig_cmp
  ------------------
  |  Branch (106:7): [True: 1, False: 2.05k]
  ------------------
  107|       |    // not a PNG.
  108|      1|    return 0;
  109|      1|  }
  110|       |
  111|  2.05k|  PngObjectHandler png_handler;
  112|  2.05k|  png_handler.png_ptr = nullptr;
  113|  2.05k|  png_handler.row_ptr = nullptr;
  114|  2.05k|  png_handler.info_ptr = nullptr;
  115|  2.05k|  png_handler.end_info_ptr = nullptr;
  116|       |
  117|  2.05k|  png_handler.png_ptr = png_create_read_struct
  ------------------
  |  |  244|  2.05k|#define png_create_read_struct OSS_FUZZ_png_create_read_struct
  ------------------
  118|  2.05k|    (PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);
  ------------------
  |  |  277|  2.05k|#define PNG_LIBPNG_VER_STRING "1.6.48.git"
  ------------------
  119|  2.05k|  if (!png_handler.png_ptr) {
  ------------------
  |  Branch (119:7): [True: 0, False: 2.05k]
  ------------------
  120|      0|    return 0;
  121|      0|  }
  122|       |
  123|  2.05k|  png_handler.info_ptr = png_create_info_struct(png_handler.png_ptr);
  ------------------
  |  |  243|  2.05k|#define png_create_info_struct OSS_FUZZ_png_create_info_struct
  ------------------
  124|  2.05k|  if (!png_handler.info_ptr) {
  ------------------
  |  Branch (124:7): [True: 0, False: 2.05k]
  ------------------
  125|      0|    PNG_CLEANUP
  ------------------
  |  |   26|      0|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 0, False: 0]
  |  |  ------------------
  |  |   27|      0|  { \
  |  |   28|      0|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   29|      0|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|      0|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   31|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|      0|        &png_handler.end_info_ptr); \
  |  |   33|      0|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|      0|    png_handler.png_ptr = nullptr; \
  |  |   39|      0|    png_handler.row_ptr = nullptr; \
  |  |   40|      0|    png_handler.info_ptr = nullptr; \
  |  |   41|      0|    png_handler.end_info_ptr = nullptr; \
  |  |   42|      0|  }
  ------------------
  126|      0|    return 0;
  127|      0|  }
  128|       |
  129|  2.05k|  png_handler.end_info_ptr = png_create_info_struct(png_handler.png_ptr);
  ------------------
  |  |  243|  2.05k|#define png_create_info_struct OSS_FUZZ_png_create_info_struct
  ------------------
  130|  2.05k|  if (!png_handler.end_info_ptr) {
  ------------------
  |  Branch (130:7): [True: 0, False: 2.05k]
  ------------------
  131|      0|    PNG_CLEANUP
  ------------------
  |  |   26|      0|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 0, False: 0]
  |  |  ------------------
  |  |   27|      0|  { \
  |  |   28|      0|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   29|      0|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|      0|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   31|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|      0|        &png_handler.end_info_ptr); \
  |  |   33|      0|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|      0|    png_handler.png_ptr = nullptr; \
  |  |   39|      0|    png_handler.row_ptr = nullptr; \
  |  |   40|      0|    png_handler.info_ptr = nullptr; \
  |  |   41|      0|    png_handler.end_info_ptr = nullptr; \
  |  |   42|      0|  }
  ------------------
  132|      0|    return 0;
  133|      0|  }
  134|       |
  135|       |  // Use a custom allocator that fails for large allocations to avoid OOM.
  136|  2.05k|  png_set_mem_fn(png_handler.png_ptr, nullptr, limited_malloc, default_free);
  ------------------
  |  |  407|  2.05k|#define png_set_mem_fn OSS_FUZZ_png_set_mem_fn
  ------------------
  137|       |
  138|  2.05k|  png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
  ------------------
  |  |  384|  2.05k|#define png_set_crc_action OSS_FUZZ_png_set_crc_action
  ------------------
                png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
  ------------------
  |  | 1453|  2.05k|#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
  ------------------
                png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
  ------------------
  |  | 1453|  2.05k|#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
  ------------------
  139|       |#ifdef PNG_IGNORE_ADLER32
  140|       |  png_set_option(png_handler.png_ptr, PNG_IGNORE_ADLER32, PNG_OPTION_ON);
  141|       |#endif
  142|       |
  143|       |  // Setting up reading from buffer.
  144|  2.05k|  png_handler.buf_state = new BufState();
  145|  2.05k|  png_handler.buf_state->data = data + kPngHeaderSize;
  146|  2.05k|  png_handler.buf_state->bytes_left = size - kPngHeaderSize;
  147|  2.05k|  png_set_read_fn(png_handler.png_ptr, png_handler.buf_state, user_read_data);
  ------------------
  |  |  417|  2.05k|#define png_set_read_fn OSS_FUZZ_png_set_read_fn
  ------------------
  148|  2.05k|  png_set_sig_bytes(png_handler.png_ptr, kPngHeaderSize);
  ------------------
  |  |  433|  2.05k|#define png_set_sig_bytes OSS_FUZZ_png_set_sig_bytes
  ------------------
  149|       |
  150|  2.05k|  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {
  151|    942|    PNG_CLEANUP
  ------------------
  |  |   26|    942|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 942, False: 0]
  |  |  ------------------
  |  |   27|    942|  { \
  |  |   28|    942|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 0, False: 942]
  |  |  ------------------
  |  |   29|    942|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|    942|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 942, False: 0]
  |  |  ------------------
  |  |   31|    942|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|    942|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|    942|        &png_handler.end_info_ptr); \
  |  |   33|    942|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|    942|    png_handler.png_ptr = nullptr; \
  |  |   39|    942|    png_handler.row_ptr = nullptr; \
  |  |   40|    942|    png_handler.info_ptr = nullptr; \
  |  |   41|    942|    png_handler.end_info_ptr = nullptr; \
  |  |   42|    942|  }
  ------------------
  152|    942|    return 0;
  153|    942|  }
  154|       |
  155|       |  // Reading.
  156|  1.11k|  png_read_info(png_handler.png_ptr, png_handler.info_ptr);
  ------------------
  |  |  357|  1.11k|#define png_read_info OSS_FUZZ_png_read_info
  ------------------
  157|       |
  158|       |  // reset error handler to put png_deleter into scope.
  159|  1.11k|  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {
  160|    564|    PNG_CLEANUP
  ------------------
  |  |   26|    564|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 564, False: 0]
  |  |  ------------------
  |  |   27|    564|  { \
  |  |   28|    564|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 562, False: 2]
  |  |  ------------------
  |  |   29|    564|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|    562|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|    564|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 564, False: 0]
  |  |  ------------------
  |  |   31|    564|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|    564|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|    564|        &png_handler.end_info_ptr); \
  |  |   33|    564|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|    564|    png_handler.png_ptr = nullptr; \
  |  |   39|    564|    png_handler.row_ptr = nullptr; \
  |  |   40|    564|    png_handler.info_ptr = nullptr; \
  |  |   41|    564|    png_handler.end_info_ptr = nullptr; \
  |  |   42|    564|  }
  ------------------
  161|    564|    return 0;
  162|    564|  }
  163|       |
  164|    549|  png_uint_32 width, height;
  165|    549|  int bit_depth, color_type, interlace_type, compression_type;
  166|    549|  int filter_type;
  167|       |
  168|    549|  if (!png_get_IHDR(png_handler.png_ptr, png_handler.info_ptr, &width,
  ------------------
  |  |  256|    549|#define png_get_IHDR OSS_FUZZ_png_get_IHDR
  ------------------
  |  Branch (168:7): [True: 0, False: 549]
  ------------------
  169|    549|                    &height, &bit_depth, &color_type, &interlace_type,
  170|    549|                    &compression_type, &filter_type)) {
  171|      0|    PNG_CLEANUP
  ------------------
  |  |   26|      0|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 0, False: 0]
  |  |  ------------------
  |  |   27|      0|  { \
  |  |   28|      0|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   29|      0|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|      0|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   31|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|      0|        &png_handler.end_info_ptr); \
  |  |   33|      0|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|      0|    png_handler.png_ptr = nullptr; \
  |  |   39|      0|    png_handler.row_ptr = nullptr; \
  |  |   40|      0|    png_handler.info_ptr = nullptr; \
  |  |   41|      0|    png_handler.end_info_ptr = nullptr; \
  |  |   42|      0|  }
  ------------------
  172|      0|    return 0;
  173|      0|  }
  174|       |
  175|       |  // This is going to be too slow.
  176|  1.11k|  if (width && height > 100000000 / width) {
  ------------------
  |  Branch (176:7): [True: 1.11k, False: 18.4E]
  |  Branch (176:16): [True: 1, False: 1.11k]
  ------------------
  177|      1|    PNG_CLEANUP
  ------------------
  |  |   26|      1|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 1, False: 0]
  |  |  ------------------
  |  |   27|      1|  { \
  |  |   28|      1|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 0, False: 1]
  |  |  ------------------
  |  |   29|      1|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|      1|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 1, False: 0]
  |  |  ------------------
  |  |   31|      1|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      1|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|      1|        &png_handler.end_info_ptr); \
  |  |   33|      1|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|      1|    png_handler.png_ptr = nullptr; \
  |  |   39|      1|    png_handler.row_ptr = nullptr; \
  |  |   40|      1|    png_handler.info_ptr = nullptr; \
  |  |   41|      1|    png_handler.end_info_ptr = nullptr; \
  |  |   42|      1|  }
  ------------------
  178|      1|    return 0;
  179|      1|  }
  180|       |
  181|       |  // Set several transforms that browsers typically use:
  182|    548|  png_set_gray_to_rgb(png_handler.png_ptr);
  ------------------
  |  |  396|    548|#define png_set_gray_to_rgb OSS_FUZZ_png_set_gray_to_rgb
  ------------------
  183|    548|  png_set_expand(png_handler.png_ptr);
  ------------------
  |  |  388|    548|#define png_set_expand OSS_FUZZ_png_set_expand
  ------------------
  184|    548|  png_set_packing(png_handler.png_ptr);
  ------------------
  |  |  412|    548|#define png_set_packing OSS_FUZZ_png_set_packing
  ------------------
  185|    548|  png_set_scale_16(png_handler.png_ptr);
  ------------------
  |  |  431|    548|#define png_set_scale_16 OSS_FUZZ_png_set_scale_16
  ------------------
  186|    548|  png_set_tRNS_to_alpha(png_handler.png_ptr);
  ------------------
  |  |  440|    548|#define png_set_tRNS_to_alpha OSS_FUZZ_png_set_tRNS_to_alpha
  ------------------
  187|       |
  188|    548|  int passes = png_set_interlace_handling(png_handler.png_ptr);
  ------------------
  |  |  399|    548|#define png_set_interlace_handling OSS_FUZZ_png_set_interlace_handling
  ------------------
  189|       |
  190|    548|  png_read_update_info(png_handler.png_ptr, png_handler.info_ptr);
  ------------------
  |  |  361|    548|#define png_read_update_info OSS_FUZZ_png_read_update_info
  ------------------
  191|       |
  192|    548|  png_handler.row_ptr = png_malloc(
  ------------------
  |  |  347|    548|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
  193|    548|      png_handler.png_ptr, png_get_rowbytes(png_handler.png_ptr,
  ------------------
  |  |  308|    548|#define png_get_rowbytes OSS_FUZZ_png_get_rowbytes
  ------------------
  194|    548|                                            png_handler.info_ptr));
  195|       |
  196|  3.12k|  for (int pass = 0; pass < passes; ++pass) {
  ------------------
  |  Branch (196:22): [True: 2.57k, False: 548]
  ------------------
  197|   535k|    for (png_uint_32 y = 0; y < height; ++y) {
  ------------------
  |  Branch (197:29): [True: 533k, False: 2.57k]
  ------------------
  198|   533k|      png_read_row(png_handler.png_ptr,
  ------------------
  |  |  359|   533k|#define png_read_row OSS_FUZZ_png_read_row
  ------------------
  199|   533k|                   static_cast<png_bytep>(png_handler.row_ptr), nullptr);
  200|   533k|    }
  201|  2.57k|  }
  202|       |
  203|    548|  png_read_end(png_handler.png_ptr, png_handler.end_info_ptr);
  ------------------
  |  |  355|    548|#define png_read_end OSS_FUZZ_png_read_end
  ------------------
  204|       |
  205|    548|  PNG_CLEANUP
  ------------------
  |  |   26|    548|  if(png_handler.png_ptr) \
  |  |  ------------------
  |  |  |  Branch (26:6): [True: 548, False: 0]
  |  |  ------------------
  |  |   27|    548|  { \
  |  |   28|    548|    if (png_handler.row_ptr) \
  |  |  ------------------
  |  |  |  Branch (28:9): [True: 548, False: 0]
  |  |  ------------------
  |  |   29|    548|      png_free(png_handler.png_ptr, png_handler.row_ptr); \
  |  |  ------------------
  |  |  |  |  253|    548|#define png_free OSS_FUZZ_png_free
  |  |  ------------------
  |  |   30|    548|    if (png_handler.end_info_ptr) \
  |  |  ------------------
  |  |  |  Branch (30:9): [True: 548, False: 0]
  |  |  ------------------
  |  |   31|    548|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|    548|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   32|    548|        &png_handler.end_info_ptr); \
  |  |   33|    548|    else if (png_handler.info_ptr) \
  |  |  ------------------
  |  |  |  Branch (33:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|      png_destroy_read_struct(&png_handler.png_ptr, &png_handler.info_ptr,\
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   35|      0|        nullptr); \
  |  |   36|      0|    else \
  |  |   37|      0|      png_destroy_read_struct(&png_handler.png_ptr, nullptr, nullptr); \
  |  |  ------------------
  |  |  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  |  |  ------------------
  |  |   38|    548|    png_handler.png_ptr = nullptr; \
  |  |   39|    548|    png_handler.row_ptr = nullptr; \
  |  |   40|    548|    png_handler.info_ptr = nullptr; \
  |  |   41|    548|    png_handler.end_info_ptr = nullptr; \
  |  |   42|    548|  }
  ------------------
  206|       |
  207|    548|#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
  208|       |  // Simplified READ API
  209|    548|  png_image image;
  210|    548|  memset(&image, 0, (sizeof image));
  211|    548|  image.version = PNG_IMAGE_VERSION;
  ------------------
  |  | 2773|    548|#define PNG_IMAGE_VERSION 1
  ------------------
  212|       |
  213|    548|  if (!png_image_begin_read_from_memory(&image, data, size)) {
  ------------------
  |  |  342|    548|#define png_image_begin_read_from_memory OSS_FUZZ_png_image_begin_read_from_memory
  ------------------
  |  Branch (213:7): [True: 11, False: 537]
  ------------------
  214|     11|    return 0;
  215|     11|  }
  216|       |
  217|    537|  image.format = PNG_FORMAT_RGBA;
  ------------------
  |  | 2906|    537|#define PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
  |  |  ------------------
  |  |  |  | 2904|    537|#define PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
  |  |  |  |  ------------------
  |  |  |  |  |  | 2883|    537|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
  |  |  ------------------
  |  |  |  | 2882|    537|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  |  |  ------------------
  ------------------
  218|    537|  std::vector<png_byte> buffer(PNG_IMAGE_SIZE(image));
  ------------------
  |  | 3024|    537|   PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))
  |  |  ------------------
  |  |  |  | 3015|  1.07k|   (PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2993|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2984|    537|   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |                  (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2993|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2955|    537|   ((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2884|    537|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2984:5): [True: 0, False: 537]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3015:68): [True: 0, False: 537]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  219|    537|  png_image_finish_read(&image, NULL, buffer.data(), 0, NULL);
  ------------------
  |  |  343|    537|#define png_image_finish_read OSS_FUZZ_png_image_finish_read
  ------------------
  220|    537|#endif
  221|       |
  222|    537|  return 0;
  223|    548|}
_ZN16PngObjectHandlerD2Ev:
   56|  2.05k|  ~PngObjectHandler() {
   57|  2.05k|    if (row_ptr)
  ------------------
  |  Branch (57:9): [True: 0, False: 2.05k]
  ------------------
   58|      0|      png_free(png_ptr, row_ptr);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
   59|  2.05k|    if (end_info_ptr)
  ------------------
  |  Branch (59:9): [True: 0, False: 2.05k]
  ------------------
   60|      0|      png_destroy_read_struct(&png_ptr, &info_ptr, &end_info_ptr);
  ------------------
  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  ------------------
   61|  2.05k|    else if (info_ptr)
  ------------------
  |  Branch (61:14): [True: 0, False: 2.05k]
  ------------------
   62|      0|      png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);
  ------------------
  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  ------------------
   63|  2.05k|    else
   64|  2.05k|      png_destroy_read_struct(&png_ptr, nullptr, nullptr);
  ------------------
  |  |  250|  2.05k|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  ------------------
   65|  2.05k|    delete buf_state;
   66|  2.05k|  }

OSS_FUZZ_png_set_sig_bytes:
   54|  2.05k|{
   55|  2.05k|   unsigned int nb = (unsigned int)num_bytes;
   56|       |
   57|  2.05k|   png_debug(1, "in png_set_sig_bytes");
  ------------------
  |  |  148|  2.05k|#  define png_debug(l, m) ((void)0)
  ------------------
   58|       |
   59|  2.05k|   if (png_ptr == NULL)
  ------------------
  |  Branch (59:8): [True: 0, False: 2.05k]
  ------------------
   60|      0|      return;
   61|       |
   62|  2.05k|   if (num_bytes < 0)
  ------------------
  |  Branch (62:8): [True: 0, False: 2.05k]
  ------------------
   63|      0|      nb = 0;
   64|       |
   65|  2.05k|   if (nb > 8)
  ------------------
  |  Branch (65:8): [True: 0, False: 2.05k]
  ------------------
   66|      0|      png_error(png_ptr, "Too many bytes for PNG signature");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
   67|       |
   68|  2.05k|   png_ptr->sig_bytes = (png_byte)nb;
   69|  2.05k|}
OSS_FUZZ_png_sig_cmp:
   81|  2.60k|{
   82|  2.60k|   static const png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   83|       |
   84|  2.60k|   if (num_to_check > 8)
  ------------------
  |  Branch (84:8): [True: 0, False: 2.60k]
  ------------------
   85|      0|      num_to_check = 8;
   86|       |
   87|  2.60k|   else if (num_to_check < 1)
  ------------------
  |  Branch (87:13): [True: 0, False: 2.60k]
  ------------------
   88|      0|      return -1;
   89|       |
   90|  2.60k|   if (start > 7)
  ------------------
  |  Branch (90:8): [True: 0, False: 2.60k]
  ------------------
   91|      0|      return -1;
   92|       |
   93|  2.60k|   if (start + num_to_check > 8)
  ------------------
  |  Branch (93:8): [True: 0, False: 2.60k]
  ------------------
   94|      0|      num_to_check = 8 - start;
   95|       |
   96|  2.60k|   return memcmp(&sig[start], &png_signature[start], num_to_check);
   97|  2.60k|}
OSS_FUZZ_png_zalloc:
  105|  3.81k|{
  106|  3.81k|   png_alloc_size_t num_bytes = size;
  107|       |
  108|  3.81k|   if (png_ptr == NULL)
  ------------------
  |  Branch (108:8): [True: 0, False: 3.81k]
  ------------------
  109|      0|      return NULL;
  110|       |
  111|  3.81k|   if (items >= (~(png_alloc_size_t)0)/size)
  ------------------
  |  Branch (111:8): [True: 0, False: 3.81k]
  ------------------
  112|      0|   {
  113|      0|      png_warning (png_voidcast(png_structrp, png_ptr),
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
                    png_warning (png_voidcast(png_structrp, png_ptr),
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
  114|      0|          "Potential overflow in png_zalloc()");
  115|      0|      return NULL;
  116|      0|   }
  117|       |
  118|  3.81k|   num_bytes *= items;
  119|  3.81k|   return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);
  ------------------
  |  |  349|  3.81k|#define png_malloc_warn OSS_FUZZ_png_malloc_warn
  ------------------
                 return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);
  ------------------
  |  |  511|  3.81k|#  define png_voidcast(type, value) (value)
  ------------------
  120|  3.81k|}
OSS_FUZZ_png_zfree:
  125|  3.81k|{
  126|  3.81k|   png_free(png_voidcast(png_const_structrp,png_ptr), ptr);
  ------------------
  |  |  253|  3.81k|#define png_free OSS_FUZZ_png_free
  ------------------
                 png_free(png_voidcast(png_const_structrp,png_ptr), ptr);
  ------------------
  |  |  511|  3.81k|#  define png_voidcast(type, value) (value)
  ------------------
  127|  3.81k|}
OSS_FUZZ_png_reset_crc:
  134|  55.0k|{
  135|       |   /* The cast is safe because the crc is a 32-bit value. */
  136|  55.0k|   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);
  137|  55.0k|}
OSS_FUZZ_png_calculate_crc:
  146|   109k|{
  147|   109k|   int need_crc = 1;
  148|       |
  149|   109k|   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
  ------------------
  |  |  917|   109k|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  ------------------
  |  Branch (149:8): [True: 97.7k, False: 12.1k]
  ------------------
  150|  97.7k|   {
  151|  97.7k|      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
  ------------------
  |  |  703|  97.7k|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|  97.7k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|  97.7k|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|  97.7k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
  |  Branch (151:11): [True: 75.5k, False: 22.1k]
  ------------------
  152|  97.7k|          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
  ------------------
  |  |  679|  97.7k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  ------------------
                        (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
  ------------------
  |  |  680|  97.7k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  ------------------
  153|  75.5k|         need_crc = 0;
  154|  97.7k|   }
  155|       |
  156|  12.1k|   else /* critical */
  157|  12.1k|   {
  158|  12.1k|      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
  ------------------
  |  |  682|  12.1k|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  ------------------
  |  Branch (158:11): [True: 9.32k, False: 2.85k]
  ------------------
  159|  9.32k|         need_crc = 0;
  160|  12.1k|   }
  161|       |
  162|       |   /* 'uLong' is defined in zlib.h as unsigned long; this means that on some
  163|       |    * systems it is a 64-bit value.  crc32, however, returns 32 bits so the
  164|       |    * following cast is safe.  'uInt' may be no more than 16 bits, so it is
  165|       |    * necessary to perform a loop here.
  166|       |    */
  167|   109k|   if (need_crc != 0 && length > 0)
  ------------------
  |  Branch (167:8): [True: 25.0k, False: 84.9k]
  |  Branch (167:25): [True: 25.0k, False: 0]
  ------------------
  168|  25.0k|   {
  169|  25.0k|      uLong crc = png_ptr->crc; /* Should never issue a warning */
  170|       |
  171|  25.0k|      do
  172|  25.0k|      {
  173|  25.0k|         uInt safe_length = (uInt)length;
  174|  25.0k|#ifndef __COVERITY__
  175|  25.0k|         if (safe_length == 0)
  ------------------
  |  Branch (175:14): [True: 0, False: 25.0k]
  ------------------
  176|      0|            safe_length = (uInt)-1; /* evil, but safe */
  177|  25.0k|#endif
  178|       |
  179|  25.0k|         crc = crc32(crc, ptr, safe_length);
  180|       |
  181|       |         /* The following should never issue compiler warnings; if they do the
  182|       |          * target system has characteristics that will probably violate other
  183|       |          * assumptions within the libpng code.
  184|       |          */
  185|  25.0k|         ptr += safe_length;
  186|  25.0k|         length -= safe_length;
  187|  25.0k|      }
  188|  25.0k|      while (length > 0);
  ------------------
  |  Branch (188:14): [True: 0, False: 25.0k]
  ------------------
  189|       |
  190|       |      /* And the following is always safe because the crc is only 32 bits. */
  191|  25.0k|      png_ptr->crc = (png_uint_32)crc;
  192|  25.0k|   }
  193|   109k|}
OSS_FUZZ_png_user_version_check:
  200|  2.60k|{
  201|       |   /* Libpng versions 1.0.0 and later are binary compatible if the version
  202|       |    * string matches through the second '.'; we must recompile any
  203|       |    * applications that use any older library version.
  204|       |    */
  205|       |
  206|  2.60k|   if (user_png_ver != NULL)
  ------------------
  |  Branch (206:8): [True: 2.60k, False: 0]
  ------------------
  207|  2.60k|   {
  208|  2.60k|      int i = -1;
  209|  2.60k|      int found_dots = 0;
  210|       |
  211|  2.60k|      do
  212|  10.4k|      {
  213|  10.4k|         i++;
  214|  10.4k|         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])
  ------------------
  |  |  277|  10.4k|#define PNG_LIBPNG_VER_STRING "1.6.48.git"
  ------------------
  |  Branch (214:14): [True: 0, False: 10.4k]
  ------------------
  215|      0|            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
  ------------------
  |  |  688|      0|#define PNG_FLAG_LIBRARY_MISMATCH        0x20000U
  ------------------
  216|  10.4k|         if (user_png_ver[i] == '.')
  ------------------
  |  Branch (216:14): [True: 5.20k, False: 5.20k]
  ------------------
  217|  5.20k|            found_dots++;
  218|  10.4k|      } while (found_dots < 2 && user_png_ver[i] != 0 &&
  ------------------
  |  Branch (218:16): [True: 7.80k, False: 2.60k]
  |  Branch (218:34): [True: 7.80k, False: 0]
  ------------------
  219|  10.4k|            PNG_LIBPNG_VER_STRING[i] != 0);
  ------------------
  |  |  277|  7.80k|#define PNG_LIBPNG_VER_STRING "1.6.48.git"
  ------------------
  |  Branch (219:13): [True: 7.80k, False: 0]
  ------------------
  220|  2.60k|   }
  221|       |
  222|      0|   else
  223|      0|      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
  ------------------
  |  |  688|      0|#define PNG_FLAG_LIBRARY_MISMATCH        0x20000U
  ------------------
  224|       |
  225|  2.60k|   if ((png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH) != 0)
  ------------------
  |  |  688|  2.60k|#define PNG_FLAG_LIBRARY_MISMATCH        0x20000U
  ------------------
  |  Branch (225:8): [True: 0, False: 2.60k]
  ------------------
  226|      0|   {
  227|      0|#ifdef PNG_WARNINGS_SUPPORTED
  228|      0|      size_t pos = 0;
  229|      0|      char m[128];
  230|       |
  231|      0|      pos = png_safecat(m, (sizeof m), pos,
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  232|      0|          "Application built with libpng-");
  233|      0|      pos = png_safecat(m, (sizeof m), pos, user_png_ver);
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  234|      0|      pos = png_safecat(m, (sizeof m), pos, " but running with ");
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  235|      0|      pos = png_safecat(m, (sizeof m), pos, PNG_LIBPNG_VER_STRING);
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
                    pos = png_safecat(m, (sizeof m), pos, PNG_LIBPNG_VER_STRING);
  ------------------
  |  |  277|      0|#define PNG_LIBPNG_VER_STRING "1.6.48.git"
  ------------------
  236|      0|      PNG_UNUSED(pos)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
  237|       |
  238|      0|      png_warning(png_ptr, m);
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  239|      0|#endif
  240|       |
  241|       |#ifdef PNG_ERROR_NUMBERS_SUPPORTED
  242|       |      png_ptr->flags = 0;
  243|       |#endif
  244|       |
  245|      0|      return 0;
  246|      0|   }
  247|       |
  248|       |   /* Success return. */
  249|  2.60k|   return 1;
  250|  2.60k|}
OSS_FUZZ_png_create_png_struct:
  259|  2.60k|{
  260|  2.60k|   png_struct create_struct;
  261|  2.60k|#  ifdef PNG_SETJMP_SUPPORTED
  262|  2.60k|      jmp_buf create_jmp_buf;
  263|  2.60k|#  endif
  264|       |
  265|       |   /* This temporary stack-allocated structure is used to provide a place to
  266|       |    * build enough context to allow the user provided memory allocator (if any)
  267|       |    * to be called.
  268|       |    */
  269|  2.60k|   memset(&create_struct, 0, (sizeof create_struct));
  270|       |
  271|  2.60k|#  ifdef PNG_USER_LIMITS_SUPPORTED
  272|  2.60k|      create_struct.user_width_max = PNG_USER_WIDTH_MAX;
  ------------------
  |  |  225|  2.60k|#define PNG_USER_WIDTH_MAX 1000000
  ------------------
  273|  2.60k|      create_struct.user_height_max = PNG_USER_HEIGHT_MAX;
  ------------------
  |  |  224|  2.60k|#define PNG_USER_HEIGHT_MAX 1000000
  ------------------
  274|       |
  275|  2.60k|#     ifdef PNG_USER_CHUNK_CACHE_MAX
  276|  2.60k|      create_struct.user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
  ------------------
  |  |  222|  2.60k|#define PNG_USER_CHUNK_CACHE_MAX 1000
  ------------------
  277|  2.60k|#     endif
  278|       |
  279|  2.60k|#     if PNG_USER_CHUNK_MALLOC_MAX > 0 /* default to compile-time limit */
  280|  2.60k|      create_struct.user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
  ------------------
  |  |  223|  2.60k|#define PNG_USER_CHUNK_MALLOC_MAX 8000000
  ------------------
  281|       |
  282|       |      /* No compile-time limit, so initialize to the system limit: */
  283|       |#     elif defined PNG_MAX_MALLOC_64K /* legacy system limit */
  284|       |      create_struct.user_chunk_malloc_max = 65536U;
  285|       |
  286|       |#     else /* modern system limit SIZE_MAX (C99) */
  287|       |      create_struct.user_chunk_malloc_max = PNG_SIZE_MAX;
  288|       |#     endif
  289|  2.60k|#  endif
  290|       |
  291|       |   /* The following two API calls simply set fields in png_struct, so it is safe
  292|       |    * to do them now even though error handling is not yet set up.
  293|       |    */
  294|  2.60k|#  ifdef PNG_USER_MEM_SUPPORTED
  295|  2.60k|      png_set_mem_fn(&create_struct, mem_ptr, malloc_fn, free_fn);
  ------------------
  |  |  407|  2.60k|#define png_set_mem_fn OSS_FUZZ_png_set_mem_fn
  ------------------
  296|       |#  else
  297|       |      PNG_UNUSED(mem_ptr)
  298|       |      PNG_UNUSED(malloc_fn)
  299|       |      PNG_UNUSED(free_fn)
  300|       |#  endif
  301|       |
  302|       |   /* (*error_fn) can return control to the caller after the error_ptr is set,
  303|       |    * this will result in a memory leak unless the error_fn does something
  304|       |    * extremely sophisticated.  The design lacks merit but is implicit in the
  305|       |    * API.
  306|       |    */
  307|  2.60k|   png_set_error_fn(&create_struct, error_ptr, error_fn, warn_fn);
  ------------------
  |  |  387|  2.60k|#define png_set_error_fn OSS_FUZZ_png_set_error_fn
  ------------------
  308|       |
  309|  2.60k|#  ifdef PNG_SETJMP_SUPPORTED
  310|  2.60k|      if (!setjmp(create_jmp_buf))
  ------------------
  |  Branch (310:11): [True: 2.60k, False: 0]
  ------------------
  311|  2.60k|#  endif
  312|  2.60k|      {
  313|  2.60k|#  ifdef PNG_SETJMP_SUPPORTED
  314|       |         /* Temporarily fake out the longjmp information until we have
  315|       |          * successfully completed this function.  This only works if we have
  316|       |          * setjmp() support compiled in, but it is safe - this stuff should
  317|       |          * never happen.
  318|       |          */
  319|  2.60k|         create_struct.jmp_buf_ptr = &create_jmp_buf;
  320|  2.60k|         create_struct.jmp_buf_size = 0; /*stack allocation*/
  321|  2.60k|         create_struct.longjmp_fn = longjmp;
  322|  2.60k|#  endif
  323|       |         /* Call the general version checker (shared with read and write code):
  324|       |          */
  325|  2.60k|         if (png_user_version_check(&create_struct, user_png_ver) != 0)
  ------------------
  |  |    7|  2.60k|#define png_user_version_check OSS_FUZZ_png_user_version_check
  ------------------
  |  Branch (325:14): [True: 2.60k, False: 0]
  ------------------
  326|  2.60k|         {
  327|  2.60k|            png_structrp png_ptr = png_voidcast(png_structrp,
  ------------------
  |  |  511|  2.60k|#  define png_voidcast(type, value) (value)
  ------------------
  328|  2.60k|                png_malloc_warn(&create_struct, (sizeof *png_ptr)));
  329|       |
  330|  2.60k|            if (png_ptr != NULL)
  ------------------
  |  Branch (330:17): [True: 2.60k, False: 0]
  ------------------
  331|  2.60k|            {
  332|       |               /* png_ptr->zstream holds a back-pointer to the png_struct, so
  333|       |                * this can only be done now:
  334|       |                */
  335|  2.60k|               create_struct.zstream.zalloc = png_zalloc;
  ------------------
  |  |   14|  2.60k|#define png_zalloc OSS_FUZZ_png_zalloc
  ------------------
  336|  2.60k|               create_struct.zstream.zfree = png_zfree;
  ------------------
  |  |   15|  2.60k|#define png_zfree OSS_FUZZ_png_zfree
  ------------------
  337|  2.60k|               create_struct.zstream.opaque = png_ptr;
  338|       |
  339|  2.60k|#              ifdef PNG_SETJMP_SUPPORTED
  340|       |               /* Eliminate the local error handling: */
  341|  2.60k|               create_struct.jmp_buf_ptr = NULL;
  342|  2.60k|               create_struct.jmp_buf_size = 0;
  343|  2.60k|               create_struct.longjmp_fn = 0;
  344|  2.60k|#              endif
  345|       |
  346|  2.60k|               *png_ptr = create_struct;
  347|       |
  348|       |               /* This is the successful return point */
  349|  2.60k|               return png_ptr;
  350|  2.60k|            }
  351|  2.60k|         }
  352|  2.60k|      }
  353|       |
  354|       |   /* A longjmp because of a bug in the application storage allocator or a
  355|       |    * simple failure to allocate the png_struct.
  356|       |    */
  357|      0|   return NULL;
  358|  2.60k|}
OSS_FUZZ_png_create_info_struct:
  363|  4.65k|{
  364|  4.65k|   png_inforp info_ptr;
  365|       |
  366|  4.65k|   png_debug(1, "in png_create_info_struct");
  ------------------
  |  |  148|  4.65k|#  define png_debug(l, m) ((void)0)
  ------------------
  367|       |
  368|  4.65k|   if (png_ptr == NULL)
  ------------------
  |  Branch (368:8): [True: 0, False: 4.65k]
  ------------------
  369|      0|      return NULL;
  370|       |
  371|       |   /* Use the internal API that does not (or at least should not) error out, so
  372|       |    * that this call always returns ok.  The application typically sets up the
  373|       |    * error handling *after* creating the info_struct because this is the way it
  374|       |    * has always been done in 'example.c'.
  375|       |    */
  376|  4.65k|   info_ptr = png_voidcast(png_inforp, png_malloc_base(png_ptr,
  ------------------
  |  |  511|  4.65k|#  define png_voidcast(type, value) (value)
  ------------------
  377|  4.65k|       (sizeof *info_ptr)));
  378|       |
  379|  4.65k|   if (info_ptr != NULL)
  ------------------
  |  Branch (379:8): [True: 4.65k, False: 0]
  ------------------
  380|  4.65k|      memset(info_ptr, 0, (sizeof *info_ptr));
  381|       |
  382|  4.65k|   return info_ptr;
  383|  4.65k|}
OSS_FUZZ_png_destroy_info_struct:
  395|  5.20k|{
  396|  5.20k|   png_inforp info_ptr = NULL;
  397|       |
  398|  5.20k|   png_debug(1, "in png_destroy_info_struct");
  ------------------
  |  |  148|  5.20k|#  define png_debug(l, m) ((void)0)
  ------------------
  399|       |
  400|  5.20k|   if (png_ptr == NULL)
  ------------------
  |  Branch (400:8): [True: 0, False: 5.20k]
  ------------------
  401|      0|      return;
  402|       |
  403|  5.20k|   if (info_ptr_ptr != NULL)
  ------------------
  |  Branch (403:8): [True: 4.65k, False: 548]
  ------------------
  404|  4.65k|      info_ptr = *info_ptr_ptr;
  405|       |
  406|  5.20k|   if (info_ptr != NULL)
  ------------------
  |  Branch (406:8): [True: 4.65k, False: 548]
  ------------------
  407|  4.65k|   {
  408|       |      /* Do this first in case of an error below; if the app implements its own
  409|       |       * memory management this can lead to png_free calling png_error, which
  410|       |       * will abort this routine and return control to the app error handler.
  411|       |       * An infinite loop may result if it then tries to free the same info
  412|       |       * ptr.
  413|       |       */
  414|  4.65k|      *info_ptr_ptr = NULL;
  415|       |
  416|  4.65k|      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
  ------------------
  |  |  254|  4.65k|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
                    png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
  ------------------
  |  | 1772|  4.65k|#define PNG_FREE_ALL  0xffffU
  ------------------
  417|  4.65k|      memset(info_ptr, 0, (sizeof *info_ptr));
  418|  4.65k|      png_free(png_ptr, info_ptr);
  ------------------
  |  |  253|  4.65k|#define png_free OSS_FUZZ_png_free
  ------------------
  419|  4.65k|   }
  420|  5.20k|}
OSS_FUZZ_png_free_data:
  480|  5.62k|{
  481|  5.62k|   png_debug(1, "in png_free_data");
  ------------------
  |  |  148|  5.62k|#  define png_debug(l, m) ((void)0)
  ------------------
  482|       |
  483|  5.62k|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (483:8): [True: 0, False: 5.62k]
  |  Branch (483:27): [True: 0, False: 5.62k]
  ------------------
  484|      0|      return;
  485|       |
  486|  5.62k|#ifdef PNG_TEXT_SUPPORTED
  487|       |   /* Free text item num or (if num == -1) all text items */
  488|  5.62k|   if (info_ptr->text != NULL &&
  ------------------
  |  Branch (488:8): [True: 798, False: 4.82k]
  ------------------
  489|  5.62k|       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)
  ------------------
  |  | 1770|    798|#define PNG_FREE_TEXT 0x4000U
  ------------------
  |  Branch (489:8): [True: 778, False: 20]
  ------------------
  490|    778|   {
  491|    778|      if (num != -1)
  ------------------
  |  Branch (491:11): [True: 0, False: 778]
  ------------------
  492|      0|      {
  493|      0|         png_free(png_ptr, info_ptr->text[num].key);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  494|      0|         info_ptr->text[num].key = NULL;
  495|      0|      }
  496|       |
  497|    778|      else
  498|    778|      {
  499|    778|         int i;
  500|       |
  501|  4.10k|         for (i = 0; i < info_ptr->num_text; i++)
  ------------------
  |  Branch (501:22): [True: 3.33k, False: 778]
  ------------------
  502|  3.33k|            png_free(png_ptr, info_ptr->text[i].key);
  ------------------
  |  |  253|  3.33k|#define png_free OSS_FUZZ_png_free
  ------------------
  503|       |
  504|    778|         png_free(png_ptr, info_ptr->text);
  ------------------
  |  |  253|    778|#define png_free OSS_FUZZ_png_free
  ------------------
  505|    778|         info_ptr->text = NULL;
  506|    778|         info_ptr->num_text = 0;
  507|    778|         info_ptr->max_text = 0;
  508|    778|      }
  509|    778|   }
  510|  5.62k|#endif
  511|       |
  512|  5.62k|#ifdef PNG_tRNS_SUPPORTED
  513|       |   /* Free any tRNS entry */
  514|  5.62k|   if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)
  ------------------
  |  | 1769|  5.62k|#define PNG_FREE_TRNS 0x2000U
  ------------------
  |  Branch (514:8): [True: 594, False: 5.03k]
  ------------------
  515|    594|   {
  516|    594|      info_ptr->valid &= ~PNG_INFO_tRNS;
  ------------------
  |  |  734|    594|#define PNG_INFO_tRNS 0x0010U
  ------------------
  517|    594|      png_free(png_ptr, info_ptr->trans_alpha);
  ------------------
  |  |  253|    594|#define png_free OSS_FUZZ_png_free
  ------------------
  518|    594|      info_ptr->trans_alpha = NULL;
  519|    594|      info_ptr->num_trans = 0;
  520|    594|   }
  521|  5.62k|#endif
  522|       |
  523|  5.62k|#ifdef PNG_sCAL_SUPPORTED
  524|       |   /* Free any sCAL entry */
  525|  5.62k|   if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)
  ------------------
  |  | 1763|  5.62k|#define PNG_FREE_SCAL 0x0100U
  ------------------
  |  Branch (525:8): [True: 111, False: 5.51k]
  ------------------
  526|    111|   {
  527|    111|      png_free(png_ptr, info_ptr->scal_s_width);
  ------------------
  |  |  253|    111|#define png_free OSS_FUZZ_png_free
  ------------------
  528|    111|      png_free(png_ptr, info_ptr->scal_s_height);
  ------------------
  |  |  253|    111|#define png_free OSS_FUZZ_png_free
  ------------------
  529|    111|      info_ptr->scal_s_width = NULL;
  530|    111|      info_ptr->scal_s_height = NULL;
  531|    111|      info_ptr->valid &= ~PNG_INFO_sCAL;
  ------------------
  |  |  744|    111|#define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
  ------------------
  532|    111|   }
  533|  5.62k|#endif
  534|       |
  535|  5.62k|#ifdef PNG_pCAL_SUPPORTED
  536|       |   /* Free any pCAL entry */
  537|  5.62k|   if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)
  ------------------
  |  | 1762|  5.62k|#define PNG_FREE_PCAL 0x0080U
  ------------------
  |  Branch (537:8): [True: 58, False: 5.56k]
  ------------------
  538|     58|   {
  539|     58|      png_free(png_ptr, info_ptr->pcal_purpose);
  ------------------
  |  |  253|     58|#define png_free OSS_FUZZ_png_free
  ------------------
  540|     58|      png_free(png_ptr, info_ptr->pcal_units);
  ------------------
  |  |  253|     58|#define png_free OSS_FUZZ_png_free
  ------------------
  541|     58|      info_ptr->pcal_purpose = NULL;
  542|     58|      info_ptr->pcal_units = NULL;
  543|       |
  544|     58|      if (info_ptr->pcal_params != NULL)
  ------------------
  |  Branch (544:11): [True: 58, False: 0]
  ------------------
  545|     58|         {
  546|     58|            int i;
  547|       |
  548|    174|            for (i = 0; i < info_ptr->pcal_nparams; i++)
  ------------------
  |  Branch (548:25): [True: 116, False: 58]
  ------------------
  549|    116|               png_free(png_ptr, info_ptr->pcal_params[i]);
  ------------------
  |  |  253|    116|#define png_free OSS_FUZZ_png_free
  ------------------
  550|       |
  551|     58|            png_free(png_ptr, info_ptr->pcal_params);
  ------------------
  |  |  253|     58|#define png_free OSS_FUZZ_png_free
  ------------------
  552|     58|            info_ptr->pcal_params = NULL;
  553|     58|         }
  554|     58|      info_ptr->valid &= ~PNG_INFO_pCAL;
  ------------------
  |  |  740|     58|#define PNG_INFO_pCAL 0x0400U
  ------------------
  555|     58|   }
  556|  5.62k|#endif
  557|       |
  558|  5.62k|#ifdef PNG_iCCP_SUPPORTED
  559|       |   /* Free any profile entry */
  560|  5.62k|   if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)
  ------------------
  |  | 1759|  5.62k|#define PNG_FREE_ICCP 0x0010U
  ------------------
  |  Branch (560:8): [True: 0, False: 5.62k]
  ------------------
  561|      0|   {
  562|      0|      png_free(png_ptr, info_ptr->iccp_name);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  563|      0|      png_free(png_ptr, info_ptr->iccp_profile);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  564|      0|      info_ptr->iccp_name = NULL;
  565|      0|      info_ptr->iccp_profile = NULL;
  566|      0|      info_ptr->valid &= ~PNG_INFO_iCCP;
  ------------------
  |  |  742|      0|#define PNG_INFO_iCCP 0x1000U  /* ESR, 1.0.6 */
  ------------------
  567|      0|   }
  568|  5.62k|#endif
  569|       |
  570|  5.62k|#ifdef PNG_sPLT_SUPPORTED
  571|       |   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
  572|  5.62k|   if (info_ptr->splt_palettes != NULL &&
  ------------------
  |  Branch (572:8): [True: 55, False: 5.57k]
  ------------------
  573|  5.62k|       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)
  ------------------
  |  | 1760|     55|#define PNG_FREE_SPLT 0x0020U
  ------------------
  |  Branch (573:8): [True: 52, False: 3]
  ------------------
  574|     52|   {
  575|     52|      if (num != -1)
  ------------------
  |  Branch (575:11): [True: 0, False: 52]
  ------------------
  576|      0|      {
  577|      0|         png_free(png_ptr, info_ptr->splt_palettes[num].name);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  578|      0|         png_free(png_ptr, info_ptr->splt_palettes[num].entries);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  579|      0|         info_ptr->splt_palettes[num].name = NULL;
  580|      0|         info_ptr->splt_palettes[num].entries = NULL;
  581|      0|      }
  582|       |
  583|     52|      else
  584|     52|      {
  585|     52|         int i;
  586|       |
  587|    712|         for (i = 0; i < info_ptr->splt_palettes_num; i++)
  ------------------
  |  Branch (587:22): [True: 660, False: 52]
  ------------------
  588|    660|         {
  589|    660|            png_free(png_ptr, info_ptr->splt_palettes[i].name);
  ------------------
  |  |  253|    660|#define png_free OSS_FUZZ_png_free
  ------------------
  590|    660|            png_free(png_ptr, info_ptr->splt_palettes[i].entries);
  ------------------
  |  |  253|    660|#define png_free OSS_FUZZ_png_free
  ------------------
  591|    660|         }
  592|       |
  593|     52|         png_free(png_ptr, info_ptr->splt_palettes);
  ------------------
  |  |  253|     52|#define png_free OSS_FUZZ_png_free
  ------------------
  594|     52|         info_ptr->splt_palettes = NULL;
  595|     52|         info_ptr->splt_palettes_num = 0;
  596|     52|         info_ptr->valid &= ~PNG_INFO_sPLT;
  ------------------
  |  |  743|     52|#define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
  ------------------
  597|     52|      }
  598|     52|   }
  599|  5.62k|#endif
  600|       |
  601|  5.62k|#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
  602|  5.62k|   if (info_ptr->unknown_chunks != NULL &&
  ------------------
  |  Branch (602:8): [True: 0, False: 5.62k]
  ------------------
  603|  5.62k|       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)
  ------------------
  |  | 1765|      0|#  define PNG_FREE_UNKN 0x0200U
  ------------------
  |  Branch (603:8): [True: 0, False: 0]
  ------------------
  604|      0|   {
  605|      0|      if (num != -1)
  ------------------
  |  Branch (605:11): [True: 0, False: 0]
  ------------------
  606|      0|      {
  607|      0|          png_free(png_ptr, info_ptr->unknown_chunks[num].data);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  608|      0|          info_ptr->unknown_chunks[num].data = NULL;
  609|      0|      }
  610|       |
  611|      0|      else
  612|      0|      {
  613|      0|         int i;
  614|       |
  615|      0|         for (i = 0; i < info_ptr->unknown_chunks_num; i++)
  ------------------
  |  Branch (615:22): [True: 0, False: 0]
  ------------------
  616|      0|            png_free(png_ptr, info_ptr->unknown_chunks[i].data);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  617|       |
  618|      0|         png_free(png_ptr, info_ptr->unknown_chunks);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  619|      0|         info_ptr->unknown_chunks = NULL;
  620|      0|         info_ptr->unknown_chunks_num = 0;
  621|      0|      }
  622|      0|   }
  623|  5.62k|#endif
  624|       |
  625|  5.62k|#ifdef PNG_eXIf_SUPPORTED
  626|       |   /* Free any eXIf entry */
  627|  5.62k|   if (((mask & PNG_FREE_EXIF) & info_ptr->free_me) != 0)
  ------------------
  |  | 1771|  5.62k|#define PNG_FREE_EXIF 0x8000U /* Added at libpng-1.6.31 */
  ------------------
  |  Branch (627:8): [True: 16, False: 5.60k]
  ------------------
  628|     16|   {
  629|     16|      if (info_ptr->exif)
  ------------------
  |  Branch (629:11): [True: 16, False: 0]
  ------------------
  630|     16|      {
  631|     16|         png_free(png_ptr, info_ptr->exif);
  ------------------
  |  |  253|     16|#define png_free OSS_FUZZ_png_free
  ------------------
  632|     16|         info_ptr->exif = NULL;
  633|     16|      }
  634|     16|      info_ptr->valid &= ~PNG_INFO_eXIf;
  ------------------
  |  |  746|     16|#define PNG_INFO_eXIf 0x10000U /* GR-P, 1.6.31 */
  ------------------
  635|     16|   }
  636|  5.62k|#endif
  637|       |
  638|  5.62k|#ifdef PNG_hIST_SUPPORTED
  639|       |   /* Free any hIST entry */
  640|  5.62k|   if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
  ------------------
  |  | 1758|  5.62k|#define PNG_FREE_HIST 0x0008U
  ------------------
  |  Branch (640:8): [True: 0, False: 5.62k]
  ------------------
  641|      0|   {
  642|      0|      png_free(png_ptr, info_ptr->hist);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  643|      0|      info_ptr->hist = NULL;
  644|      0|      info_ptr->valid &= ~PNG_INFO_hIST;
  ------------------
  |  |  736|      0|#define PNG_INFO_hIST 0x0040U
  ------------------
  645|      0|   }
  646|  5.62k|#endif
  647|       |
  648|       |   /* Free any PLTE entry that was internally allocated */
  649|  5.62k|   if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)
  ------------------
  |  | 1768|  5.62k|#define PNG_FREE_PLTE 0x1000U
  ------------------
  |  Branch (649:8): [True: 357, False: 5.26k]
  ------------------
  650|    357|   {
  651|    357|      png_free(png_ptr, info_ptr->palette);
  ------------------
  |  |  253|    357|#define png_free OSS_FUZZ_png_free
  ------------------
  652|    357|      info_ptr->palette = NULL;
  653|    357|      info_ptr->valid &= ~PNG_INFO_PLTE;
  ------------------
  |  |  733|    357|#define PNG_INFO_PLTE 0x0008U
  ------------------
  654|    357|      info_ptr->num_palette = 0;
  655|    357|   }
  656|       |
  657|  5.62k|#ifdef PNG_INFO_IMAGE_SUPPORTED
  658|       |   /* Free any image bits attached to the info structure */
  659|  5.62k|   if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)
  ------------------
  |  | 1761|  5.62k|#define PNG_FREE_ROWS 0x0040U
  ------------------
  |  Branch (659:8): [True: 0, False: 5.62k]
  ------------------
  660|      0|   {
  661|      0|      if (info_ptr->row_pointers != NULL)
  ------------------
  |  Branch (661:11): [True: 0, False: 0]
  ------------------
  662|      0|      {
  663|      0|         png_uint_32 row;
  664|      0|         for (row = 0; row < info_ptr->height; row++)
  ------------------
  |  Branch (664:24): [True: 0, False: 0]
  ------------------
  665|      0|            png_free(png_ptr, info_ptr->row_pointers[row]);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  666|       |
  667|      0|         png_free(png_ptr, info_ptr->row_pointers);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  668|      0|         info_ptr->row_pointers = NULL;
  669|      0|      }
  670|      0|      info_ptr->valid &= ~PNG_INFO_IDAT;
  ------------------
  |  |  745|      0|#define PNG_INFO_IDAT 0x8000U  /* ESR, 1.0.6 */
  ------------------
  671|      0|   }
  672|  5.62k|#endif
  673|       |
  674|  5.62k|   if (num != -1)
  ------------------
  |  Branch (674:8): [True: 967, False: 4.65k]
  ------------------
  675|    967|      mask &= ~PNG_FREE_MUL;
  ------------------
  |  | 1773|    967|#define PNG_FREE_MUL  0x4220U /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
  ------------------
  676|       |
  677|  5.62k|   info_ptr->free_me &= ~mask;
  678|  5.62k|}
OSS_FUZZ_png_get_io_ptr:
  687|   127k|{
  688|   127k|   if (png_ptr == NULL)
  ------------------
  |  Branch (688:8): [True: 0, False: 127k]
  ------------------
  689|      0|      return NULL;
  690|       |
  691|   127k|   return png_ptr->io_ptr;
  692|   127k|}
OSS_FUZZ_png_handle_as_unknown:
  927|  52.4k|{
  928|       |   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
  929|  52.4k|   png_const_bytep p, p_end;
  930|       |
  931|  52.4k|   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)
  ------------------
  |  Branch (931:8): [True: 0, False: 52.4k]
  |  Branch (931:27): [True: 0, False: 52.4k]
  |  Branch (931:49): [True: 52.4k, False: 0]
  ------------------
  932|  52.4k|      return PNG_HANDLE_CHUNK_AS_DEFAULT;
  ------------------
  |  | 2449|  52.4k|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
  933|       |
  934|      0|   p_end = png_ptr->chunk_list;
  935|      0|   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */
  936|       |
  937|       |   /* The code is the fifth byte after each four byte string.  Historically this
  938|       |    * code was always searched from the end of the list, this is no longer
  939|       |    * necessary because the 'set' routine handles duplicate entries correctly.
  940|       |    */
  941|      0|   do /* num_chunk_list > 0, so at least one */
  942|      0|   {
  943|      0|      p -= 5;
  944|       |
  945|      0|      if (memcmp(chunk_name, p, 4) == 0)
  ------------------
  |  Branch (945:11): [True: 0, False: 0]
  ------------------
  946|      0|         return p[4];
  947|      0|   }
  948|      0|   while (p > p_end);
  ------------------
  |  Branch (948:11): [True: 0, False: 0]
  ------------------
  949|       |
  950|       |   /* This means that known chunks should be processed and unknown chunks should
  951|       |    * be handled according to the value of png_ptr->unknown_default; this can be
  952|       |    * confusing because, as a result, there are two levels of defaulting for
  953|       |    * unknown chunks.
  954|       |    */
  955|      0|   return PNG_HANDLE_CHUNK_AS_DEFAULT;
  ------------------
  |  | 2449|      0|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
  956|      0|}
OSS_FUZZ_png_chunk_unknown_handling:
  962|  52.4k|{
  963|  52.4k|   png_byte chunk_string[5];
  964|       |
  965|  52.4k|   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
  ------------------
  |  |  914|  52.4k|   (void)(PNG_STRING_FROM_CHUNK(s,c), ((char*)(s))[4] = 0)
  |  |  ------------------
  |  |  |  |  907|  52.4k|   (void)(((char*)(s))[0]=(char)(((c)>>24) & 0xff), \
  |  |  |  |  908|  52.4k|   ((char*)(s))[1]=(char)(((c)>>16) & 0xff),\
  |  |  |  |  909|  52.4k|   ((char*)(s))[2]=(char)(((c)>>8) & 0xff), \
  |  |  |  |  910|  52.4k|   ((char*)(s))[3]=(char)((c & 0xff)))
  |  |  ------------------
  ------------------
  966|  52.4k|   return png_handle_as_unknown(png_ptr, chunk_string);
  ------------------
  |  |  341|  52.4k|#define png_handle_as_unknown OSS_FUZZ_png_handle_as_unknown
  ------------------
  967|  52.4k|}
OSS_FUZZ_png_zstream_error:
  999|  3.47k|{
 1000|       |   /* Translate 'ret' into an appropriate error string, priority is given to the
 1001|       |    * one in zstream if set.  This always returns a string, even in cases like
 1002|       |    * Z_OK or Z_STREAM_END where the error code is a success code.
 1003|       |    */
 1004|  3.47k|   if (png_ptr->zstream.msg == NULL) switch (ret)
  ------------------
  |  Branch (1004:8): [True: 1.56k, False: 1.91k]
  ------------------
 1005|  1.56k|   {
 1006|      0|      default:
  ------------------
  |  Branch (1006:7): [True: 0, False: 1.56k]
  ------------------
 1007|    525|      case Z_OK:
  ------------------
  |  Branch (1007:7): [True: 525, False: 1.04k]
  ------------------
 1008|    525|         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return code");
  ------------------
  |  |   40|    525|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1009|    525|         break;
 1010|       |
 1011|    634|      case Z_STREAM_END:
  ------------------
  |  Branch (1011:7): [True: 634, False: 935]
  ------------------
 1012|       |         /* Normal exit */
 1013|    634|         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected end of LZ stream");
  ------------------
  |  |   40|    634|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1014|    634|         break;
 1015|       |
 1016|      1|      case Z_NEED_DICT:
  ------------------
  |  Branch (1016:7): [True: 1, False: 1.56k]
  ------------------
 1017|       |         /* This means the deflate stream did not have a dictionary; this
 1018|       |          * indicates a bogus PNG.
 1019|       |          */
 1020|      1|         png_ptr->zstream.msg = PNGZ_MSG_CAST("missing LZ dictionary");
  ------------------
  |  |   40|      1|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1021|      1|         break;
 1022|       |
 1023|      0|      case Z_ERRNO:
  ------------------
  |  Branch (1023:7): [True: 0, False: 1.56k]
  ------------------
 1024|       |         /* gz APIs only: should not happen */
 1025|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("zlib IO error");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1026|      0|         break;
 1027|       |
 1028|      0|      case Z_STREAM_ERROR:
  ------------------
  |  Branch (1028:7): [True: 0, False: 1.56k]
  ------------------
 1029|       |         /* internal libpng error */
 1030|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("bad parameters to zlib");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1031|      0|         break;
 1032|       |
 1033|      0|      case Z_DATA_ERROR:
  ------------------
  |  Branch (1033:7): [True: 0, False: 1.56k]
  ------------------
 1034|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("damaged LZ stream");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1035|      0|         break;
 1036|       |
 1037|      0|      case Z_MEM_ERROR:
  ------------------
  |  Branch (1037:7): [True: 0, False: 1.56k]
  ------------------
 1038|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("insufficient memory");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1039|      0|         break;
 1040|       |
 1041|    409|      case Z_BUF_ERROR:
  ------------------
  |  Branch (1041:7): [True: 409, False: 1.16k]
  ------------------
 1042|       |         /* End of input or output; not a problem if the caller is doing
 1043|       |          * incremental read or write.
 1044|       |          */
 1045|    409|         png_ptr->zstream.msg = PNGZ_MSG_CAST("truncated");
  ------------------
  |  |   40|    409|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1046|    409|         break;
 1047|       |
 1048|      0|      case Z_VERSION_ERROR:
  ------------------
  |  Branch (1048:7): [True: 0, False: 1.56k]
  ------------------
 1049|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("unsupported zlib version");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1050|      0|         break;
 1051|       |
 1052|      0|      case PNG_UNEXPECTED_ZLIB_RETURN:
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  |  Branch (1052:7): [True: 0, False: 1.56k]
  ------------------
 1053|       |         /* Compile errors here mean that zlib now uses the value co-opted in
 1054|       |          * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above
 1055|       |          * and change pngpriv.h.  Note that this message is "... return",
 1056|       |          * whereas the default/Z_OK one is "... return code".
 1057|       |          */
 1058|      0|         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
 1059|      0|         break;
 1060|  1.56k|   }
 1061|  3.47k|}
OSS_FUZZ_png_icc_check_length:
 1591|    525|{
 1592|    525|   if (!icc_check_length(png_ptr, name, profile_length))
  ------------------
  |  Branch (1592:8): [True: 18, False: 507]
  ------------------
 1593|     18|      return 0;
 1594|       |
 1595|       |   /* This needs to be here because the 'normal' check is in
 1596|       |    * png_decompress_chunk, yet this happens after the attempt to
 1597|       |    * png_malloc_base the required data.  We only need this on read; on write
 1598|       |    * the caller supplies the profile buffer so libpng doesn't allocate it.  See
 1599|       |    * the call to icc_check_length below (the write case).
 1600|       |    */
 1601|    507|   if (profile_length > png_chunk_max(png_ptr))
  ------------------
  |  | 1097|    507|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
  |  Branch (1601:8): [True: 440, False: 67]
  ------------------
 1602|    440|      return png_icc_profile_error(png_ptr, name, profile_length,
 1603|    440|            "profile too long");
 1604|       |
 1605|     67|   return 1;
 1606|    507|}
OSS_FUZZ_png_icc_check_header:
 1612|     67|{
 1613|     67|   png_uint_32 temp;
 1614|       |
 1615|       |   /* Length check; this cannot be ignored in this code because profile_length
 1616|       |    * is used later to check the tag table, so even if the profile seems over
 1617|       |    * long profile_length from the caller must be correct.  The caller can fix
 1618|       |    * this up on read or write by just passing in the profile header length.
 1619|       |    */
 1620|     67|   temp = png_get_uint_32(profile);
  ------------------
  |  |  322|     67|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     67|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     67|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     67|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     67|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     67|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1621|     67|   if (temp != profile_length)
  ------------------
  |  Branch (1621:8): [True: 0, False: 67]
  ------------------
 1622|      0|      return png_icc_profile_error(png_ptr, name, temp,
 1623|      0|          "length does not match profile");
 1624|       |
 1625|     67|   temp = (png_uint_32) (*(profile+8));
 1626|     67|   if (temp > 3 && (profile_length & 3))
  ------------------
  |  Branch (1626:8): [True: 53, False: 14]
  |  Branch (1626:20): [True: 3, False: 50]
  ------------------
 1627|      3|      return png_icc_profile_error(png_ptr, name, profile_length,
 1628|      3|          "invalid length");
 1629|       |
 1630|     64|   temp = png_get_uint_32(profile+128); /* tag count: 12 bytes/tag */
  ------------------
  |  |  322|     64|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     64|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     64|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     64|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     64|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     64|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1631|     64|   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */
  ------------------
  |  Branch (1631:8): [True: 11, False: 53]
  ------------------
 1632|     64|      profile_length < 132+12*temp) /* truncated tag table */
  ------------------
  |  Branch (1632:7): [True: 11, False: 42]
  ------------------
 1633|     22|      return png_icc_profile_error(png_ptr, name, temp,
 1634|     22|          "tag count too large");
 1635|       |
 1636|       |   /* The 'intent' must be valid or we can't store it, ICC limits the intent to
 1637|       |    * 16 bits.
 1638|       |    */
 1639|     42|   temp = png_get_uint_32(profile+64);
  ------------------
  |  |  322|     42|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     42|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     42|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     42|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     42|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     42|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1640|     42|   if (temp >= 0xffff) /* The ICC limit */
  ------------------
  |  Branch (1640:8): [True: 18, False: 24]
  ------------------
 1641|     18|      return png_icc_profile_error(png_ptr, name, temp,
 1642|     18|          "invalid rendering intent");
 1643|       |
 1644|       |   /* This is just a warning because the profile may be valid in future
 1645|       |    * versions.
 1646|       |    */
 1647|     24|   if (temp >= PNG_sRGB_INTENT_LAST)
  ------------------
  |  |  717|     24|#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */
  ------------------
  |  Branch (1647:8): [True: 13, False: 11]
  ------------------
 1648|     13|      (void)png_icc_profile_error(png_ptr, name, temp,
 1649|     13|          "intent outside defined range");
 1650|       |
 1651|       |   /* At this point the tag table can't be checked because it hasn't necessarily
 1652|       |    * been loaded; however, various header fields can be checked.  These checks
 1653|       |    * are for values permitted by the PNG spec in an ICC profile; the PNG spec
 1654|       |    * restricts the profiles that can be passed in an iCCP chunk (they must be
 1655|       |    * appropriate to processing PNG data!)
 1656|       |    */
 1657|       |
 1658|       |   /* Data checks (could be skipped).  These checks must be independent of the
 1659|       |    * version number; however, the version number doesn't accommodate changes in
 1660|       |    * the header fields (just the known tags and the interpretation of the
 1661|       |    * data.)
 1662|       |    */
 1663|     24|   temp = png_get_uint_32(profile+36); /* signature 'ascp' */
  ------------------
  |  |  322|     24|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     24|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     24|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     24|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     24|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     24|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1664|     24|   if (temp != 0x61637370)
  ------------------
  |  Branch (1664:8): [True: 24, False: 0]
  ------------------
 1665|     24|      return png_icc_profile_error(png_ptr, name, temp,
 1666|     24|          "invalid signature");
 1667|       |
 1668|       |   /* Currently the PCS illuminant/adopted white point (the computational
 1669|       |    * white point) are required to be D50,
 1670|       |    * however the profile contains a record of the illuminant so perhaps ICC
 1671|       |    * expects to be able to change this in the future (despite the rationale in
 1672|       |    * the introduction for using a fixed PCS adopted white.)  Consequently the
 1673|       |    * following is just a warning.
 1674|       |    */
 1675|      0|   if (memcmp(profile+68, D50_nCIEXYZ, 12) != 0)
  ------------------
  |  Branch (1675:8): [True: 0, False: 0]
  ------------------
 1676|      0|      (void)png_icc_profile_error(png_ptr, name, 0/*no tag value*/,
 1677|      0|          "PCS illuminant is not D50");
 1678|       |
 1679|       |   /* The PNG spec requires this:
 1680|       |    * "If the iCCP chunk is present, the image samples conform to the colour
 1681|       |    * space represented by the embedded ICC profile as defined by the
 1682|       |    * International Color Consortium [ICC]. The colour space of the ICC profile
 1683|       |    * shall be an RGB colour space for colour images (PNG colour types 2, 3, and
 1684|       |    * 6), or a greyscale colour space for greyscale images (PNG colour types 0
 1685|       |    * and 4)."
 1686|       |    *
 1687|       |    * This checking code ensures the embedded profile (on either read or write)
 1688|       |    * conforms to the specification requirements.  Notice that an ICC 'gray'
 1689|       |    * color-space profile contains the information to transform the monochrome
 1690|       |    * data to XYZ or L*a*b (according to which PCS the profile uses) and this
 1691|       |    * should be used in preference to the standard libpng K channel replication
 1692|       |    * into R, G and B channels.
 1693|       |    *
 1694|       |    * Previously it was suggested that an RGB profile on grayscale data could be
 1695|       |    * handled.  However it it is clear that using an RGB profile in this context
 1696|       |    * must be an error - there is no specification of what it means.  Thus it is
 1697|       |    * almost certainly more correct to ignore the profile.
 1698|       |    */
 1699|      0|   temp = png_get_uint_32(profile+16); /* data colour space field */
  ------------------
  |  |  322|      0|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|      0|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|      0|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|      0|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|      0|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|      0|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1700|      0|   switch (temp)
 1701|      0|   {
 1702|      0|      case 0x52474220: /* 'RGB ' */
  ------------------
  |  Branch (1702:7): [True: 0, False: 0]
  ------------------
 1703|      0|         if ((color_type & PNG_COLOR_MASK_COLOR) == 0)
  ------------------
  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1703:14): [True: 0, False: 0]
  ------------------
 1704|      0|            return png_icc_profile_error(png_ptr, name, temp,
 1705|      0|                "RGB color space not permitted on grayscale PNG");
 1706|      0|         break;
 1707|       |
 1708|      0|      case 0x47524159: /* 'GRAY' */
  ------------------
  |  Branch (1708:7): [True: 0, False: 0]
  ------------------
 1709|      0|         if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1709:14): [True: 0, False: 0]
  ------------------
 1710|      0|            return png_icc_profile_error(png_ptr, name, temp,
 1711|      0|                "Gray color space not permitted on RGB PNG");
 1712|      0|         break;
 1713|       |
 1714|      0|      default:
  ------------------
  |  Branch (1714:7): [True: 0, False: 0]
  ------------------
 1715|      0|         return png_icc_profile_error(png_ptr, name, temp,
 1716|      0|             "invalid ICC profile color space");
 1717|      0|   }
 1718|       |
 1719|       |   /* It is up to the application to check that the profile class matches the
 1720|       |    * application requirements; the spec provides no guidance, but it's pretty
 1721|       |    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer
 1722|       |    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these
 1723|       |    * cases.  Issue an error for device link or abstract profiles - these don't
 1724|       |    * contain the records necessary to transform the color-space to anything
 1725|       |    * other than the target device (and not even that for an abstract profile).
 1726|       |    * Profiles of these classes may not be embedded in images.
 1727|       |    */
 1728|      0|   temp = png_get_uint_32(profile+12); /* profile/device class */
  ------------------
  |  |  322|      0|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|      0|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|      0|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|      0|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|      0|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|      0|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1729|      0|   switch (temp)
 1730|      0|   {
 1731|      0|      case 0x73636e72: /* 'scnr' */
  ------------------
  |  Branch (1731:7): [True: 0, False: 0]
  ------------------
 1732|      0|      case 0x6d6e7472: /* 'mntr' */
  ------------------
  |  Branch (1732:7): [True: 0, False: 0]
  ------------------
 1733|      0|      case 0x70727472: /* 'prtr' */
  ------------------
  |  Branch (1733:7): [True: 0, False: 0]
  ------------------
 1734|      0|      case 0x73706163: /* 'spac' */
  ------------------
  |  Branch (1734:7): [True: 0, False: 0]
  ------------------
 1735|       |         /* All supported */
 1736|      0|         break;
 1737|       |
 1738|      0|      case 0x61627374: /* 'abst' */
  ------------------
  |  Branch (1738:7): [True: 0, False: 0]
  ------------------
 1739|       |         /* May not be embedded in an image */
 1740|      0|         return png_icc_profile_error(png_ptr, name, temp,
 1741|      0|             "invalid embedded Abstract ICC profile");
 1742|       |
 1743|      0|      case 0x6c696e6b: /* 'link' */
  ------------------
  |  Branch (1743:7): [True: 0, False: 0]
  ------------------
 1744|       |         /* DeviceLink profiles cannot be interpreted in a non-device specific
 1745|       |          * fashion, if an app uses the AToB0Tag in the profile the results are
 1746|       |          * undefined unless the result is sent to the intended device,
 1747|       |          * therefore a DeviceLink profile should not be found embedded in a
 1748|       |          * PNG.
 1749|       |          */
 1750|      0|         return png_icc_profile_error(png_ptr, name, temp,
 1751|      0|             "unexpected DeviceLink ICC profile class");
 1752|       |
 1753|      0|      case 0x6e6d636c: /* 'nmcl' */
  ------------------
  |  Branch (1753:7): [True: 0, False: 0]
  ------------------
 1754|       |         /* A NamedColor profile is also device specific, however it doesn't
 1755|       |          * contain an AToB0 tag that is open to misinterpretation.  Almost
 1756|       |          * certainly it will fail the tests below.
 1757|       |          */
 1758|      0|         (void)png_icc_profile_error(png_ptr, name, temp,
 1759|      0|             "unexpected NamedColor ICC profile class");
 1760|      0|         break;
 1761|       |
 1762|      0|      default:
  ------------------
  |  Branch (1762:7): [True: 0, False: 0]
  ------------------
 1763|       |         /* To allow for future enhancements to the profile accept unrecognized
 1764|       |          * profile classes with a warning, these then hit the test below on the
 1765|       |          * tag content to ensure they are backward compatible with one of the
 1766|       |          * understood profiles.
 1767|       |          */
 1768|      0|         (void)png_icc_profile_error(png_ptr, name, temp,
 1769|      0|             "unrecognized ICC profile class");
 1770|      0|         break;
 1771|      0|   }
 1772|       |
 1773|       |   /* For any profile other than a device link one the PCS must be encoded
 1774|       |    * either in XYZ or Lab.
 1775|       |    */
 1776|      0|   temp = png_get_uint_32(profile+20);
  ------------------
  |  |  322|      0|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|      0|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|      0|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|      0|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|      0|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|      0|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1777|      0|   switch (temp)
 1778|      0|   {
 1779|      0|      case 0x58595a20: /* 'XYZ ' */
  ------------------
  |  Branch (1779:7): [True: 0, False: 0]
  ------------------
 1780|      0|      case 0x4c616220: /* 'Lab ' */
  ------------------
  |  Branch (1780:7): [True: 0, False: 0]
  ------------------
 1781|      0|         break;
 1782|       |
 1783|      0|      default:
  ------------------
  |  Branch (1783:7): [True: 0, False: 0]
  ------------------
 1784|      0|         return png_icc_profile_error(png_ptr, name, temp,
 1785|      0|             "unexpected ICC PCS encoding");
 1786|      0|   }
 1787|       |
 1788|      0|   return 1;
 1789|      0|}
OSS_FUZZ_png_check_IHDR:
 1960|  3.67k|{
 1961|  3.67k|   int error = 0;
 1962|       |
 1963|       |   /* Check for width and height valid values */
 1964|  3.67k|   if (width == 0)
  ------------------
  |  Branch (1964:8): [True: 2, False: 3.67k]
  ------------------
 1965|      2|   {
 1966|      2|      png_warning(png_ptr, "Image width is zero in IHDR");
  ------------------
  |  |  450|      2|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1967|      2|      error = 1;
 1968|      2|   }
 1969|       |
 1970|  3.67k|   if (width > PNG_UINT_31_MAX)
  ------------------
  |  |  647|  3.67k|#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
  ------------------
  |  Branch (1970:8): [True: 0, False: 3.67k]
  ------------------
 1971|      0|   {
 1972|      0|      png_warning(png_ptr, "Invalid image width in IHDR");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1973|      0|      error = 1;
 1974|      0|   }
 1975|       |
 1976|       |   /* The bit mask on the first line below must be at least as big as a
 1977|       |    * png_uint_32.  "~7U" is not adequate on 16-bit systems because it will
 1978|       |    * be an unsigned 16-bit value.  Casting to (png_alloc_size_t) makes the
 1979|       |    * type of the result at least as bit (in bits) as the RHS of the > operator
 1980|       |    * which also avoids a common warning on 64-bit systems that the comparison
 1981|       |    * of (png_uint_32) against the constant value on the RHS will always be
 1982|       |    * false.
 1983|       |    */
 1984|  3.67k|   if (((width + 7) & ~(png_alloc_size_t)7) >
  ------------------
  |  Branch (1984:8): [True: 0, False: 3.67k]
  ------------------
 1985|  3.67k|       (((PNG_SIZE_MAX
  ------------------
  |  |  649|  3.67k|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
 1986|  3.67k|           - 48        /* big_row_buf hack */
 1987|  3.67k|           - 1)        /* filter byte */
 1988|  3.67k|           / 8)        /* 8-byte RGBA pixels */
 1989|  3.67k|           - 1))       /* extra max_pixel_depth pad */
 1990|      0|   {
 1991|       |      /* The size of the row must be within the limits of this architecture.
 1992|       |       * Because the read code can perform arbitrary transformations the
 1993|       |       * maximum size is checked here.  Because the code in png_read_start_row
 1994|       |       * adds extra space "for safety's sake" in several places a conservative
 1995|       |       * limit is used here.
 1996|       |       *
 1997|       |       * NOTE: it would be far better to check the size that is actually used,
 1998|       |       * but the effect in the real world is minor and the changes are more
 1999|       |       * extensive, therefore much more dangerous and much more difficult to
 2000|       |       * write in a way that avoids compiler warnings.
 2001|       |       */
 2002|      0|      png_warning(png_ptr, "Image width is too large for this architecture");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2003|      0|      error = 1;
 2004|      0|   }
 2005|       |
 2006|  3.67k|#ifdef PNG_SET_USER_LIMITS_SUPPORTED
 2007|  3.67k|   if (width > png_ptr->user_width_max)
  ------------------
  |  Branch (2007:8): [True: 4, False: 3.67k]
  ------------------
 2008|       |#else
 2009|       |   if (width > PNG_USER_WIDTH_MAX)
 2010|       |#endif
 2011|      4|   {
 2012|      4|      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
  ------------------
  |  |  450|      4|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2013|      4|      error = 1;
 2014|      4|   }
 2015|       |
 2016|  3.67k|   if (height == 0)
  ------------------
  |  Branch (2016:8): [True: 1, False: 3.67k]
  ------------------
 2017|      1|   {
 2018|      1|      png_warning(png_ptr, "Image height is zero in IHDR");
  ------------------
  |  |  450|      1|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2019|      1|      error = 1;
 2020|      1|   }
 2021|       |
 2022|  3.67k|   if (height > PNG_UINT_31_MAX)
  ------------------
  |  |  647|  3.67k|#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
  ------------------
  |  Branch (2022:8): [True: 0, False: 3.67k]
  ------------------
 2023|      0|   {
 2024|      0|      png_warning(png_ptr, "Invalid image height in IHDR");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2025|      0|      error = 1;
 2026|      0|   }
 2027|       |
 2028|  3.67k|#ifdef PNG_SET_USER_LIMITS_SUPPORTED
 2029|  3.67k|   if (height > png_ptr->user_height_max)
  ------------------
  |  Branch (2029:8): [True: 5, False: 3.67k]
  ------------------
 2030|       |#else
 2031|       |   if (height > PNG_USER_HEIGHT_MAX)
 2032|       |#endif
 2033|      5|   {
 2034|      5|      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
  ------------------
  |  |  450|      5|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2035|      5|      error = 1;
 2036|      5|   }
 2037|       |
 2038|       |   /* Check other values */
 2039|  3.67k|   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
  ------------------
  |  Branch (2039:8): [True: 2.57k, False: 1.10k]
  |  Branch (2039:26): [True: 2.16k, False: 407]
  |  Branch (2039:44): [True: 1.81k, False: 348]
  ------------------
 2040|  3.67k|       bit_depth != 8 && bit_depth != 16)
  ------------------
  |  Branch (2040:8): [True: 503, False: 1.31k]
  |  Branch (2040:26): [True: 10, False: 493]
  ------------------
 2041|     10|   {
 2042|     10|      png_warning(png_ptr, "Invalid bit depth in IHDR");
  ------------------
  |  |  450|     10|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2043|     10|      error = 1;
 2044|     10|   }
 2045|       |
 2046|  3.67k|   if (color_type < 0 || color_type == 1 ||
  ------------------
  |  Branch (2046:8): [True: 0, False: 3.67k]
  |  Branch (2046:26): [True: 1, False: 3.67k]
  ------------------
 2047|  3.67k|       color_type == 5 || color_type > 6)
  ------------------
  |  Branch (2047:8): [True: 1, False: 3.67k]
  |  Branch (2047:27): [True: 3, False: 3.67k]
  ------------------
 2048|      5|   {
 2049|      5|      png_warning(png_ptr, "Invalid color type in IHDR");
  ------------------
  |  |  450|      5|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2050|      5|      error = 1;
 2051|      5|   }
 2052|       |
 2053|  3.67k|   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
  ------------------
  |  |  667|  3.67k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  3.67k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  3.67k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (2053:9): [True: 685, False: 2.99k]
  |  Branch (2053:51): [True: 1, False: 684]
  ------------------
 2054|  3.67k|       ((color_type == PNG_COLOR_TYPE_RGB ||
  ------------------
  |  |  668|  7.35k|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|  3.67k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (2054:10): [True: 481, False: 3.19k]
  ------------------
 2055|  3.67k|         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
  ------------------
  |  |  670|  6.87k|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  3.19k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (2055:10): [True: 83, False: 3.11k]
  ------------------
 2056|  3.67k|         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
  ------------------
  |  |  669|  3.11k|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|  3.11k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  3.11k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (2056:10): [True: 728, False: 2.38k]
  |  Branch (2056:53): [True: 1, False: 1.29k]
  ------------------
 2057|      2|   {
 2058|      2|      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
  ------------------
  |  |  450|      2|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2059|      2|      error = 1;
 2060|      2|   }
 2061|       |
 2062|  3.67k|   if (interlace_type >= PNG_INTERLACE_LAST)
  ------------------
  |  |  687|  3.67k|#define PNG_INTERLACE_LAST        2 /* Not a valid value */
  ------------------
  |  Branch (2062:8): [True: 11, False: 3.66k]
  ------------------
 2063|     11|   {
 2064|     11|      png_warning(png_ptr, "Unknown interlace method in IHDR");
  ------------------
  |  |  450|     11|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2065|     11|      error = 1;
 2066|     11|   }
 2067|       |
 2068|  3.67k|   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
  ------------------
  |  |  676|  3.67k|#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
  ------------------
  |  Branch (2068:8): [True: 8, False: 3.67k]
  ------------------
 2069|      8|   {
 2070|      8|      png_warning(png_ptr, "Unknown compression method in IHDR");
  ------------------
  |  |  450|      8|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2071|      8|      error = 1;
 2072|      8|   }
 2073|       |
 2074|  3.67k|#ifdef PNG_MNG_FEATURES_SUPPORTED
 2075|       |   /* Accept filter_method 64 (intrapixel differencing) only if
 2076|       |    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
 2077|       |    * 2. Libpng did not read a PNG signature (this filter_method is only
 2078|       |    *    used in PNG datastreams that are embedded in MNG datastreams) and
 2079|       |    * 3. The application called png_permit_mng_features with a mask that
 2080|       |    *    included PNG_FLAG_MNG_FILTER_64 and
 2081|       |    * 4. The filter_method is 64 and
 2082|       |    * 5. The color_type is RGB or RGBA
 2083|       |    */
 2084|  3.67k|   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0 &&
  ------------------
  |  |  628|  3.67k|#define PNG_HAVE_PNG_SIGNATURE    0x1000U
  ------------------
  |  Branch (2084:8): [True: 546, False: 3.13k]
  ------------------
 2085|  3.67k|       png_ptr->mng_features_permitted != 0)
  ------------------
  |  Branch (2085:8): [True: 0, False: 546]
  ------------------
 2086|      0|      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2087|       |
 2088|  3.67k|   if (filter_type != PNG_FILTER_TYPE_BASE)
  ------------------
  |  |  680|  3.67k|#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
  ------------------
  |  Branch (2088:8): [True: 9, False: 3.66k]
  ------------------
 2089|      9|   {
 2090|      9|      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
  ------------------
  |  |  871|      9|#define PNG_FLAG_MNG_FILTER_64      0x04
  ------------------
  |  Branch (2090:13): [True: 0, False: 9]
  ------------------
 2091|      9|          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
  ------------------
  |  |  681|      0|#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
  ------------------
  |  Branch (2091:11): [True: 0, False: 0]
  ------------------
 2092|      9|          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
  ------------------
  |  |  628|      0|#define PNG_HAVE_PNG_SIGNATURE    0x1000U
  ------------------
  |  Branch (2092:11): [True: 0, False: 0]
  ------------------
 2093|      9|          (color_type == PNG_COLOR_TYPE_RGB ||
  ------------------
  |  |  668|      0|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (2093:12): [True: 0, False: 0]
  ------------------
 2094|      0|          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
  ------------------
  |  |  669|      0|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (2094:11): [True: 0, False: 0]
  ------------------
 2095|      9|      {
 2096|      9|         png_warning(png_ptr, "Unknown filter method in IHDR");
  ------------------
  |  |  450|      9|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2097|      9|         error = 1;
 2098|      9|      }
 2099|       |
 2100|      9|      if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0)
  ------------------
  |  |  628|      9|#define PNG_HAVE_PNG_SIGNATURE    0x1000U
  ------------------
  |  Branch (2100:11): [True: 0, False: 9]
  ------------------
 2101|      0|      {
 2102|      0|         png_warning(png_ptr, "Invalid filter method in IHDR");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 2103|      0|         error = 1;
 2104|      0|      }
 2105|      9|   }
 2106|       |
 2107|       |#else
 2108|       |   if (filter_type != PNG_FILTER_TYPE_BASE)
 2109|       |   {
 2110|       |      png_warning(png_ptr, "Unknown filter method in IHDR");
 2111|       |      error = 1;
 2112|       |   }
 2113|       |#endif
 2114|       |
 2115|  3.67k|   if (error == 1)
  ------------------
  |  Branch (2115:8): [True: 17, False: 3.66k]
  ------------------
 2116|     17|      png_error(png_ptr, "Invalid IHDR data");
  ------------------
  |  |  252|     17|#define png_error OSS_FUZZ_png_error
  ------------------
 2117|  3.67k|}
OSS_FUZZ_png_check_fp_number:
 2131|  4.67k|{
 2132|  4.67k|   int state = *statep;
 2133|  4.67k|   size_t i = *whereami;
 2134|       |
 2135|  30.7k|   while (i < size)
  ------------------
  |  Branch (2135:11): [True: 30.2k, False: 503]
  ------------------
 2136|  30.2k|   {
 2137|  30.2k|      int type;
 2138|       |      /* First find the type of the next character */
 2139|  30.2k|      switch (string[i])
 2140|  30.2k|      {
 2141|     17|      case 43:  type = PNG_FP_SAW_SIGN;                   break;
  ------------------
  |  | 1896|     17|#define PNG_FP_SAW_SIGN   4  /* Saw +/- in current state */
  ------------------
  |  Branch (2141:7): [True: 17, False: 30.1k]
  ------------------
 2142|  1.87k|      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
  ------------------
  |  | 1896|  1.87k|#define PNG_FP_SAW_SIGN   4  /* Saw +/- in current state */
  ------------------
                    case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
  ------------------
  |  | 1905|  1.87k|#define PNG_FP_NEGATIVE 128  /* A negative number, including "-0" */
  ------------------
  |  Branch (2142:7): [True: 1.87k, False: 28.3k]
  ------------------
 2143|  1.75k|      case 46:  type = PNG_FP_SAW_DOT;                    break;
  ------------------
  |  | 1898|  1.75k|#define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
  ------------------
  |  Branch (2143:7): [True: 1.75k, False: 28.4k]
  ------------------
 2144|    898|      case 48:  type = PNG_FP_SAW_DIGIT;                  break;
  ------------------
  |  | 1897|    898|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2144:7): [True: 898, False: 29.3k]
  ------------------
 2145|  13.7k|      case 49: case 50: case 51: case 52:
  ------------------
  |  Branch (2145:7): [True: 2.40k, False: 27.7k]
  |  Branch (2145:16): [True: 4.62k, False: 25.5k]
  |  Branch (2145:25): [True: 3.76k, False: 26.4k]
  |  Branch (2145:34): [True: 2.91k, False: 27.2k]
  ------------------
 2146|  18.5k|      case 53: case 54: case 55: case 56:
  ------------------
  |  Branch (2146:7): [True: 316, False: 29.8k]
  |  Branch (2146:16): [True: 2.58k, False: 27.6k]
  |  Branch (2146:25): [True: 1.88k, False: 28.3k]
  |  Branch (2146:34): [True: 68, False: 30.1k]
  ------------------
 2147|  20.3k|      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
  ------------------
  |  | 1897|  20.3k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
                    case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
  ------------------
  |  | 1906|  20.3k|#define PNG_FP_NONZERO  256  /* A non-zero value */
  ------------------
  |  Branch (2147:7): [True: 1.81k, False: 28.3k]
  ------------------
 2148|  1.38k|      case 69:
  ------------------
  |  Branch (2148:7): [True: 1.38k, False: 28.8k]
  ------------------
 2149|  2.74k|      case 101: type = PNG_FP_SAW_E;                      break;
  ------------------
  |  | 1899|  2.74k|#define PNG_FP_SAW_E     32  /* Saw an E (or e) in current state */
  ------------------
  |  Branch (2149:7): [True: 1.36k, False: 28.8k]
  ------------------
 2150|  2.53k|      default:  goto PNG_FP_End;
  ------------------
  |  Branch (2150:7): [True: 2.53k, False: 27.6k]
  ------------------
 2151|  30.2k|      }
 2152|       |
 2153|       |      /* Now deal with this type according to the current
 2154|       |       * state, the type is arranged to not overlap the
 2155|       |       * bits of the PNG_FP_STATE.
 2156|       |       */
 2157|  27.6k|      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
  ------------------
  |  | 1895|  27.6k|#define PNG_FP_STATE      3  /* mask for the above */
  ------------------
                    switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
  ------------------
  |  | 1900|  27.6k|#define PNG_FP_SAW_ANY   60  /* Saw any of the above 4 */
  ------------------
 2158|  27.6k|      {
 2159|     64|      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
  ------------------
  |  | 1892|     64|#define PNG_FP_INTEGER    0  /* before or in integer */
  ------------------
                    case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
  ------------------
  |  | 1896|     64|#define PNG_FP_SAW_SIGN   4  /* Saw +/- in current state */
  ------------------
  |  Branch (2159:7): [True: 64, False: 27.6k]
  ------------------
 2160|     64|         if ((state & PNG_FP_SAW_ANY) != 0)
  ------------------
  |  | 1900|     64|#define PNG_FP_SAW_ANY   60  /* Saw any of the above 4 */
  ------------------
  |  Branch (2160:14): [True: 13, False: 51]
  ------------------
 2161|     13|            goto PNG_FP_End; /* not a part of the number */
 2162|       |
 2163|     51|         png_fp_add(state, type);
  ------------------
  |  | 2125|     51|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2164|     51|         break;
 2165|       |
 2166|  1.74k|      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
  ------------------
  |  | 1892|  1.74k|#define PNG_FP_INTEGER    0  /* before or in integer */
  ------------------
                    case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
  ------------------
  |  | 1898|  1.74k|#define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
  ------------------
  |  Branch (2166:7): [True: 1.74k, False: 25.9k]
  ------------------
 2167|       |         /* Ok as trailer, ok as lead of fraction. */
 2168|  1.74k|         if ((state & PNG_FP_SAW_DOT) != 0) /* two dots */
  ------------------
  |  | 1898|  1.74k|#define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
  ------------------
  |  Branch (2168:14): [True: 2, False: 1.74k]
  ------------------
 2169|      2|            goto PNG_FP_End;
 2170|       |
 2171|  1.74k|         else if ((state & PNG_FP_SAW_DIGIT) != 0) /* trailing dot? */
  ------------------
  |  | 1897|  1.74k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2171:19): [True: 1.72k, False: 21]
  ------------------
 2172|  1.72k|            png_fp_add(state, type);
  ------------------
  |  | 2125|  1.72k|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2173|       |
 2174|     21|         else
 2175|     21|            png_fp_set(state, PNG_FP_FRACTION | type);
  ------------------
  |  | 2126|     21|#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
  |  |  ------------------
  |  |  |  | 1907|     21|#define PNG_FP_STICKY   448  /* The above three flags */
  |  |  ------------------
  ------------------
 2176|       |
 2177|  1.74k|         break;
 2178|       |
 2179|  14.5k|      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1892|  14.5k|#define PNG_FP_INTEGER    0  /* before or in integer */
  ------------------
                    case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1897|  14.5k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2179:7): [True: 14.5k, False: 13.1k]
  ------------------
 2180|  14.5k|         if ((state & PNG_FP_SAW_DOT) != 0) /* delayed fraction */
  ------------------
  |  | 1898|  14.5k|#define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
  ------------------
  |  Branch (2180:14): [True: 1.71k, False: 12.7k]
  ------------------
 2181|  1.71k|            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);
  ------------------
  |  | 2126|  1.71k|#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
  |  |  ------------------
  |  |  |  | 1907|  1.71k|#define PNG_FP_STICKY   448  /* The above three flags */
  |  |  ------------------
  ------------------
 2182|       |
 2183|  14.5k|         png_fp_add(state, type | PNG_FP_WAS_VALID);
  ------------------
  |  | 2125|  14.5k|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2184|       |
 2185|  14.5k|         break;
 2186|       |
 2187|  1.98k|      case PNG_FP_INTEGER + PNG_FP_SAW_E:
  ------------------
  |  | 1892|  1.98k|#define PNG_FP_INTEGER    0  /* before or in integer */
  ------------------
                    case PNG_FP_INTEGER + PNG_FP_SAW_E:
  ------------------
  |  | 1899|  1.98k|#define PNG_FP_SAW_E     32  /* Saw an E (or e) in current state */
  ------------------
  |  Branch (2187:7): [True: 1.98k, False: 25.6k]
  ------------------
 2188|  1.98k|         if ((state & PNG_FP_SAW_DIGIT) == 0)
  ------------------
  |  | 1897|  1.98k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2188:14): [True: 613, False: 1.36k]
  ------------------
 2189|    613|            goto PNG_FP_End;
 2190|       |
 2191|  1.36k|         png_fp_set(state, PNG_FP_EXPONENT);
  ------------------
  |  | 2126|  1.36k|#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
  |  |  ------------------
  |  |  |  | 1907|  1.36k|#define PNG_FP_STICKY   448  /* The above three flags */
  |  |  ------------------
  ------------------
 2192|       |
 2193|  1.36k|         break;
 2194|       |
 2195|       |   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
 2196|       |         goto PNG_FP_End; ** no sign in fraction */
 2197|       |
 2198|       |   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
 2199|       |         goto PNG_FP_End; ** Because SAW_DOT is always set */
 2200|       |
 2201|  3.87k|      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1893|  3.87k|#define PNG_FP_FRACTION   1  /* before or in fraction */
  ------------------
                    case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1897|  3.87k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2201:7): [True: 3.87k, False: 23.7k]
  ------------------
 2202|  3.87k|         png_fp_add(state, type | PNG_FP_WAS_VALID);
  ------------------
  |  | 2125|  3.87k|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2203|  3.87k|         break;
 2204|       |
 2205|    760|      case PNG_FP_FRACTION + PNG_FP_SAW_E:
  ------------------
  |  | 1893|    760|#define PNG_FP_FRACTION   1  /* before or in fraction */
  ------------------
                    case PNG_FP_FRACTION + PNG_FP_SAW_E:
  ------------------
  |  | 1899|    760|#define PNG_FP_SAW_E     32  /* Saw an E (or e) in current state */
  ------------------
  |  Branch (2205:7): [True: 760, False: 26.9k]
  ------------------
 2206|       |         /* This is correct because the trailing '.' on an
 2207|       |          * integer is handled above - so we can only get here
 2208|       |          * with the sequence ".E" (with no preceding digits).
 2209|       |          */
 2210|    760|         if ((state & PNG_FP_SAW_DIGIT) == 0)
  ------------------
  |  | 1897|    760|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2210:14): [True: 1, False: 759]
  ------------------
 2211|      1|            goto PNG_FP_End;
 2212|       |
 2213|    759|         png_fp_set(state, PNG_FP_EXPONENT);
  ------------------
  |  | 2126|    759|#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
  |  |  ------------------
  |  |  |  | 1907|    759|#define PNG_FP_STICKY   448  /* The above three flags */
  |  |  ------------------
  ------------------
 2214|       |
 2215|    759|         break;
 2216|       |
 2217|    954|      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
  ------------------
  |  | 1894|    954|#define PNG_FP_EXPONENT   2  /* before or in exponent */
  ------------------
                    case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
  ------------------
  |  | 1896|    954|#define PNG_FP_SAW_SIGN   4  /* Saw +/- in current state */
  ------------------
  |  Branch (2217:7): [True: 954, False: 26.7k]
  ------------------
 2218|    954|         if ((state & PNG_FP_SAW_ANY) != 0)
  ------------------
  |  | 1900|    954|#define PNG_FP_SAW_ANY   60  /* Saw any of the above 4 */
  ------------------
  |  Branch (2218:14): [True: 120, False: 834]
  ------------------
 2219|    120|            goto PNG_FP_End; /* not a part of the number */
 2220|       |
 2221|    834|         png_fp_add(state, PNG_FP_SAW_SIGN);
  ------------------
  |  | 2125|    834|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2222|       |
 2223|    834|         break;
 2224|       |
 2225|       |   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
 2226|       |         goto PNG_FP_End; */
 2227|       |
 2228|  2.89k|      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1894|  2.89k|#define PNG_FP_EXPONENT   2  /* before or in exponent */
  ------------------
                    case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
  ------------------
  |  | 1897|  2.89k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
  |  Branch (2228:7): [True: 2.89k, False: 24.7k]
  ------------------
 2229|  2.89k|         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);
  ------------------
  |  | 2125|  2.89k|#define png_fp_add(state, flags) ((state) |= (flags))
  ------------------
 2230|       |
 2231|  2.89k|         break;
 2232|       |
 2233|       |   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
 2234|       |         goto PNG_FP_End; */
 2235|       |
 2236|    887|      default: goto PNG_FP_End; /* I.e. break 2 */
  ------------------
  |  Branch (2236:7): [True: 887, False: 26.7k]
  ------------------
 2237|  27.6k|      }
 2238|       |
 2239|       |      /* The character seems ok, continue. */
 2240|  26.0k|      ++i;
 2241|  26.0k|   }
 2242|       |
 2243|  4.67k|PNG_FP_End:
 2244|       |   /* Here at the end, update the state and return the correct
 2245|       |    * return code.
 2246|       |    */
 2247|  4.67k|   *statep = state;
 2248|  4.67k|   *whereami = i;
 2249|       |
 2250|  4.67k|   return (state & PNG_FP_SAW_DIGIT) != 0;
  ------------------
  |  | 1897|  4.67k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  ------------------
 2251|  4.67k|}
OSS_FUZZ_png_check_fp_string:
 2257|    482|{
 2258|    482|   int        state=0;
 2259|    482|   size_t char_index=0;
 2260|       |
 2261|    482|   if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
  ------------------
  |  |   86|    482|#define png_check_fp_number OSS_FUZZ_png_check_fp_number
  ------------------
  |  Branch (2261:8): [True: 383, False: 99]
  ------------------
 2262|    482|      (char_index == size || string[char_index] == 0))
  ------------------
  |  Branch (2262:8): [True: 356, False: 27]
  |  Branch (2262:30): [True: 0, False: 27]
  ------------------
 2263|    356|      return state /* must be non-zero - see above */;
 2264|       |
 2265|    126|   return 0; /* i.e. fail */
 2266|    482|}
OSS_FUZZ_png_muldiv:
 2767|    537|{
 2768|       |   /* Return a * times / divisor, rounded. */
 2769|    537|   if (divisor != 0)
  ------------------
  |  Branch (2769:8): [True: 537, False: 0]
  ------------------
 2770|    537|   {
 2771|    537|      if (a == 0 || times == 0)
  ------------------
  |  Branch (2771:11): [True: 0, False: 537]
  |  Branch (2771:21): [True: 0, False: 537]
  ------------------
 2772|      0|      {
 2773|      0|         *res = 0;
 2774|      0|         return 1;
 2775|      0|      }
 2776|    537|      else
 2777|    537|      {
 2778|    537|#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
 2779|    537|         double r = a;
 2780|    537|         r *= times;
 2781|    537|         r /= divisor;
 2782|    537|         r = floor(r+.5);
 2783|       |
 2784|       |         /* A png_fixed_point is a 32-bit integer. */
 2785|    537|         if (r <= 2147483647. && r >= -2147483648.)
  ------------------
  |  Branch (2785:14): [True: 537, False: 0]
  |  Branch (2785:34): [True: 537, False: 0]
  ------------------
 2786|    537|         {
 2787|    537|            *res = (png_fixed_point)r;
 2788|    537|            return 1;
 2789|    537|         }
 2790|       |#else
 2791|       |         int negative = 0;
 2792|       |         png_uint_32 A, T, D;
 2793|       |         png_uint_32 s16, s32, s00;
 2794|       |
 2795|       |         if (a < 0)
 2796|       |            negative = 1, A = -a;
 2797|       |         else
 2798|       |            A = a;
 2799|       |
 2800|       |         if (times < 0)
 2801|       |            negative = !negative, T = -times;
 2802|       |         else
 2803|       |            T = times;
 2804|       |
 2805|       |         if (divisor < 0)
 2806|       |            negative = !negative, D = -divisor;
 2807|       |         else
 2808|       |            D = divisor;
 2809|       |
 2810|       |         /* Following can't overflow because the arguments only
 2811|       |          * have 31 bits each, however the result may be 32 bits.
 2812|       |          */
 2813|       |         s16 = (A >> 16) * (T & 0xffff) +
 2814|       |                           (A & 0xffff) * (T >> 16);
 2815|       |         /* Can't overflow because the a*times bit is only 30
 2816|       |          * bits at most.
 2817|       |          */
 2818|       |         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);
 2819|       |         s00 = (A & 0xffff) * (T & 0xffff);
 2820|       |
 2821|       |         s16 = (s16 & 0xffff) << 16;
 2822|       |         s00 += s16;
 2823|       |
 2824|       |         if (s00 < s16)
 2825|       |            ++s32; /* carry */
 2826|       |
 2827|       |         if (s32 < D) /* else overflow */
 2828|       |         {
 2829|       |            /* s32.s00 is now the 64-bit product, do a standard
 2830|       |             * division, we know that s32 < D, so the maximum
 2831|       |             * required shift is 31.
 2832|       |             */
 2833|       |            int bitshift = 32;
 2834|       |            png_fixed_point result = 0; /* NOTE: signed */
 2835|       |
 2836|       |            while (--bitshift >= 0)
 2837|       |            {
 2838|       |               png_uint_32 d32, d00;
 2839|       |
 2840|       |               if (bitshift > 0)
 2841|       |                  d32 = D >> (32-bitshift), d00 = D << bitshift;
 2842|       |
 2843|       |               else
 2844|       |                  d32 = 0, d00 = D;
 2845|       |
 2846|       |               if (s32 > d32)
 2847|       |               {
 2848|       |                  if (s00 < d00) --s32; /* carry */
 2849|       |                  s32 -= d32, s00 -= d00, result += 1<<bitshift;
 2850|       |               }
 2851|       |
 2852|       |               else
 2853|       |                  if (s32 == d32 && s00 >= d00)
 2854|       |                     s32 = 0, s00 -= d00, result += 1<<bitshift;
 2855|       |            }
 2856|       |
 2857|       |            /* Handle the rounding. */
 2858|       |            if (s00 >= (D >> 1))
 2859|       |               ++result;
 2860|       |
 2861|       |            if (negative != 0)
 2862|       |               result = -result;
 2863|       |
 2864|       |            /* Check for overflow. */
 2865|       |            if ((negative != 0 && result <= 0) ||
 2866|       |                (negative == 0 && result >= 0))
 2867|       |            {
 2868|       |               *res = result;
 2869|       |               return 1;
 2870|       |            }
 2871|       |         }
 2872|       |#endif
 2873|    537|      }
 2874|    537|   }
 2875|       |
 2876|      0|   return 0;
 2877|    537|}
OSS_FUZZ_png_reciprocal:
 2882|  1.35k|{
 2883|  1.35k|#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
 2884|  1.35k|   double r = floor(1E10/a+.5);
 2885|       |
 2886|  1.35k|   if (r <= 2147483647. && r >= -2147483648.)
  ------------------
  |  Branch (2886:8): [True: 1.35k, False: 1]
  |  Branch (2886:28): [True: 1.35k, False: 0]
  ------------------
 2887|  1.35k|      return (png_fixed_point)r;
 2888|       |#else
 2889|       |   png_fixed_point res;
 2890|       |
 2891|       |   if (png_muldiv(&res, 100000, 100000, a) != 0)
 2892|       |      return res;
 2893|       |#endif
 2894|       |
 2895|      1|   return 0; /* error/overflow */
 2896|  1.35k|}
OSS_FUZZ_png_gamma_significant:
 2905|  2.30k|{
 2906|       |   /* sRGB:       1/2.2 == 0.4545(45)
 2907|       |    * AdobeRGB:   1/(2+51/256) ~= 0.45471 5dp
 2908|       |    *
 2909|       |    * So the correction from AdobeRGB to sRGB (output) is:
 2910|       |    *
 2911|       |    *    2.2/(2+51/256) == 1.00035524
 2912|       |    *
 2913|       |    * I.e. vanishly small (<4E-4) but still detectable in 16-bit linear (+/-
 2914|       |    * 23).  Note that the Adobe choice seems to be something intended to give an
 2915|       |    * exact number with 8 binary fractional digits - it is the closest to 2.2
 2916|       |    * that is possible a base 2 .8p representation.
 2917|       |    */
 2918|  2.30k|   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
  ------------------
  |  |  654|  2.30k|#define PNG_FP_1    100000
  ------------------
                 return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
  ------------------
  |  |  208|  4.60k|#define PNG_GAMMA_THRESHOLD_FIXED 5000
  ------------------
  |  Branch (2918:11): [True: 123, False: 2.17k]
  ------------------
 2919|  2.30k|       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
  ------------------
  |  |  654|  2.17k|#define PNG_FP_1    100000
  ------------------
                     gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
  ------------------
  |  |  208|  2.17k|#define PNG_GAMMA_THRESHOLD_FIXED 5000
  ------------------
  |  Branch (2919:8): [True: 894, False: 1.28k]
  ------------------
 2920|  2.30k|}
OSS_FUZZ_png_reciprocal2:
 2948|    162|{
 2949|       |   /* The required result is 1/a * 1/b; the following preserves accuracy. */
 2950|    162|#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
 2951|    162|   if (a != 0 && b != 0)
  ------------------
  |  Branch (2951:8): [True: 162, False: 0]
  |  Branch (2951:18): [True: 162, False: 0]
  ------------------
 2952|    162|   {
 2953|    162|      double r = 1E15/a;
 2954|    162|      r /= b;
 2955|    162|      r = floor(r+.5);
 2956|       |
 2957|    162|      if (r <= 2147483647. && r >= -2147483648.)
  ------------------
  |  Branch (2957:11): [True: 162, False: 0]
  |  Branch (2957:31): [True: 162, False: 0]
  ------------------
 2958|    162|         return (png_fixed_point)r;
 2959|    162|   }
 2960|       |#else
 2961|       |   /* This may overflow because the range of png_fixed_point isn't symmetric,
 2962|       |    * but this API is only used for the product of file and screen gamma so it
 2963|       |    * doesn't matter that the smallest number it can produce is 1/21474, not
 2964|       |    * 1/100000
 2965|       |    */
 2966|       |   png_fixed_point res = png_product2(a, b);
 2967|       |
 2968|       |   if (res != 0)
 2969|       |      return png_reciprocal(res);
 2970|       |#endif
 2971|       |
 2972|      0|   return 0; /* overflow */
 2973|    162|}
OSS_FUZZ_png_gamma_8bit_correct:
 3269|  29.6k|{
 3270|  29.6k|   if (value > 0 && value < 255)
  ------------------
  |  Branch (3270:8): [True: 29.5k, False: 116]
  |  Branch (3270:21): [True: 29.4k, False: 116]
  ------------------
 3271|  29.4k|   {
 3272|  29.4k|#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
 3273|       |         /* 'value' is unsigned, ANSI-C90 requires the compiler to correctly
 3274|       |          * convert this to a floating point value.  This includes values that
 3275|       |          * would overflow if 'value' were to be converted to 'int'.
 3276|       |          *
 3277|       |          * Apparently GCC, however, does an intermediate conversion to (int)
 3278|       |          * on some (ARM) but not all (x86) platforms, possibly because of
 3279|       |          * hardware FP limitations.  (E.g. if the hardware conversion always
 3280|       |          * assumes the integer register contains a signed value.)  This results
 3281|       |          * in ANSI-C undefined behavior for large values.
 3282|       |          *
 3283|       |          * Other implementations on the same machine might actually be ANSI-C90
 3284|       |          * conformant and therefore compile spurious extra code for the large
 3285|       |          * values.
 3286|       |          *
 3287|       |          * We can be reasonably sure that an unsigned to float conversion
 3288|       |          * won't be faster than an int to float one.  Therefore this code
 3289|       |          * assumes responsibility for the undefined behavior, which it knows
 3290|       |          * can't happen because of the check above.
 3291|       |          *
 3292|       |          * Note the argument to this routine is an (unsigned int) because, on
 3293|       |          * 16-bit platforms, it is assigned a value which might be out of
 3294|       |          * range for an (int); that would result in undefined behavior in the
 3295|       |          * caller if the *argument* ('value') were to be declared (int).
 3296|       |          */
 3297|  29.4k|         double r = floor(255*pow((int)/*SAFE*/value/255.,gamma_val*.00001)+.5);
 3298|  29.4k|         return (png_byte)r;
 3299|       |#     else
 3300|       |         png_int_32 lg2 = png_log8bit(value);
 3301|       |         png_fixed_point res;
 3302|       |
 3303|       |         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
 3304|       |            return png_exp8bit(res);
 3305|       |
 3306|       |         /* Overflow. */
 3307|       |         value = 0;
 3308|       |#     endif
 3309|  29.4k|   }
 3310|       |
 3311|    232|   return (png_byte)(value & 0xff);
 3312|  29.6k|}
OSS_FUZZ_png_gamma_16bit_correct:
 3317|  11.7k|{
 3318|  11.7k|   if (value > 0 && value < 65535)
  ------------------
  |  Branch (3318:8): [True: 11.7k, False: 0]
  |  Branch (3318:21): [True: 11.7k, False: 0]
  ------------------
 3319|  11.7k|   {
 3320|  11.7k|# ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
 3321|       |      /* The same (unsigned int)->(double) constraints apply here as above,
 3322|       |       * however in this case the (unsigned int) to (int) conversion can
 3323|       |       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
 3324|       |       * that this is not possible.
 3325|       |       */
 3326|  11.7k|      double r = floor(65535*pow((png_int_32)value/65535.,
 3327|  11.7k|          gamma_val*.00001)+.5);
 3328|  11.7k|      return (png_uint_16)r;
 3329|       |# else
 3330|       |      png_int_32 lg2 = png_log16bit(value);
 3331|       |      png_fixed_point res;
 3332|       |
 3333|       |      if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
 3334|       |         return png_exp16bit(res);
 3335|       |
 3336|       |      /* Overflow. */
 3337|       |      value = 0;
 3338|       |# endif
 3339|  11.7k|   }
 3340|       |
 3341|      0|   return (png_uint_16)value;
 3342|  11.7k|}
OSS_FUZZ_png_destroy_gamma_table:
 3541|  2.60k|{
 3542|  2.60k|   png_free(png_ptr, png_ptr->gamma_table);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
 3543|  2.60k|   png_ptr->gamma_table = NULL;
 3544|       |
 3545|  2.60k|#ifdef PNG_16BIT_SUPPORTED
 3546|  2.60k|   if (png_ptr->gamma_16_table != NULL)
  ------------------
  |  Branch (3546:8): [True: 46, False: 2.55k]
  ------------------
 3547|     46|   {
 3548|     46|      int i;
 3549|     46|      int istop = (1 << (8 - png_ptr->gamma_shift));
 3550|    414|      for (i = 0; i < istop; i++)
  ------------------
  |  Branch (3550:19): [True: 368, False: 46]
  ------------------
 3551|    368|      {
 3552|    368|         png_free(png_ptr, png_ptr->gamma_16_table[i]);
  ------------------
  |  |  253|    368|#define png_free OSS_FUZZ_png_free
  ------------------
 3553|    368|      }
 3554|     46|   png_free(png_ptr, png_ptr->gamma_16_table);
  ------------------
  |  |  253|     46|#define png_free OSS_FUZZ_png_free
  ------------------
 3555|     46|   png_ptr->gamma_16_table = NULL;
 3556|     46|   }
 3557|  2.60k|#endif /* 16BIT */
 3558|       |
 3559|  2.60k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
 3560|  2.60k|   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
 3561|  2.60k|   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
 3562|  2.60k|   png_free(png_ptr, png_ptr->gamma_from_1);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
 3563|  2.60k|   png_ptr->gamma_from_1 = NULL;
 3564|  2.60k|   png_free(png_ptr, png_ptr->gamma_to_1);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
 3565|  2.60k|   png_ptr->gamma_to_1 = NULL;
 3566|       |
 3567|  2.60k|#ifdef PNG_16BIT_SUPPORTED
 3568|  2.60k|   if (png_ptr->gamma_16_from_1 != NULL)
  ------------------
  |  Branch (3568:8): [True: 0, False: 2.60k]
  ------------------
 3569|      0|   {
 3570|      0|      int i;
 3571|      0|      int istop = (1 << (8 - png_ptr->gamma_shift));
 3572|      0|      for (i = 0; i < istop; i++)
  ------------------
  |  Branch (3572:19): [True: 0, False: 0]
  ------------------
 3573|      0|      {
 3574|      0|         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3575|      0|      }
 3576|      0|   png_free(png_ptr, png_ptr->gamma_16_from_1);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3577|      0|   png_ptr->gamma_16_from_1 = NULL;
 3578|      0|   }
 3579|  2.60k|   if (png_ptr->gamma_16_to_1 != NULL)
  ------------------
  |  Branch (3579:8): [True: 0, False: 2.60k]
  ------------------
 3580|      0|   {
 3581|      0|      int i;
 3582|      0|      int istop = (1 << (8 - png_ptr->gamma_shift));
 3583|      0|      for (i = 0; i < istop; i++)
  ------------------
  |  Branch (3583:19): [True: 0, False: 0]
  ------------------
 3584|      0|      {
 3585|      0|         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3586|      0|      }
 3587|      0|   png_free(png_ptr, png_ptr->gamma_16_to_1);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3588|      0|   png_ptr->gamma_16_to_1 = NULL;
 3589|      0|   }
 3590|  2.60k|#endif /* 16BIT */
 3591|  2.60k|#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
 3592|  2.60k|}
OSS_FUZZ_png_build_gamma_table:
 3612|    162|{
 3613|    162|   png_fixed_point file_gamma, screen_gamma;
 3614|    162|   png_fixed_point correction;
 3615|    162|#  if GAMMA_TRANSFORMS
 3616|    162|      png_fixed_point file_to_linear, linear_to_screen;
 3617|    162|#  endif
 3618|       |
 3619|    162|   png_debug(1, "in png_build_gamma_table");
  ------------------
  |  |  148|    162|#  define png_debug(l, m) ((void)0)
  ------------------
 3620|       |
 3621|       |   /* Remove any existing table; this copes with multiple calls to
 3622|       |    * png_read_update_info. The warning is because building the gamma tables
 3623|       |    * multiple times is a performance hit - it's harmless but the ability to
 3624|       |    * call png_read_update_info() multiple times is new in 1.5.6 so it seems
 3625|       |    * sensible to warn if the app introduces such a hit.
 3626|       |    */
 3627|    162|   if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)
  ------------------
  |  Branch (3627:8): [True: 0, False: 162]
  |  Branch (3627:40): [True: 0, False: 162]
  ------------------
 3628|      0|   {
 3629|      0|      png_warning(png_ptr, "gamma table being rebuilt");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 3630|      0|      png_destroy_gamma_table(png_ptr);
  ------------------
  |  |   96|      0|#define png_destroy_gamma_table OSS_FUZZ_png_destroy_gamma_table
  ------------------
 3631|      0|   }
 3632|       |
 3633|       |   /* The following fields are set, finally, in png_init_read_transformations.
 3634|       |    * If file_gamma is 0 (unset) nothing can be done otherwise if screen_gamma
 3635|       |    * is 0 (unset) there is no gamma correction but to/from linear is possible.
 3636|       |    */
 3637|    162|   file_gamma = png_ptr->file_gamma;
 3638|    162|   screen_gamma = png_ptr->screen_gamma;
 3639|    162|#  if GAMMA_TRANSFORMS
 3640|    162|      file_to_linear = png_reciprocal(file_gamma);
  ------------------
  |  |   89|    162|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 3641|    162|#  endif
 3642|       |
 3643|    162|   if (screen_gamma > 0)
  ------------------
  |  Branch (3643:8): [True: 162, False: 0]
  ------------------
 3644|    162|   {
 3645|    162|#     if GAMMA_TRANSFORMS
 3646|    162|         linear_to_screen = png_reciprocal(screen_gamma);
  ------------------
  |  |   89|    162|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 3647|    162|#     endif
 3648|    162|      correction = png_reciprocal2(screen_gamma, file_gamma);
  ------------------
  |  |   90|    162|#define png_reciprocal2 OSS_FUZZ_png_reciprocal2
  ------------------
 3649|    162|   }
 3650|      0|   else /* screen gamma unknown */
 3651|      0|   {
 3652|      0|#     if GAMMA_TRANSFORMS
 3653|      0|         linear_to_screen = file_gamma;
 3654|      0|#     endif
 3655|      0|      correction = PNG_FP_1;
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 3656|      0|   }
 3657|       |
 3658|    162|   if (bit_depth <= 8)
  ------------------
  |  Branch (3658:8): [True: 116, False: 46]
  ------------------
 3659|    116|   {
 3660|    116|      png_build_8bit_table(png_ptr, &png_ptr->gamma_table, correction);
 3661|       |
 3662|    116|#if GAMMA_TRANSFORMS
 3663|    116|      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
  ------------------
  |  |  641|    116|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
                    if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
  ------------------
  |  |  657|    116|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (3663:11): [True: 0, False: 116]
  ------------------
 3664|      0|      {
 3665|      0|         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1, file_to_linear);
 3666|       |
 3667|      0|         png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,
 3668|      0|            linear_to_screen);
 3669|      0|      }
 3670|    116|#endif /* GAMMA_TRANSFORMS */
 3671|    116|   }
 3672|     46|#ifdef PNG_16BIT_SUPPORTED
 3673|     46|   else
 3674|     46|   {
 3675|     46|      png_byte shift, sig_bit;
 3676|       |
 3677|     46|      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|     46|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (3677:11): [True: 22, False: 24]
  ------------------
 3678|     22|      {
 3679|     22|         sig_bit = png_ptr->sig_bit.red;
 3680|       |
 3681|     22|         if (png_ptr->sig_bit.green > sig_bit)
  ------------------
  |  Branch (3681:14): [True: 0, False: 22]
  ------------------
 3682|      0|            sig_bit = png_ptr->sig_bit.green;
 3683|       |
 3684|     22|         if (png_ptr->sig_bit.blue > sig_bit)
  ------------------
  |  Branch (3684:14): [True: 0, False: 22]
  ------------------
 3685|      0|            sig_bit = png_ptr->sig_bit.blue;
 3686|     22|      }
 3687|     24|      else
 3688|     24|         sig_bit = png_ptr->sig_bit.gray;
 3689|       |
 3690|       |      /* 16-bit gamma code uses this equation:
 3691|       |       *
 3692|       |       *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
 3693|       |       *
 3694|       |       * Where 'iv' is the input color value and 'ov' is the output value -
 3695|       |       * pow(iv, gamma).
 3696|       |       *
 3697|       |       * Thus the gamma table consists of up to 256 256-entry tables.  The table
 3698|       |       * is selected by the (8-gamma_shift) most significant of the low 8 bits
 3699|       |       * of the color value then indexed by the upper 8 bits:
 3700|       |       *
 3701|       |       *   table[low bits][high 8 bits]
 3702|       |       *
 3703|       |       * So the table 'n' corresponds to all those 'iv' of:
 3704|       |       *
 3705|       |       *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
 3706|       |       *
 3707|       |       */
 3708|     46|      if (sig_bit > 0 && sig_bit < 16U)
  ------------------
  |  Branch (3708:11): [True: 0, False: 46]
  |  Branch (3708:26): [True: 0, False: 0]
  ------------------
 3709|       |         /* shift == insignificant bits */
 3710|      0|         shift = (png_byte)((16U - sig_bit) & 0xff);
 3711|       |
 3712|     46|      else
 3713|     46|         shift = 0; /* keep all 16 bits */
 3714|       |
 3715|     46|      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
  ------------------
  |  |  644|     46|#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
  ------------------
                    if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
  ------------------
  |  |  661|     46|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (3715:11): [True: 46, False: 0]
  ------------------
 3716|     46|      {
 3717|       |         /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
 3718|       |          * the significant bits in the *input* when the output will
 3719|       |          * eventually be 8 bits.  By default it is 11.
 3720|       |          */
 3721|     46|         if (shift < (16U - PNG_MAX_GAMMA_8))
  ------------------
  |  |  215|     46|#define PNG_MAX_GAMMA_8 11
  ------------------
  |  Branch (3721:14): [True: 46, False: 0]
  ------------------
 3722|     46|            shift = (16U - PNG_MAX_GAMMA_8);
  ------------------
  |  |  215|     46|#define PNG_MAX_GAMMA_8 11
  ------------------
 3723|     46|      }
 3724|       |
 3725|     46|      if (shift > 8U)
  ------------------
  |  Branch (3725:11): [True: 0, False: 46]
  ------------------
 3726|      0|         shift = 8U; /* Guarantees at least one table! */
 3727|       |
 3728|     46|      png_ptr->gamma_shift = shift;
 3729|       |
 3730|       |      /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
 3731|       |       * PNG_COMPOSE).  This effectively smashed the background calculation for
 3732|       |       * 16-bit output because the 8-bit table assumes the result will be
 3733|       |       * reduced to 8 bits.
 3734|       |       */
 3735|     46|      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
  ------------------
  |  |  644|     46|#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
  ------------------
                    if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
  ------------------
  |  |  661|     46|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (3735:11): [True: 46, False: 0]
  ------------------
 3736|     46|         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,
 3737|     46|            png_reciprocal(correction));
  ------------------
  |  |   89|     46|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 3738|      0|      else
 3739|      0|         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,
 3740|      0|            correction);
 3741|       |
 3742|     46|#  if GAMMA_TRANSFORMS
 3743|     46|      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
  ------------------
  |  |  641|     46|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
                    if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
  ------------------
  |  |  657|     46|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (3743:11): [True: 0, False: 46]
  ------------------
 3744|      0|      {
 3745|      0|         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,
 3746|      0|            file_to_linear);
 3747|       |
 3748|       |         /* Notice that the '16 from 1' table should be full precision, however
 3749|       |          * the lookup on this table still uses gamma_shift, so it can't be.
 3750|       |          * TODO: fix this.
 3751|       |          */
 3752|      0|         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,
 3753|      0|            linear_to_screen);
 3754|      0|      }
 3755|     46|#endif /* GAMMA_TRANSFORMS */
 3756|     46|   }
 3757|    162|#endif /* 16BIT */
 3758|    162|}
OSS_FUZZ_png_image_free:
 4015|    687|{
 4016|       |   /* Safely call the real function, but only if doing so is safe at this point
 4017|       |    * (if not inside an error handling context).  Otherwise assume
 4018|       |    * png_safe_execute will call this API after the return.
 4019|       |    */
 4020|    687|   if (image != NULL && image->opaque != NULL &&
  ------------------
  |  Branch (4020:8): [True: 687, False: 0]
  |  Branch (4020:25): [True: 548, False: 139]
  ------------------
 4021|    687|      image->opaque->error_buf == NULL)
  ------------------
  |  Branch (4021:7): [True: 548, False: 0]
  ------------------
 4022|    548|   {
 4023|    548|      png_image_free_function(image);
 4024|    548|      image->opaque = NULL;
 4025|    548|   }
 4026|    687|}
png.c:icc_check_length:
 1582|    525|{
 1583|    525|   if (profile_length < 132)
  ------------------
  |  Branch (1583:8): [True: 18, False: 507]
  ------------------
 1584|     18|      return png_icc_profile_error(png_ptr, name, profile_length, "too short");
 1585|    507|   return 1;
 1586|    525|}
png.c:png_icc_profile_error:
 1536|    538|{
 1537|    538|   size_t pos;
 1538|    538|   char message[196]; /* see below for calculation */
 1539|       |
 1540|    538|   pos = png_safecat(message, (sizeof message), 0, "profile '"); /* 9 chars */
  ------------------
  |  |   75|    538|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1541|    538|   pos = png_safecat(message, pos+79, pos, name); /* Truncate to 79 chars */
  ------------------
  |  |   75|    538|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1542|    538|   pos = png_safecat(message, (sizeof message), pos, "': "); /* +2 = 90 */
  ------------------
  |  |   75|    538|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1543|    538|   if (is_ICC_signature(value) != 0)
  ------------------
  |  Branch (1543:8): [True: 82, False: 456]
  ------------------
 1544|     82|   {
 1545|       |      /* So 'value' is at most 4 bytes and the following cast is safe */
 1546|     82|      png_icc_tag_name(message+pos, (png_uint_32)value);
 1547|     82|      pos += 6; /* total +8; less than the else clause */
 1548|     82|      message[pos++] = ':';
 1549|     82|      message[pos++] = ' ';
 1550|     82|   }
 1551|    456|#  ifdef PNG_WARNINGS_SUPPORTED
 1552|    456|   else
 1553|    456|   {
 1554|    456|      char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114 */
 1555|       |
 1556|    456|      pos = png_safecat(message, (sizeof message), pos,
  ------------------
  |  |   75|    456|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1557|    456|          png_format_number(number, number+(sizeof number),
  ------------------
  |  |   76|    456|#define png_format_number OSS_FUZZ_png_format_number
  ------------------
 1558|    456|          PNG_NUMBER_FORMAT_x, value));
  ------------------
  |  | 1753|    456|#define PNG_NUMBER_FORMAT_x     3
  ------------------
 1559|    456|      pos = png_safecat(message, (sizeof message), pos, "h: "); /* +2 = 116 */
  ------------------
  |  |   75|    456|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1560|    456|   }
 1561|    538|#  endif
 1562|       |   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */
 1563|    538|   pos = png_safecat(message, (sizeof message), pos, reason);
  ------------------
  |  |   75|    538|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
 1564|    538|   PNG_UNUSED(pos)
  ------------------
  |  |  455|    538|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1565|       |
 1566|    538|   png_chunk_benign_error(png_ptr, message);
  ------------------
  |  |  238|    538|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1567|       |
 1568|    538|   return 0;
 1569|    538|}
png.c:is_ICC_signature:
 1526|    538|{
 1527|    538|   return is_ICC_signature_char(it >> 24) /* checks all the top bits */ &&
  ------------------
  |  Branch (1527:11): [True: 431, False: 107]
  ------------------
 1528|    538|      is_ICC_signature_char((it >> 16) & 0xff) &&
  ------------------
  |  Branch (1528:7): [True: 277, False: 154]
  ------------------
 1529|    538|      is_ICC_signature_char((it >> 8) & 0xff) &&
  ------------------
  |  Branch (1529:7): [True: 254, False: 23]
  ------------------
 1530|    538|      is_ICC_signature_char(it & 0xff);
  ------------------
  |  Branch (1530:7): [True: 82, False: 172]
  ------------------
 1531|    538|}
png.c:is_ICC_signature_char:
 1519|  1.50k|{
 1520|  1.50k|   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||
  ------------------
  |  Branch (1520:11): [True: 117, False: 1.38k]
  |  Branch (1520:24): [True: 1.10k, False: 281]
  |  Branch (1520:36): [True: 80, False: 1.02k]
  |  Branch (1520:50): [True: 856, False: 447]
  |  Branch (1520:62): [True: 282, False: 574]
  ------------------
 1521|  1.50k|      (it >= 97 && it <= 122);
  ------------------
  |  Branch (1521:8): [True: 574, False: 447]
  |  Branch (1521:20): [True: 565, False: 9]
  ------------------
 1522|  1.50k|}
png.c:png_icc_tag_name:
 1508|     82|{
 1509|     82|   name[0] = '\'';
 1510|     82|   name[1] = png_icc_tag_char(tag >> 24);
 1511|     82|   name[2] = png_icc_tag_char(tag >> 16);
 1512|     82|   name[3] = png_icc_tag_char(tag >>  8);
 1513|     82|   name[4] = png_icc_tag_char(tag      );
 1514|     82|   name[5] = '\'';
 1515|     82|}
png.c:png_icc_tag_char:
 1498|    328|{
 1499|    328|   byte &= 0xff;
 1500|    328|   if (byte >= 32 && byte <= 126)
  ------------------
  |  Branch (1500:8): [True: 328, False: 0]
  |  Branch (1500:22): [True: 328, False: 0]
  ------------------
 1501|    328|      return (char)byte;
 1502|      0|   else
 1503|      0|      return '?';
 1504|    328|}
png.c:png_build_8bit_table:
 3523|    116|{
 3524|    116|   unsigned int i;
 3525|    116|   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
  ------------------
  |  |  347|    116|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
 3526|       |
 3527|    116|   if (png_gamma_significant(gamma_val) != 0)
  ------------------
  |  |   91|    116|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (3527:8): [True: 116, False: 0]
  ------------------
 3528|  29.8k|      for (i=0; i<256; i++)
  ------------------
  |  Branch (3528:17): [True: 29.6k, False: 116]
  ------------------
 3529|  29.6k|         table[i] = png_gamma_8bit_correct(i, gamma_val);
  ------------------
  |  |   95|  29.6k|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 3530|       |
 3531|      0|   else
 3532|      0|      for (i=0; i<256; ++i)
  ------------------
  |  Branch (3532:17): [True: 0, False: 0]
  ------------------
 3533|      0|         table[i] = (png_byte)(i & 0xff);
 3534|    116|}
png.c:png_build_16to8_table:
 3455|     46|{
 3456|     46|   unsigned int num = 1U << (8U - shift);
 3457|     46|   unsigned int max = (1U << (16U - shift))-1U;
 3458|     46|   unsigned int i;
 3459|     46|   png_uint_32 last;
 3460|       |
 3461|     46|   png_uint_16pp table = *ptable =
 3462|     46|       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));
  ------------------
  |  |  237|     46|#define png_calloc OSS_FUZZ_png_calloc
  ------------------
 3463|       |
 3464|       |   /* 'num' is the number of tables and also the number of low bits of low
 3465|       |    * bits of the input 16-bit value used to select a table.  Each table is
 3466|       |    * itself indexed by the high 8 bits of the value.
 3467|       |    */
 3468|    414|   for (i = 0; i < num; i++)
  ------------------
  |  Branch (3468:16): [True: 368, False: 46]
  ------------------
 3469|    368|      table[i] = (png_uint_16p)png_malloc(png_ptr,
  ------------------
  |  |  347|    368|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
 3470|    368|          256 * (sizeof (png_uint_16)));
 3471|       |
 3472|       |   /* 'gamma_val' is set to the reciprocal of the value calculated above, so
 3473|       |    * pow(out,g) is an *input* value.  'last' is the last input value set.
 3474|       |    *
 3475|       |    * In the loop 'i' is used to find output values.  Since the output is
 3476|       |    * 8-bit there are only 256 possible values.  The tables are set up to
 3477|       |    * select the closest possible output value for each input by finding
 3478|       |    * the input value at the boundary between each pair of output values
 3479|       |    * and filling the table up to that boundary with the lower output
 3480|       |    * value.
 3481|       |    *
 3482|       |    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit
 3483|       |    * values the code below uses a 16-bit value in i; the values start at
 3484|       |    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last
 3485|       |    * entries are filled with 255).  Start i at 128 and fill all 'last'
 3486|       |    * table entries <= 'max'
 3487|       |    */
 3488|     46|   last = 0;
 3489|  11.7k|   for (i = 0; i < 255; ++i) /* 8-bit output value */
  ------------------
  |  Branch (3489:16): [True: 11.7k, False: 46]
  ------------------
 3490|  11.7k|   {
 3491|       |      /* Find the corresponding maximum input value */
 3492|  11.7k|      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */
 3493|       |
 3494|       |      /* Find the boundary value in 16 bits: */
 3495|  11.7k|      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);
  ------------------
  |  |   94|  11.7k|#define png_gamma_16bit_correct OSS_FUZZ_png_gamma_16bit_correct
  ------------------
 3496|       |
 3497|       |      /* Adjust (round) to (16-shift) bits: */
 3498|  11.7k|      bound = (bound * max + 32768U)/65535U + 1U;
 3499|       |
 3500|   105k|      while (last < bound)
  ------------------
  |  Branch (3500:14): [True: 93.8k, False: 11.7k]
  ------------------
 3501|  93.8k|      {
 3502|  93.8k|         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;
 3503|  93.8k|         last++;
 3504|  93.8k|      }
 3505|  11.7k|   }
 3506|       |
 3507|       |   /* And fill in the final entries. */
 3508|    436|   while (last < (num << 8))
  ------------------
  |  Branch (3508:11): [True: 390, False: 46]
  ------------------
 3509|    390|   {
 3510|    390|      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;
 3511|    390|      last++;
 3512|    390|   }
 3513|     46|}
png.c:png_image_free_function:
 3955|    548|{
 3956|    548|   png_imagep image = png_voidcast(png_imagep, argument);
  ------------------
  |  |  511|    548|#  define png_voidcast(type, value) (value)
  ------------------
 3957|    548|   png_controlp cp = image->opaque;
 3958|    548|   png_control c;
 3959|       |
 3960|       |   /* Double check that we have a png_ptr - it should be impossible to get here
 3961|       |    * without one.
 3962|       |    */
 3963|    548|   if (cp->png_ptr == NULL)
  ------------------
  |  Branch (3963:8): [True: 0, False: 548]
  ------------------
 3964|      0|      return 0;
 3965|       |
 3966|       |   /* First free any data held in the control structure. */
 3967|       |#  ifdef PNG_STDIO_SUPPORTED
 3968|       |      if (cp->owned_file != 0)
 3969|       |      {
 3970|       |         FILE *fp = png_voidcast(FILE *, cp->png_ptr->io_ptr);
 3971|       |         cp->owned_file = 0;
 3972|       |
 3973|       |         /* Ignore errors here. */
 3974|       |         if (fp != NULL)
 3975|       |         {
 3976|       |            cp->png_ptr->io_ptr = NULL;
 3977|       |            (void)fclose(fp);
 3978|       |         }
 3979|       |      }
 3980|       |#  endif
 3981|       |
 3982|       |   /* Copy the control structure so that the original, allocated, version can be
 3983|       |    * safely freed.  Notice that a png_error here stops the remainder of the
 3984|       |    * cleanup, but this is probably fine because that would indicate bad memory
 3985|       |    * problems anyway.
 3986|       |    */
 3987|    548|   c = *cp;
 3988|    548|   image->opaque = &c;
 3989|    548|   png_free(c.png_ptr, cp);
  ------------------
  |  |  253|    548|#define png_free OSS_FUZZ_png_free
  ------------------
 3990|       |
 3991|       |   /* Then the structures, calling the correct API. */
 3992|    548|   if (c.for_write != 0)
  ------------------
  |  Branch (3992:8): [True: 0, False: 548]
  ------------------
 3993|      0|   {
 3994|       |#     ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
 3995|       |         png_destroy_write_struct(&c.png_ptr, &c.info_ptr);
 3996|       |#     else
 3997|      0|         png_error(c.png_ptr, "simplified write not supported");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3998|      0|#     endif
 3999|      0|   }
 4000|    548|   else
 4001|    548|   {
 4002|    548|#     ifdef PNG_SIMPLIFIED_READ_SUPPORTED
 4003|    548|         png_destroy_read_struct(&c.png_ptr, &c.info_ptr, NULL);
  ------------------
  |  |  250|    548|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  ------------------
 4004|       |#     else
 4005|       |         png_error(c.png_ptr, "simplified read not supported");
 4006|       |#     endif
 4007|    548|   }
 4008|       |
 4009|       |   /* Success. */
 4010|    548|   return 1;
 4011|    548|}

OSS_FUZZ_png_error:
   41|  1.65k|{
   42|       |#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   43|       |   char msg[16];
   44|       |   if (png_ptr != NULL)
   45|       |   {
   46|       |      if ((png_ptr->flags &
   47|       |         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)
   48|       |      {
   49|       |         if (*error_message == PNG_LITERAL_SHARP)
   50|       |         {
   51|       |            /* Strip "#nnnn " from beginning of error message. */
   52|       |            int offset;
   53|       |            for (offset = 1; offset<15; offset++)
   54|       |               if (error_message[offset] == ' ')
   55|       |                  break;
   56|       |
   57|       |            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)
   58|       |            {
   59|       |               int i;
   60|       |               for (i = 0; i < offset - 1; i++)
   61|       |                  msg[i] = error_message[i + 1];
   62|       |               msg[i - 1] = '\0';
   63|       |               error_message = msg;
   64|       |            }
   65|       |
   66|       |            else
   67|       |               error_message += offset;
   68|       |         }
   69|       |
   70|       |         else
   71|       |         {
   72|       |            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)
   73|       |            {
   74|       |               msg[0] = '0';
   75|       |               msg[1] = '\0';
   76|       |               error_message = msg;
   77|       |            }
   78|       |         }
   79|       |      }
   80|       |   }
   81|       |#endif
   82|  1.65k|   if (png_ptr != NULL && png_ptr->error_fn != NULL)
  ------------------
  |  Branch (82:8): [True: 1.65k, False: 0]
  |  Branch (82:27): [True: 150, False: 1.50k]
  ------------------
   83|    150|      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),
  ------------------
  |  |  512|    150|#  define png_constcast(type, value) ((type)(void*)(const void*)(value))
  ------------------
   84|    150|          error_message);
   85|       |
   86|       |   /* If the custom handler doesn't exist, or if it returns,
   87|       |      use the default handler, which will not return. */
   88|  1.65k|   png_default_error(png_ptr, error_message);
   89|  1.65k|}
OSS_FUZZ_png_safecat:
  114|  3.54k|{
  115|  3.54k|   if (buffer != NULL && pos < bufsize)
  ------------------
  |  Branch (115:8): [True: 3.54k, False: 0]
  |  Branch (115:26): [True: 3.54k, False: 0]
  ------------------
  116|  3.54k|   {
  117|  3.54k|      if (string != NULL)
  ------------------
  |  Branch (117:11): [True: 3.54k, False: 0]
  ------------------
  118|  41.7k|         while (*string != '\0' && pos < bufsize-1)
  ------------------
  |  Branch (118:17): [True: 38.1k, False: 3.54k]
  |  Branch (118:36): [True: 38.1k, False: 1]
  ------------------
  119|  38.1k|           buffer[pos++] = *string++;
  120|       |
  121|  3.54k|      buffer[pos] = '\0';
  122|  3.54k|   }
  123|       |
  124|  3.54k|   return pos;
  125|  3.54k|}
OSS_FUZZ_png_format_number:
  135|    456|{
  136|    456|   int count = 0;    /* number of digits output */
  137|    456|   int mincount = 1; /* minimum number required */
  138|    456|   int output = 0;   /* digit output (for the fixed point format) */
  139|       |
  140|    456|   *--end = '\0';
  141|       |
  142|       |   /* This is written so that the loop always runs at least once, even with
  143|       |    * number zero.
  144|       |    */
  145|  3.72k|   while (end > start && (number != 0 || count < mincount))
  ------------------
  |  Branch (145:11): [True: 3.72k, False: 0]
  |  Branch (145:27): [True: 3.22k, False: 498]
  |  Branch (145:42): [True: 42, False: 456]
  ------------------
  146|  3.26k|   {
  147|       |
  148|  3.26k|      static const char digits[] = "0123456789ABCDEF";
  149|       |
  150|  3.26k|      switch (format)
  151|  3.26k|      {
  152|      0|         case PNG_NUMBER_FORMAT_fixed:
  ------------------
  |  | 1755|      0|#define PNG_NUMBER_FORMAT_fixed 5 /* choose the signed API */
  ------------------
  |  Branch (152:10): [True: 0, False: 3.26k]
  ------------------
  153|       |            /* Needs five digits (the fraction) */
  154|      0|            mincount = 5;
  155|      0|            if (output != 0 || number % 10 != 0)
  ------------------
  |  Branch (155:17): [True: 0, False: 0]
  |  Branch (155:32): [True: 0, False: 0]
  ------------------
  156|      0|            {
  157|      0|               *--end = digits[number % 10];
  158|      0|               output = 1;
  159|      0|            }
  160|      0|            number /= 10;
  161|      0|            break;
  162|       |
  163|      0|         case PNG_NUMBER_FORMAT_02u:
  ------------------
  |  | 1750|      0|#define PNG_NUMBER_FORMAT_02u   2
  ------------------
  |  Branch (163:10): [True: 0, False: 3.26k]
  ------------------
  164|       |            /* Expects at least 2 digits. */
  165|      0|            mincount = 2;
  166|       |            /* FALLTHROUGH */
  167|       |
  168|      0|         case PNG_NUMBER_FORMAT_u:
  ------------------
  |  | 1749|      0|#define PNG_NUMBER_FORMAT_u     1 /* chose unsigned API! */
  ------------------
  |  Branch (168:10): [True: 0, False: 3.26k]
  ------------------
  169|      0|            *--end = digits[number % 10];
  170|      0|            number /= 10;
  171|      0|            break;
  172|       |
  173|      0|         case PNG_NUMBER_FORMAT_02x:
  ------------------
  |  | 1754|      0|#define PNG_NUMBER_FORMAT_02x   4
  ------------------
  |  Branch (173:10): [True: 0, False: 3.26k]
  ------------------
  174|       |            /* This format expects at least two digits */
  175|      0|            mincount = 2;
  176|       |            /* FALLTHROUGH */
  177|       |
  178|  3.26k|         case PNG_NUMBER_FORMAT_x:
  ------------------
  |  | 1753|  3.26k|#define PNG_NUMBER_FORMAT_x     3
  ------------------
  |  Branch (178:10): [True: 3.26k, False: 0]
  ------------------
  179|  3.26k|            *--end = digits[number & 0xf];
  180|  3.26k|            number >>= 4;
  181|  3.26k|            break;
  182|       |
  183|      0|         default: /* an error */
  ------------------
  |  Branch (183:10): [True: 0, False: 3.26k]
  ------------------
  184|      0|            number = 0;
  185|      0|            break;
  186|  3.26k|      }
  187|       |
  188|       |      /* Keep track of the number of digits added */
  189|  3.26k|      ++count;
  190|       |
  191|       |      /* Float a fixed number here: */
  192|  3.26k|      if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))
  ------------------
  |  | 1755|  3.26k|#define PNG_NUMBER_FORMAT_fixed 5 /* choose the signed API */
  ------------------
  |  Branch (192:11): [True: 0, False: 3.26k]
  |  Branch (192:50): [True: 0, False: 0]
  |  Branch (192:66): [True: 0, False: 0]
  ------------------
  193|      0|      {
  194|       |         /* End of the fraction, but maybe nothing was output?  In that case
  195|       |          * drop the decimal point.  If the number is a true zero handle that
  196|       |          * here.
  197|       |          */
  198|      0|         if (output != 0)
  ------------------
  |  Branch (198:14): [True: 0, False: 0]
  ------------------
  199|      0|            *--end = '.';
  200|      0|         else if (number == 0) /* and !output */
  ------------------
  |  Branch (200:19): [True: 0, False: 0]
  ------------------
  201|      0|            *--end = '0';
  202|      0|      }
  203|  3.26k|   }
  204|       |
  205|    456|   return end;
  206|    456|}
OSS_FUZZ_png_warning:
  217|  38.4k|{
  218|  38.4k|   int offset = 0;
  219|  38.4k|   if (png_ptr != NULL)
  ------------------
  |  Branch (219:8): [True: 38.4k, False: 0]
  ------------------
  220|  38.4k|   {
  221|       |#ifdef PNG_ERROR_NUMBERS_SUPPORTED
  222|       |   if ((png_ptr->flags &
  223|       |       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)
  224|       |#endif
  225|  38.4k|      {
  226|  38.4k|         if (*warning_message == PNG_LITERAL_SHARP)
  ------------------
  |  |   42|  38.4k|#    define PNG_LITERAL_SHARP 0x23
  ------------------
  |  Branch (226:14): [True: 0, False: 38.4k]
  ------------------
  227|      0|         {
  228|      0|            for (offset = 1; offset < 15; offset++)
  ------------------
  |  Branch (228:30): [True: 0, False: 0]
  ------------------
  229|      0|               if (warning_message[offset] == ' ')
  ------------------
  |  Branch (229:20): [True: 0, False: 0]
  ------------------
  230|      0|                  break;
  231|      0|         }
  232|  38.4k|      }
  233|  38.4k|   }
  234|  38.4k|   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
  ------------------
  |  Branch (234:8): [True: 38.4k, False: 0]
  |  Branch (234:27): [True: 10.4k, False: 27.9k]
  ------------------
  235|  10.4k|      (*(png_ptr->warning_fn))(png_constcast(png_structrp,png_ptr),
  ------------------
  |  |  512|  10.4k|#  define png_constcast(type, value) ((type)(void*)(const void*)(value))
  ------------------
  236|  10.4k|          warning_message + offset);
  237|  27.9k|   else
  238|  27.9k|      png_default_warning(png_ptr, warning_message + offset);
  239|  38.4k|}
OSS_FUZZ_png_benign_error:
  363|    355|{
  364|    355|   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
  ------------------
  |  |  691|    355|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
  |  Branch (364:8): [True: 355, False: 0]
  ------------------
  365|    355|   {
  366|    355|#     ifdef PNG_READ_SUPPORTED
  367|    355|         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
  ------------------
  |  |  631|    355|#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */
  ------------------
  |  Branch (367:14): [True: 355, False: 0]
  ------------------
  368|    355|            png_ptr->chunk_name != 0)
  ------------------
  |  Branch (368:13): [True: 355, False: 0]
  ------------------
  369|    355|            png_chunk_warning(png_ptr, error_message);
  ------------------
  |  |  240|    355|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
  370|      0|         else
  371|      0|#     endif
  372|      0|      png_warning(png_ptr, error_message);
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  373|    355|   }
  374|       |
  375|      0|   else
  376|      0|   {
  377|      0|#     ifdef PNG_READ_SUPPORTED
  378|      0|         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
  ------------------
  |  |  631|      0|#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */
  ------------------
  |  Branch (378:14): [True: 0, False: 0]
  ------------------
  379|      0|            png_ptr->chunk_name != 0)
  ------------------
  |  Branch (379:13): [True: 0, False: 0]
  ------------------
  380|      0|            png_chunk_error(png_ptr, error_message);
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  381|      0|         else
  382|      0|#     endif
  383|      0|      png_error(png_ptr, error_message);
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  384|      0|   }
  385|       |
  386|       |#  ifndef PNG_ERROR_TEXT_SUPPORTED
  387|       |      PNG_UNUSED(error_message)
  388|       |#  endif
  389|    355|}
OSS_FUZZ_png_chunk_error:
  482|    451|{
  483|    451|   char msg[18+PNG_MAX_ERROR_TEXT];
  484|    451|   if (png_ptr == NULL)
  ------------------
  |  Branch (484:8): [True: 0, False: 451]
  ------------------
  485|      0|      png_error(png_ptr, error_message);
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  486|       |
  487|    451|   else
  488|    451|   {
  489|    451|      png_format_buffer(png_ptr, msg, error_message);
  490|    451|      png_error(png_ptr, msg);
  ------------------
  |  |  252|    902|#define png_error OSS_FUZZ_png_error
  ------------------
  491|    451|   }
  492|    451|}
OSS_FUZZ_png_chunk_warning:
  498|  37.8k|{
  499|  37.8k|   char msg[18+PNG_MAX_ERROR_TEXT];
  500|  37.8k|   if (png_ptr == NULL)
  ------------------
  |  Branch (500:8): [True: 0, False: 37.8k]
  ------------------
  501|      0|      png_warning(png_ptr, warning_message);
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  502|       |
  503|  37.8k|   else
  504|  37.8k|   {
  505|  37.8k|      png_format_buffer(png_ptr, msg, warning_message);
  506|  37.8k|      png_warning(png_ptr, msg);
  ------------------
  |  |  450|  37.8k|#define png_warning OSS_FUZZ_png_warning
  ------------------
  507|  37.8k|   }
  508|  37.8k|}
OSS_FUZZ_png_chunk_benign_error:
  516|  30.3k|{
  517|  30.3k|   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
  ------------------
  |  |  691|  30.3k|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
  |  Branch (517:8): [True: 30.3k, False: 0]
  ------------------
  518|  30.3k|      png_chunk_warning(png_ptr, error_message);
  ------------------
  |  |  240|  30.3k|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
  519|       |
  520|      0|   else
  521|      0|      png_chunk_error(png_ptr, error_message);
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  522|       |
  523|       |#  ifndef PNG_ERROR_TEXT_SUPPORTED
  524|       |      PNG_UNUSED(error_message)
  525|       |#  endif
  526|  30.3k|}
OSS_FUZZ_png_chunk_report:
  532|    178|{
  533|       |#  ifndef PNG_WARNINGS_SUPPORTED
  534|       |      PNG_UNUSED(message)
  535|       |#  endif
  536|       |
  537|       |   /* This is always supported, but for just read or just write it
  538|       |    * unconditionally does the right thing.
  539|       |    */
  540|       |#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)
  541|       |      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
  542|       |#  endif
  543|       |
  544|    178|#  ifdef PNG_READ_SUPPORTED
  545|    178|      {
  546|    178|         if (error < PNG_CHUNK_ERROR)
  ------------------
  |  | 1836|    178|#define PNG_CHUNK_ERROR       2 /* always an error */
  ------------------
  |  Branch (546:14): [True: 178, False: 0]
  ------------------
  547|    178|            png_chunk_warning(png_ptr, message);
  ------------------
  |  |  240|    178|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
  548|       |
  549|      0|         else
  550|      0|            png_chunk_benign_error(png_ptr, message);
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
  551|    178|      }
  552|    178|#  endif
  553|       |
  554|       |#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)
  555|       |      else if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
  556|       |#  endif
  557|       |
  558|       |#  ifdef PNG_WRITE_SUPPORTED
  559|       |      {
  560|       |         if (error < PNG_CHUNK_WRITE_ERROR)
  561|       |            png_app_warning(png_ptr, message);
  562|       |
  563|       |         else
  564|       |            png_app_error(png_ptr, message);
  565|       |      }
  566|       |#  endif
  567|    178|}
OSS_FUZZ_png_set_longjmp_fn:
  599|  3.16k|{
  600|       |   /* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value
  601|       |    * and it must not change after that.  Libpng doesn't care how big the
  602|       |    * buffer is, just that it doesn't change.
  603|       |    *
  604|       |    * If the buffer size is no *larger* than the size of jmp_buf when libpng is
  605|       |    * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0
  606|       |    * semantics that this call will not fail.  If the size is larger, however,
  607|       |    * the buffer is allocated and this may fail, causing the function to return
  608|       |    * NULL.
  609|       |    */
  610|  3.16k|   if (png_ptr == NULL)
  ------------------
  |  Branch (610:8): [True: 0, False: 3.16k]
  ------------------
  611|      0|      return NULL;
  612|       |
  613|  3.16k|   if (png_ptr->jmp_buf_ptr == NULL)
  ------------------
  |  Branch (613:8): [True: 2.05k, False: 1.11k]
  ------------------
  614|  2.05k|   {
  615|  2.05k|      png_ptr->jmp_buf_size = 0; /* not allocated */
  616|       |
  617|  2.05k|      if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))
  ------------------
  |  Branch (617:11): [True: 2.05k, False: 0]
  ------------------
  618|  2.05k|         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;
  619|       |
  620|      0|      else
  621|      0|      {
  622|      0|         png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf *,
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
  623|      0|             png_malloc_warn(png_ptr, jmp_buf_size));
  624|       |
  625|      0|         if (png_ptr->jmp_buf_ptr == NULL)
  ------------------
  |  Branch (625:14): [True: 0, False: 0]
  ------------------
  626|      0|            return NULL; /* new NULL return on OOM */
  627|       |
  628|      0|         png_ptr->jmp_buf_size = jmp_buf_size;
  629|      0|      }
  630|  2.05k|   }
  631|       |
  632|  1.11k|   else /* Already allocated: check the size */
  633|  1.11k|   {
  634|  1.11k|      size_t size = png_ptr->jmp_buf_size;
  635|       |
  636|  1.11k|      if (size == 0)
  ------------------
  |  Branch (636:11): [True: 1.11k, False: 0]
  ------------------
  637|  1.11k|      {
  638|  1.11k|         size = (sizeof png_ptr->jmp_buf_local);
  639|  1.11k|         if (png_ptr->jmp_buf_ptr != &png_ptr->jmp_buf_local)
  ------------------
  |  Branch (639:14): [True: 0, False: 1.11k]
  ------------------
  640|      0|         {
  641|       |            /* This is an internal error in libpng: somehow we have been left
  642|       |             * with a stack allocated jmp_buf when the application regained
  643|       |             * control.  It's always possible to fix this up, but for the moment
  644|       |             * this is a png_error because that makes it easy to detect.
  645|       |             */
  646|      0|            png_error(png_ptr, "Libpng jmp_buf still allocated");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  647|       |            /* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */
  648|      0|         }
  649|  1.11k|      }
  650|       |
  651|  1.11k|      if (size != jmp_buf_size)
  ------------------
  |  Branch (651:11): [True: 0, False: 1.11k]
  ------------------
  652|      0|      {
  653|      0|         png_warning(png_ptr, "Application jmp_buf size changed");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  654|      0|         return NULL; /* caller will probably crash: no choice here */
  655|      0|      }
  656|  1.11k|   }
  657|       |
  658|       |   /* Finally fill in the function, now we have a satisfactory buffer. It is
  659|       |    * valid to change the function on every call.
  660|       |    */
  661|  3.16k|   png_ptr->longjmp_fn = longjmp_fn;
  662|  3.16k|   return png_ptr->jmp_buf_ptr;
  663|  3.16k|}
OSS_FUZZ_png_free_jmpbuf:
  667|  2.60k|{
  668|  2.60k|   if (png_ptr != NULL)
  ------------------
  |  Branch (668:8): [True: 2.60k, False: 0]
  ------------------
  669|  2.60k|   {
  670|  2.60k|      jmp_buf *jb = png_ptr->jmp_buf_ptr;
  671|       |
  672|       |      /* A size of 0 is used to indicate a local, stack, allocation of the
  673|       |       * pointer; used here and in png.c
  674|       |       */
  675|  2.60k|      if (jb != NULL && png_ptr->jmp_buf_size > 0)
  ------------------
  |  Branch (675:11): [True: 2.05k, False: 548]
  |  Branch (675:25): [True: 0, False: 2.05k]
  ------------------
  676|      0|      {
  677|       |
  678|       |         /* This stuff is so that a failure to free the error control structure
  679|       |          * does not leave libpng in a state with no valid error handling: the
  680|       |          * free always succeeds, if there is an error it gets ignored.
  681|       |          */
  682|      0|         if (jb != &png_ptr->jmp_buf_local)
  ------------------
  |  Branch (682:14): [True: 0, False: 0]
  ------------------
  683|      0|         {
  684|       |            /* Make an internal, libpng, jmp_buf to return here */
  685|      0|            jmp_buf free_jmp_buf;
  686|       |
  687|      0|            if (!setjmp(free_jmp_buf))
  ------------------
  |  Branch (687:17): [True: 0, False: 0]
  ------------------
  688|      0|            {
  689|      0|               png_ptr->jmp_buf_ptr = &free_jmp_buf; /* come back here */
  690|      0|               png_ptr->jmp_buf_size = 0; /* stack allocation */
  691|      0|               png_ptr->longjmp_fn = longjmp;
  692|      0|               png_free(png_ptr, jb); /* Return to setjmp on error */
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  693|      0|            }
  694|      0|         }
  695|      0|      }
  696|       |
  697|       |      /* *Always* cancel everything out: */
  698|  2.60k|      png_ptr->jmp_buf_size = 0;
  699|  2.60k|      png_ptr->jmp_buf_ptr = NULL;
  700|  2.60k|      png_ptr->longjmp_fn = 0;
  701|  2.60k|   }
  702|  2.60k|}
OSS_FUZZ_png_longjmp:
  759|  1.50k|{
  760|  1.50k|#ifdef PNG_SETJMP_SUPPORTED
  761|  1.50k|   if (png_ptr != NULL && png_ptr->longjmp_fn != NULL &&
  ------------------
  |  Branch (761:8): [True: 1.50k, False: 0]
  |  Branch (761:27): [True: 1.50k, False: 0]
  ------------------
  762|  1.50k|       png_ptr->jmp_buf_ptr != NULL)
  ------------------
  |  Branch (762:8): [True: 1.50k, False: 0]
  ------------------
  763|  1.50k|      png_ptr->longjmp_fn(*png_ptr->jmp_buf_ptr, val);
  764|       |#else
  765|       |   PNG_UNUSED(png_ptr)
  766|       |   PNG_UNUSED(val)
  767|       |#endif
  768|       |
  769|       |   /* If control reaches this point, png_longjmp() must not return. The only
  770|       |    * choice is to terminate the whole process (or maybe the thread); to do
  771|       |    * this the ANSI-C abort() function is used unless a different method is
  772|       |    * implemented by overriding the default configuration setting for
  773|       |    * PNG_ABORT().
  774|       |    */
  775|  1.50k|   PNG_ABORT();
  ------------------
  |  |  556|  1.50k|#  define PNG_ABORT() abort()
  ------------------
  776|  1.50k|}
OSS_FUZZ_png_set_error_fn:
  837|  2.60k|{
  838|  2.60k|   if (png_ptr == NULL)
  ------------------
  |  Branch (838:8): [True: 0, False: 2.60k]
  ------------------
  839|      0|      return;
  840|       |
  841|  2.60k|   png_ptr->error_ptr = error_ptr;
  842|  2.60k|   png_ptr->error_fn = error_fn;
  843|  2.60k|#ifdef PNG_WARNINGS_SUPPORTED
  844|  2.60k|   png_ptr->warning_fn = warning_fn;
  845|       |#else
  846|       |   PNG_UNUSED(warning_fn)
  847|       |#endif
  848|  2.60k|}
OSS_FUZZ_png_safe_error:
  887|    150|{
  888|    150|   png_const_structrp png_ptr = png_nonconst_ptr;
  889|    150|   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);
  ------------------
  |  |  511|    150|#  define png_voidcast(type, value) (value)
  ------------------
  890|       |
  891|       |   /* An error is always logged here, overwriting anything (typically a warning)
  892|       |    * that is already there:
  893|       |    */
  894|    150|   if (image != NULL)
  ------------------
  |  Branch (894:8): [True: 150, False: 0]
  ------------------
  895|    150|   {
  896|    150|      png_safecat(image->message, (sizeof image->message), 0, error_message);
  ------------------
  |  |   75|    150|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  897|    150|      image->warning_or_error |= PNG_IMAGE_ERROR;
  ------------------
  |  | 2797|    150|#  define PNG_IMAGE_ERROR 2
  ------------------
  898|       |
  899|       |      /* Retrieve the jmp_buf from within the png_control, making this work for
  900|       |       * C++ compilation too is pretty tricky: C++ wants a pointer to the first
  901|       |       * element of a jmp_buf, but C doesn't tell us the type of that.
  902|       |       */
  903|    150|      if (image->opaque != NULL && image->opaque->error_buf != NULL)
  ------------------
  |  Branch (903:11): [True: 150, False: 0]
  |  Branch (903:36): [True: 150, False: 0]
  ------------------
  904|    150|         longjmp(png_control_jmp_buf(image->opaque), 1);
  ------------------
  |  | 2064|    150|#  define png_control_jmp_buf(pc) ((pc)->error_buf)
  ------------------
  905|       |
  906|       |      /* Missing longjmp buffer, the following is to help debugging: */
  907|      0|      {
  908|      0|         size_t pos = png_safecat(image->message, (sizeof image->message), 0,
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  909|      0|             "bad longjmp: ");
  910|      0|         png_safecat(image->message, (sizeof image->message), pos,
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  911|      0|             error_message);
  912|      0|      }
  913|      0|   }
  914|       |
  915|       |   /* Here on an internal programming error. */
  916|      0|   abort();
  917|    150|}
OSS_FUZZ_png_safe_warning:
  922|  10.4k|{
  923|  10.4k|   png_const_structrp png_ptr = png_nonconst_ptr;
  924|  10.4k|   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);
  ------------------
  |  |  511|  10.4k|#  define png_voidcast(type, value) (value)
  ------------------
  925|       |
  926|       |   /* A warning is only logged if there is no prior warning or error. */
  927|  10.4k|   if (image->warning_or_error == 0)
  ------------------
  |  Branch (927:8): [True: 331, False: 10.1k]
  ------------------
  928|    331|   {
  929|    331|      png_safecat(image->message, (sizeof image->message), 0, warning_message);
  ------------------
  |  |   75|    331|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  930|    331|      image->warning_or_error |= PNG_IMAGE_WARNING;
  ------------------
  |  | 2796|    331|#  define PNG_IMAGE_WARNING 1
  ------------------
  931|    331|   }
  932|  10.4k|}
OSS_FUZZ_png_safe_execute:
  937|  1.08k|{
  938|  1.08k|   const png_voidp saved_error_buf = image->opaque->error_buf;
  939|  1.08k|   jmp_buf safe_jmpbuf;
  940|       |
  941|       |   /* Safely execute function(arg), with png_error returning back here. */
  942|  1.08k|   if (setjmp(safe_jmpbuf) == 0)
  ------------------
  |  Branch (942:8): [True: 1.08k, False: 0]
  ------------------
  943|  1.08k|   {
  944|  1.08k|      int result;
  945|       |
  946|  1.08k|      image->opaque->error_buf = safe_jmpbuf;
  947|  1.08k|      result = function(arg);
  948|  1.08k|      image->opaque->error_buf = saved_error_buf;
  949|       |
  950|  1.08k|      if (result)
  ------------------
  |  Branch (950:11): [True: 935, False: 150]
  ------------------
  951|    935|         return 1; /* success */
  952|  1.08k|   }
  953|       |
  954|       |   /* The function failed either because of a caught png_error and a regular
  955|       |    * return of false above or because of an uncaught png_error from the
  956|       |    * function itself.  Ensure that the error_buf is always set back to the
  957|       |    * value saved above:
  958|       |    */
  959|    150|   image->opaque->error_buf = saved_error_buf;
  960|       |
  961|       |   /* On the final false return, when about to return control to the caller, the
  962|       |    * image is freed (png_image_free does this check but it is duplicated here
  963|       |    * for clarity:
  964|       |    */
  965|    150|   if (saved_error_buf == NULL)
  ------------------
  |  Branch (965:8): [True: 150, False: 0]
  ------------------
  966|    150|      png_image_free(image);
  ------------------
  |  |  344|    150|#define png_image_free OSS_FUZZ_png_image_free
  ------------------
  967|       |
  968|    150|   return 0; /* failure */
  969|  1.08k|}
pngerror.c:png_format_buffer:
  436|  38.3k|{
  437|  38.3k|   png_uint_32 chunk_name = png_ptr->chunk_name;
  438|  38.3k|   int iout = 0, ishift = 24;
  439|       |
  440|   191k|   while (ishift >= 0)
  ------------------
  |  Branch (440:11): [True: 153k, False: 38.3k]
  ------------------
  441|   153k|   {
  442|   153k|      int c = (int)(chunk_name >> ishift) & 0xff;
  443|       |
  444|   153k|      ishift -= 8;
  445|   153k|      if (isnonalpha(c) != 0)
  ------------------
  |  |  427|   153k|#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
  |  |  ------------------
  |  |  |  Branch (427:24): [True: 199, False: 153k]
  |  |  |  Branch (427:36): [True: 103, False: 153k]
  |  |  |  Branch (427:50): [True: 43.4k, False: 109k]
  |  |  |  Branch (427:62): [True: 12, False: 43.4k]
  |  |  ------------------
  ------------------
  |  Branch (445:11): [True: 314, False: 153k]
  ------------------
  446|    314|      {
  447|    314|         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
  ------------------
  |  |   45|    314|#    define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
  ------------------
  448|    314|         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
  449|    314|         buffer[iout++] = png_digit[c & 0x0f];
  450|    314|         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
  ------------------
  |  |   48|    314|#    define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
  ------------------
  451|    314|      }
  452|       |
  453|   153k|      else
  454|   153k|      {
  455|   153k|         buffer[iout++] = (char)c;
  456|   153k|      }
  457|   153k|   }
  458|       |
  459|  38.3k|   if (error_message == NULL)
  ------------------
  |  Branch (459:8): [True: 0, False: 38.3k]
  ------------------
  460|      0|      buffer[iout] = '\0';
  461|       |
  462|  38.3k|   else
  463|  38.3k|   {
  464|  38.3k|      int iin = 0;
  465|       |
  466|  38.3k|      buffer[iout++] = ':';
  467|  38.3k|      buffer[iout++] = ' ';
  468|       |
  469|   494k|      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
  ------------------
  |  |  418|   494k|#define PNG_MAX_ERROR_TEXT 196 /* Currently limited by profile_error in png.c */
  ------------------
  |  Branch (469:14): [True: 494k, False: 0]
  |  Branch (469:44): [True: 455k, False: 38.3k]
  ------------------
  470|   455k|         buffer[iout++] = error_message[iin++];
  471|       |
  472|       |      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
  473|  38.3k|      buffer[iout] = '\0';
  474|  38.3k|   }
  475|  38.3k|}
pngerror.c:png_default_error:
  713|  1.50k|{
  714|       |#ifdef PNG_CONSOLE_IO_SUPPORTED
  715|       |#ifdef PNG_ERROR_NUMBERS_SUPPORTED
  716|       |   /* Check on NULL only added in 1.5.4 */
  717|       |   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)
  718|       |   {
  719|       |      /* Strip "#nnnn " from beginning of error message. */
  720|       |      int offset;
  721|       |      char error_number[16];
  722|       |      for (offset = 0; offset<15; offset++)
  723|       |      {
  724|       |         error_number[offset] = error_message[offset + 1];
  725|       |         if (error_message[offset] == ' ')
  726|       |            break;
  727|       |      }
  728|       |
  729|       |      if ((offset > 1) && (offset < 15))
  730|       |      {
  731|       |         error_number[offset - 1] = '\0';
  732|       |         fprintf(stderr, "libpng error no. %s: %s",
  733|       |             error_number, error_message + offset + 1);
  734|       |         fprintf(stderr, PNG_STRING_NEWLINE);
  735|       |      }
  736|       |
  737|       |      else
  738|       |      {
  739|       |         fprintf(stderr, "libpng error: %s, offset=%d",
  740|       |             error_message, offset);
  741|       |         fprintf(stderr, PNG_STRING_NEWLINE);
  742|       |      }
  743|       |   }
  744|       |   else
  745|       |#endif
  746|       |   {
  747|       |      fprintf(stderr, "libpng error: %s", error_message ? error_message :
  748|       |         "undefined");
  749|       |      fprintf(stderr, PNG_STRING_NEWLINE);
  750|       |   }
  751|       |#else
  752|  1.50k|   PNG_UNUSED(error_message) /* Make compiler happy */
  ------------------
  |  |  455|  1.50k|#  define PNG_UNUSED(param) (void)param;
  ------------------
  753|  1.50k|#endif
  754|  1.50k|   png_longjmp(png_ptr, 1);
  ------------------
  |  |  346|  3.01k|#define png_longjmp OSS_FUZZ_png_longjmp
  ------------------
  755|  1.50k|}
pngerror.c:png_default_warning:
  786|  27.9k|{
  787|       |#ifdef PNG_CONSOLE_IO_SUPPORTED
  788|       |#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
  789|       |   if (*warning_message == PNG_LITERAL_SHARP)
  790|       |   {
  791|       |      int offset;
  792|       |      char warning_number[16];
  793|       |      for (offset = 0; offset < 15; offset++)
  794|       |      {
  795|       |         warning_number[offset] = warning_message[offset + 1];
  796|       |         if (warning_message[offset] == ' ')
  797|       |            break;
  798|       |      }
  799|       |
  800|       |      if ((offset > 1) && (offset < 15))
  801|       |      {
  802|       |         warning_number[offset + 1] = '\0';
  803|       |         fprintf(stderr, "libpng warning no. %s: %s",
  804|       |             warning_number, warning_message + offset);
  805|       |         fprintf(stderr, PNG_STRING_NEWLINE);
  806|       |      }
  807|       |
  808|       |      else
  809|       |      {
  810|       |         fprintf(stderr, "libpng warning: %s",
  811|       |             warning_message);
  812|       |         fprintf(stderr, PNG_STRING_NEWLINE);
  813|       |      }
  814|       |   }
  815|       |   else
  816|       |#  endif
  817|       |
  818|       |   {
  819|       |      fprintf(stderr, "libpng warning: %s", warning_message);
  820|       |      fprintf(stderr, PNG_STRING_NEWLINE);
  821|       |   }
  822|       |#else
  823|  27.9k|   PNG_UNUSED(warning_message) /* Make compiler happy */
  ------------------
  |  |  455|  27.9k|#  define PNG_UNUSED(param) (void)param;
  ------------------
  824|  27.9k|#endif
  825|  27.9k|   PNG_UNUSED(png_ptr) /* Make compiler happy */
  ------------------
  |  |  455|  27.9k|#  define PNG_UNUSED(param) (void)param;
  ------------------
  826|  27.9k|}

OSS_FUZZ_png_get_rowbytes:
   41|  1.11k|{
   42|  1.11k|   if (png_ptr != NULL && info_ptr != NULL)
  ------------------
  |  Branch (42:8): [True: 1.11k, False: 0]
  |  Branch (42:27): [True: 1.11k, False: 0]
  ------------------
   43|  1.11k|      return info_ptr->rowbytes;
   44|       |
   45|      0|   return 0;
   46|  1.11k|}
OSS_FUZZ_png_get_IHDR:
  943|  1.11k|{
  944|  1.11k|   png_debug1(1, "in %s retrieval function", "IHDR");
  ------------------
  |  |  151|  1.11k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  945|       |
  946|  1.11k|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (946:8): [True: 0, False: 1.11k]
  |  Branch (946:27): [True: 0, False: 1.11k]
  ------------------
  947|      0|      return 0;
  948|       |
  949|  1.11k|   if (width != NULL)
  ------------------
  |  Branch (949:8): [True: 1.11k, False: 0]
  ------------------
  950|  1.11k|       *width = info_ptr->width;
  951|       |
  952|  1.11k|   if (height != NULL)
  ------------------
  |  Branch (952:8): [True: 1.11k, False: 0]
  ------------------
  953|  1.11k|       *height = info_ptr->height;
  954|       |
  955|  1.11k|   if (bit_depth != NULL)
  ------------------
  |  Branch (955:8): [True: 1.11k, False: 0]
  ------------------
  956|  1.11k|       *bit_depth = info_ptr->bit_depth;
  957|       |
  958|  1.11k|   if (color_type != NULL)
  ------------------
  |  Branch (958:8): [True: 1.11k, False: 0]
  ------------------
  959|  1.11k|       *color_type = info_ptr->color_type;
  960|       |
  961|  1.11k|   if (compression_type != NULL)
  ------------------
  |  Branch (961:8): [True: 1.11k, False: 0]
  ------------------
  962|  1.11k|      *compression_type = info_ptr->compression_type;
  963|       |
  964|  1.11k|   if (filter_type != NULL)
  ------------------
  |  Branch (964:8): [True: 1.11k, False: 0]
  ------------------
  965|  1.11k|      *filter_type = info_ptr->filter_type;
  966|       |
  967|  1.11k|   if (interlace_type != NULL)
  ------------------
  |  Branch (967:8): [True: 1.11k, False: 0]
  ------------------
  968|  1.11k|      *interlace_type = info_ptr->interlace_type;
  969|       |
  970|       |   /* This is redundant if we can be sure that the info_ptr values were all
  971|       |    * assigned in png_set_IHDR().  We do the check anyhow in case an
  972|       |    * application has ignored our advice not to mess with the members
  973|       |    * of info_ptr directly.
  974|       |    */
  975|  1.11k|   png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height,
  ------------------
  |  |   72|  1.11k|#define png_check_IHDR OSS_FUZZ_png_check_IHDR
  ------------------
  976|  1.11k|       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
  977|  1.11k|       info_ptr->compression_type, info_ptr->filter_type);
  978|       |
  979|  1.11k|   return 1;
  980|  1.11k|}

OSS_FUZZ_png_destroy_png_struct:
   25|  2.60k|{
   26|  2.60k|   if (png_ptr != NULL)
  ------------------
  |  Branch (26:8): [True: 2.60k, False: 0]
  ------------------
   27|  2.60k|   {
   28|       |      /* png_free might call png_error and may certainly call
   29|       |       * png_get_mem_ptr, so fake a temporary png_struct to support this.
   30|       |       */
   31|  2.60k|      png_struct dummy_struct = *png_ptr;
   32|  2.60k|      memset(png_ptr, 0, (sizeof *png_ptr));
   33|  2.60k|      png_free(&dummy_struct, png_ptr);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
   34|       |
   35|  2.60k|#     ifdef PNG_SETJMP_SUPPORTED
   36|       |         /* We may have a jmp_buf left to deallocate. */
   37|  2.60k|         png_free_jmpbuf(&dummy_struct);
  ------------------
  |  |   13|  2.60k|#define png_free_jmpbuf OSS_FUZZ_png_free_jmpbuf
  ------------------
   38|  2.60k|#     endif
   39|  2.60k|   }
   40|  2.60k|}
OSS_FUZZ_png_calloc:
   50|    877|{
   51|    877|   png_voidp ret;
   52|       |
   53|    877|   ret = png_malloc(png_ptr, size);
  ------------------
  |  |  347|    877|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
   54|       |
   55|    877|   if (ret != NULL)
  ------------------
  |  Branch (55:8): [True: 876, False: 1]
  ------------------
   56|    876|      memset(ret, 0, size);
   57|       |
   58|    877|   return ret;
   59|    877|}
OSS_FUZZ_png_malloc_base:
   69|  30.0k|{
   70|       |   /* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
   71|       |    * allocators have also been removed in 1.6.0, so any 16-bit system now has
   72|       |    * to implement a user memory handler.  This checks to be sure it isn't
   73|       |    * called with big numbers.
   74|       |    */
   75|       |#  ifdef PNG_MAX_MALLOC_64K
   76|       |      /* This is support for legacy systems which had segmented addressing
   77|       |       * limiting the maximum allocation size to 65536.  It takes precedence
   78|       |       * over PNG_SIZE_MAX which is set to 65535 on true 16-bit systems.
   79|       |       *
   80|       |       * TODO: libpng-1.8: finally remove both cases.
   81|       |       */
   82|       |      if (size > 65536U) return NULL;
   83|       |#  endif
   84|       |
   85|       |   /* This is checked too because the system malloc call below takes a (size_t).
   86|       |    */
   87|  30.0k|   if (size > PNG_SIZE_MAX) return NULL;
  ------------------
  |  |  649|  30.0k|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
  |  Branch (87:8): [True: 0, False: 30.0k]
  ------------------
   88|       |
   89|  30.0k|#  ifdef PNG_USER_MEM_SUPPORTED
   90|  30.0k|      if (png_ptr != NULL && png_ptr->malloc_fn != NULL)
  ------------------
  |  Branch (90:11): [True: 30.0k, False: 0]
  |  Branch (90:30): [True: 16.8k, False: 13.2k]
  ------------------
   91|  16.8k|         return png_ptr->malloc_fn(png_constcast(png_structrp,png_ptr), size);
  ------------------
  |  |  512|  16.8k|#  define png_constcast(type, value) ((type)(void*)(const void*)(value))
  ------------------
   92|       |#  else
   93|       |      PNG_UNUSED(png_ptr)
   94|       |#  endif
   95|       |
   96|       |   /* Use the system malloc */
   97|  13.2k|   return malloc((size_t)/*SAFE*/size); /* checked for truncation above */
   98|  30.0k|}
OSS_FUZZ_png_malloc_array:
  122|    660|{
  123|    660|   if (nelements <= 0 || element_size == 0)
  ------------------
  |  Branch (123:8): [True: 0, False: 660]
  |  Branch (123:26): [True: 0, False: 660]
  ------------------
  124|      0|      png_error(png_ptr, "internal error: array alloc");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  125|       |
  126|    660|   return png_malloc_array_checked(png_ptr, nelements, element_size);
  127|    660|}
OSS_FUZZ_png_realloc_array:
  132|  1.66k|{
  133|       |   /* These are internal errors: */
  134|  1.66k|   if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||
  ------------------
  |  Branch (134:8): [True: 0, False: 1.66k]
  |  Branch (134:29): [True: 0, False: 1.66k]
  |  Branch (134:50): [True: 0, False: 1.66k]
  ------------------
  135|  1.66k|      (old_array == NULL && old_elements > 0))
  ------------------
  |  Branch (135:8): [True: 830, False: 835]
  |  Branch (135:29): [True: 0, False: 830]
  ------------------
  136|      0|      png_error(png_ptr, "internal error: array realloc");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  137|       |
  138|       |   /* Check for overflow on the elements count (so the caller does not have to
  139|       |    * check.)
  140|       |    */
  141|  1.66k|   if (add_elements <= INT_MAX - old_elements)
  ------------------
  |  Branch (141:8): [True: 1.66k, False: 0]
  ------------------
  142|  1.66k|   {
  143|  1.66k|      png_voidp new_array = png_malloc_array_checked(png_ptr,
  144|  1.66k|          old_elements+add_elements, element_size);
  145|       |
  146|  1.66k|      if (new_array != NULL)
  ------------------
  |  Branch (146:11): [True: 1.66k, False: 0]
  ------------------
  147|  1.66k|      {
  148|       |         /* Because png_malloc_array worked the size calculations below cannot
  149|       |          * overflow.
  150|       |          */
  151|  1.66k|         if (old_elements > 0)
  ------------------
  |  Branch (151:14): [True: 835, False: 830]
  ------------------
  152|    835|            memcpy(new_array, old_array, element_size*(unsigned)old_elements);
  153|       |
  154|  1.66k|         memset((char*)new_array + element_size*(unsigned)old_elements, 0,
  155|  1.66k|             element_size*(unsigned)add_elements);
  156|       |
  157|  1.66k|         return new_array;
  158|  1.66k|      }
  159|  1.66k|   }
  160|       |
  161|      0|   return NULL; /* error */
  162|  1.66k|}
OSS_FUZZ_png_malloc:
  171|  6.42k|{
  172|  6.42k|   png_voidp ret;
  173|       |
  174|  6.42k|   if (png_ptr == NULL)
  ------------------
  |  Branch (174:8): [True: 0, False: 6.42k]
  ------------------
  175|      0|      return NULL;
  176|       |
  177|  6.42k|   ret = png_malloc_base(png_ptr, size);
  ------------------
  |  |    8|  6.42k|#define png_malloc_base OSS_FUZZ_png_malloc_base
  ------------------
  178|       |
  179|  6.42k|   if (ret == NULL)
  ------------------
  |  Branch (179:8): [True: 2, False: 6.42k]
  ------------------
  180|      2|       png_error(png_ptr, "Out of memory"); /* 'm' means png_malloc */
  ------------------
  |  |  252|      2|#define png_error OSS_FUZZ_png_error
  ------------------
  181|       |
  182|  6.42k|   return ret;
  183|  6.42k|}
OSS_FUZZ_png_malloc_warn:
  212|  8.64k|{
  213|  8.64k|   if (png_ptr != NULL)
  ------------------
  |  Branch (213:8): [True: 8.64k, False: 0]
  ------------------
  214|  8.64k|   {
  215|  8.64k|      png_voidp ret = png_malloc_base(png_ptr, size);
  ------------------
  |  |    8|  8.64k|#define png_malloc_base OSS_FUZZ_png_malloc_base
  ------------------
  216|       |
  217|  8.64k|      if (ret != NULL)
  ------------------
  |  Branch (217:11): [True: 8.64k, False: 0]
  ------------------
  218|  8.64k|         return ret;
  219|       |
  220|      0|      png_warning(png_ptr, "Out of memory");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  221|      0|   }
  222|       |
  223|      0|   return NULL;
  224|  8.64k|}
OSS_FUZZ_png_free:
  231|  59.2k|{
  232|  59.2k|   if (png_ptr == NULL || ptr == NULL)
  ------------------
  |  Branch (232:8): [True: 0, False: 59.2k]
  |  Branch (232:27): [True: 29.2k, False: 30.0k]
  ------------------
  233|  29.2k|      return;
  234|       |
  235|  30.0k|#ifdef PNG_USER_MEM_SUPPORTED
  236|  30.0k|   if (png_ptr->free_fn != NULL)
  ------------------
  |  Branch (236:8): [True: 22.9k, False: 7.10k]
  ------------------
  237|  22.9k|      png_ptr->free_fn(png_constcast(png_structrp,png_ptr), ptr);
  ------------------
  |  |  512|  22.9k|#  define png_constcast(type, value) ((type)(void*)(const void*)(value))
  ------------------
  238|       |
  239|  7.10k|   else
  240|  7.10k|      png_free_default(png_ptr, ptr);
  ------------------
  |  |  255|  7.10k|#define png_free_default OSS_FUZZ_png_free_default
  ------------------
  241|  30.0k|}
OSS_FUZZ_png_free_default:
  245|  7.10k|{
  246|  7.10k|   if (png_ptr == NULL || ptr == NULL)
  ------------------
  |  Branch (246:8): [True: 0, False: 7.10k]
  |  Branch (246:27): [True: 0, False: 7.10k]
  ------------------
  247|      0|      return;
  248|  7.10k|#endif /* USER_MEM */
  249|       |
  250|  7.10k|   free(ptr);
  251|  7.10k|}
OSS_FUZZ_png_set_mem_fn:
  260|  4.65k|{
  261|  4.65k|   if (png_ptr != NULL)
  ------------------
  |  Branch (261:8): [True: 4.65k, False: 0]
  ------------------
  262|  4.65k|   {
  263|  4.65k|      png_ptr->mem_ptr = mem_ptr;
  264|  4.65k|      png_ptr->malloc_fn = malloc_fn;
  265|  4.65k|      png_ptr->free_fn = free_fn;
  266|  4.65k|   }
  267|  4.65k|}
pngmem.c:png_malloc_array_checked:
  109|  2.32k|{
  110|  2.32k|   png_alloc_size_t req = (png_alloc_size_t)nelements; /* known to be > 0 */
  111|       |
  112|  2.32k|   if (req <= PNG_SIZE_MAX/element_size)
  ------------------
  |  |  649|  2.32k|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
  |  Branch (112:8): [True: 2.32k, False: 0]
  ------------------
  113|  2.32k|      return png_malloc_base(png_ptr, req * element_size);
  ------------------
  |  |    8|  2.32k|#define png_malloc_base OSS_FUZZ_png_malloc_base
  ------------------
  114|       |
  115|       |   /* The failure case when the request is too large */
  116|      0|   return NULL;
  117|  2.32k|}

OSS_FUZZ_png_create_read_struct:
   27|  2.60k|{
   28|       |#ifndef PNG_USER_MEM_SUPPORTED
   29|       |   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
   30|       |        error_fn, warn_fn, NULL, NULL, NULL);
   31|       |#else
   32|  2.60k|   return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
  ------------------
  |  |  245|  2.60k|#define png_create_read_struct_2 OSS_FUZZ_png_create_read_struct_2
  ------------------
   33|  2.60k|        warn_fn, NULL, NULL, NULL);
   34|  2.60k|}
OSS_FUZZ_png_create_read_struct_2:
   43|  2.60k|{
   44|  2.60k|   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
  ------------------
  |  |   11|  2.60k|#define png_create_png_struct OSS_FUZZ_png_create_png_struct
  ------------------
   45|  2.60k|       error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
   46|  2.60k|#endif /* USER_MEM */
   47|       |
   48|  2.60k|   if (png_ptr != NULL)
  ------------------
  |  Branch (48:8): [True: 2.60k, False: 0]
  ------------------
   49|  2.60k|   {
   50|  2.60k|      png_ptr->mode = PNG_IS_READ_STRUCT;
  ------------------
  |  |  631|  2.60k|#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */
  ------------------
   51|       |
   52|       |      /* Added in libpng-1.6.0; this can be used to detect a read structure if
   53|       |       * required (it will be zero in a write structure.)
   54|       |       */
   55|  2.60k|#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
   56|  2.60k|         png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
  ------------------
  |  |  209|  2.60k|#define PNG_IDAT_READ_SIZE PNG_ZBUF_SIZE
  |  |  ------------------
  |  |  |  |  226|  2.60k|#define PNG_ZBUF_SIZE 8192
  |  |  ------------------
  ------------------
   57|  2.60k|#     endif
   58|       |
   59|  2.60k|#     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
   60|  2.60k|         png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
  ------------------
  |  |  691|  2.60k|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
   61|       |
   62|       |         /* In stable builds only warn if an application error can be completely
   63|       |          * handled.
   64|       |          */
   65|       |#        if PNG_RELEASE_BUILD
   66|       |            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
   67|       |#        endif
   68|  2.60k|#     endif
   69|       |
   70|       |      /* TODO: delay this, it can be done in png_init_io (if the app doesn't
   71|       |       * do it itself) avoiding setting the default function if it is not
   72|       |       * required.
   73|       |       */
   74|  2.60k|      png_set_read_fn(png_ptr, NULL, NULL);
  ------------------
  |  |  417|  2.60k|#define png_set_read_fn OSS_FUZZ_png_set_read_fn
  ------------------
   75|  2.60k|   }
   76|       |
   77|  2.60k|   return png_ptr;
   78|  2.60k|}
OSS_FUZZ_png_read_info:
   92|  2.60k|{
   93|  2.60k|#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   94|  2.60k|   int keep;
   95|  2.60k|#endif
   96|       |
   97|  2.60k|   png_debug(1, "in png_read_info");
  ------------------
  |  |  148|  2.60k|#  define png_debug(l, m) ((void)0)
  ------------------
   98|       |
   99|  2.60k|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (99:8): [True: 0, False: 2.60k]
  |  Branch (99:27): [True: 0, False: 2.60k]
  ------------------
  100|      0|      return;
  101|       |
  102|       |   /* Read and check the PNG file signature. */
  103|  2.60k|   png_read_sig(png_ptr, info_ptr);
  ------------------
  |  |   21|  2.60k|#define png_read_sig OSS_FUZZ_png_read_sig
  ------------------
  104|       |
  105|  2.60k|   for (;;)
  106|  52.2k|   {
  107|  52.2k|      png_uint_32 length = png_read_chunk_header(png_ptr);
  ------------------
  |  |   22|  52.2k|#define png_read_chunk_header OSS_FUZZ_png_read_chunk_header
  ------------------
  108|  52.2k|      png_uint_32 chunk_name = png_ptr->chunk_name;
  109|       |
  110|       |      /* IDAT logic needs to happen here to simplify getting the two flags
  111|       |       * right.
  112|       |       */
  113|  52.2k|      if (chunk_name == png_IDAT)
  ------------------
  |  |  862|  52.2k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  52.2k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (113:11): [True: 1.65k, False: 50.5k]
  ------------------
  114|  1.65k|      {
  115|  1.65k|         if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
  ------------------
  |  |  642|  1.65k|#define PNG_HAVE_IHDR  0x01
  ------------------
  |  Branch (115:14): [True: 1, False: 1.65k]
  ------------------
  116|      1|            png_chunk_error(png_ptr, "Missing IHDR before IDAT");
  ------------------
  |  |  239|      1|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  117|       |
  118|  1.65k|         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
  ------------------
  |  |  667|  3.30k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.65k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.65k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (118:19): [True: 308, False: 1.34k]
  ------------------
  119|  1.65k|             (png_ptr->mode & PNG_HAVE_PLTE) == 0)
  ------------------
  |  |  643|    308|#define PNG_HAVE_PLTE  0x02
  ------------------
  |  Branch (119:14): [True: 1, False: 307]
  ------------------
  120|      1|            png_chunk_error(png_ptr, "Missing PLTE before IDAT");
  ------------------
  |  |  239|      1|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  121|       |
  122|  1.65k|         else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
  ------------------
  |  |  644|  1.65k|#define PNG_AFTER_IDAT 0x08
  ------------------
  |  Branch (122:19): [True: 0, False: 1.65k]
  ------------------
  123|      0|            png_chunk_benign_error(png_ptr, "Too many IDATs found");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
  124|       |
  125|  1.65k|         png_ptr->mode |= PNG_HAVE_IDAT;
  ------------------
  |  |  618|  1.65k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  126|  1.65k|      }
  127|       |
  128|  50.5k|      else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|  50.5k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (128:16): [True: 0, False: 50.5k]
  ------------------
  129|      0|      {
  130|      0|         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
  ------------------
  |  |  629|      0|#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
  ------------------
  131|      0|         png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|      0|#define PNG_AFTER_IDAT 0x08
  ------------------
  132|      0|      }
  133|       |
  134|  52.2k|      if (chunk_name == png_IHDR)
  ------------------
  |  |  864|  52.2k|#define png_IHDR PNG_U32( 73,  72,  68,  82)
  |  |  ------------------
  |  |  |  |  821|  52.2k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  52.2k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (134:11): [True: 2.57k, False: 49.6k]
  ------------------
  135|  2.57k|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|  2.57k|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  136|       |
  137|  49.6k|      else if (chunk_name == png_IEND)
  ------------------
  |  |  863|  49.6k|#define png_IEND PNG_U32( 73,  69,  78,  68)
  |  |  ------------------
  |  |  |  |  821|  49.6k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (137:16): [True: 1, False: 49.6k]
  ------------------
  138|      1|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|      1|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  139|       |
  140|  49.6k|#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
  141|  49.6k|      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
  ------------------
  |  |   51|  49.6k|#define png_chunk_unknown_handling OSS_FUZZ_png_chunk_unknown_handling
  ------------------
  |  Branch (141:16): [True: 0, False: 49.6k]
  ------------------
  142|      0|      {
  143|      0|         png_handle_unknown(png_ptr, info_ptr, length, keep);
  ------------------
  |  |   49|      0|#define png_handle_unknown OSS_FUZZ_png_handle_unknown
  ------------------
  144|       |
  145|      0|         if (chunk_name == png_PLTE)
  ------------------
  |  |  865|      0|#define png_PLTE PNG_U32( 80,  76,  84,  69)
  |  |  ------------------
  |  |  |  |  821|      0|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (145:14): [True: 0, False: 0]
  ------------------
  146|      0|            png_ptr->mode |= PNG_HAVE_PLTE;
  ------------------
  |  |  643|      0|#define PNG_HAVE_PLTE  0x02
  ------------------
  147|       |
  148|      0|         else if (chunk_name == png_IDAT)
  ------------------
  |  |  862|      0|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|      0|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (148:19): [True: 0, False: 0]
  ------------------
  149|      0|         {
  150|      0|            png_ptr->idat_size = 0; /* It has been consumed */
  151|      0|            break;
  152|      0|         }
  153|      0|      }
  154|  49.6k|#endif
  155|       |
  156|  49.6k|      else if (chunk_name == png_IDAT)
  ------------------
  |  |  862|  49.6k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  49.6k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  49.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (156:16): [True: 1.65k, False: 48.0k]
  ------------------
  157|  1.65k|      {
  158|  1.65k|         png_ptr->idat_size = length;
  159|  1.65k|         break;
  160|  1.65k|      }
  161|       |
  162|  48.0k|      else
  163|  48.0k|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|  48.0k|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  164|  52.2k|   }
  165|  2.60k|}
OSS_FUZZ_png_read_update_info:
  171|  1.64k|{
  172|  1.64k|   png_debug(1, "in png_read_update_info");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
  173|       |
  174|  1.64k|   if (png_ptr != NULL)
  ------------------
  |  Branch (174:8): [True: 1.64k, False: 0]
  ------------------
  175|  1.64k|   {
  176|  1.64k|      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
  ------------------
  |  |  677|  1.64k|#define PNG_FLAG_ROW_INIT                 0x0040U
  ------------------
  |  Branch (176:11): [True: 1.64k, False: 0]
  ------------------
  177|  1.64k|      {
  178|  1.64k|         png_read_start_row(png_ptr);
  ------------------
  |  |   41|  1.64k|#define png_read_start_row OSS_FUZZ_png_read_start_row
  ------------------
  179|       |
  180|  1.64k|#        ifdef PNG_READ_TRANSFORMS_SUPPORTED
  181|  1.64k|            png_read_transform_info(png_ptr, info_ptr);
  ------------------
  |  |   43|  1.64k|#define png_read_transform_info OSS_FUZZ_png_read_transform_info
  ------------------
  182|       |#        else
  183|       |            PNG_UNUSED(info_ptr)
  184|       |#        endif
  185|  1.64k|      }
  186|       |
  187|       |      /* New in 1.6.0 this avoids the bug of doing the initializations twice */
  188|      0|      else
  189|      0|         png_app_error(png_ptr,
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
  190|      0|             "png_read_update_info/png_start_read_image: duplicate call");
  191|  1.64k|   }
  192|  1.64k|}
OSS_FUZZ_png_read_row:
  287|   610k|{
  288|   610k|   png_row_info row_info;
  289|       |
  290|   610k|   if (png_ptr == NULL)
  ------------------
  |  Branch (290:8): [True: 0, False: 610k]
  ------------------
  291|      0|      return;
  292|       |
  293|   610k|   png_debug2(1, "in png_read_row (row %lu, pass %d)",
  ------------------
  |  |  154|   610k|#  define png_debug2(l, m, p1, p2) ((void)0)
  ------------------
  294|   610k|       (unsigned long)png_ptr->row_number, png_ptr->pass);
  295|       |
  296|       |   /* png_read_start_row sets the information (in particular iwidth) for this
  297|       |    * interlace pass.
  298|       |    */
  299|   610k|   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
  ------------------
  |  |  677|   610k|#define PNG_FLAG_ROW_INIT                 0x0040U
  ------------------
  |  Branch (299:8): [True: 0, False: 610k]
  ------------------
  300|      0|      png_read_start_row(png_ptr);
  ------------------
  |  |   41|      0|#define png_read_start_row OSS_FUZZ_png_read_start_row
  ------------------
  301|       |
  302|       |   /* 1.5.6: row_info moved out of png_struct to a local here. */
  303|   610k|   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */
  304|   610k|   row_info.color_type = png_ptr->color_type;
  305|   610k|   row_info.bit_depth = png_ptr->bit_depth;
  306|   610k|   row_info.channels = png_ptr->channels;
  307|   610k|   row_info.pixel_depth = png_ptr->pixel_depth;
  308|   610k|   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
  ------------------
  |  |  731|   610k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 589k, False: 20.7k]
  |  |  ------------------
  |  |  732|   610k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|   610k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
  309|       |
  310|   610k|#ifdef PNG_WARNINGS_SUPPORTED
  311|   610k|   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
  ------------------
  |  Branch (311:8): [True: 3.91k, False: 606k]
  |  Branch (311:36): [True: 1.64k, False: 2.26k]
  ------------------
  312|  1.64k|   {
  313|       |   /* Check for transforms that have been set but were defined out */
  314|       |#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
  315|       |   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
  316|       |      png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined");
  317|       |#endif
  318|       |
  319|       |#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)
  320|       |   if ((png_ptr->transformations & PNG_FILLER) != 0)
  321|       |      png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined");
  322|       |#endif
  323|       |
  324|       |#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
  325|       |    !defined(PNG_READ_PACKSWAP_SUPPORTED)
  326|       |   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
  327|       |      png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined");
  328|       |#endif
  329|       |
  330|       |#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)
  331|       |   if ((png_ptr->transformations & PNG_PACK) != 0)
  332|       |      png_warning(png_ptr, "PNG_READ_PACK_SUPPORTED is not defined");
  333|       |#endif
  334|       |
  335|       |#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)
  336|       |   if ((png_ptr->transformations & PNG_SHIFT) != 0)
  337|       |      png_warning(png_ptr, "PNG_READ_SHIFT_SUPPORTED is not defined");
  338|       |#endif
  339|       |
  340|       |#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)
  341|       |   if ((png_ptr->transformations & PNG_BGR) != 0)
  342|       |      png_warning(png_ptr, "PNG_READ_BGR_SUPPORTED is not defined");
  343|       |#endif
  344|       |
  345|       |#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)
  346|       |   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
  347|       |      png_warning(png_ptr, "PNG_READ_SWAP_SUPPORTED is not defined");
  348|       |#endif
  349|  1.64k|   }
  350|   610k|#endif /* WARNINGS */
  351|       |
  352|   610k|#ifdef PNG_READ_INTERLACING_SUPPORTED
  353|       |   /* If interlaced and we do not need a new row, combine row and return.
  354|       |    * Notice that the pixels we have from previous rows have been transformed
  355|       |    * already; we can only combine like with like (transformed or
  356|       |    * untransformed) and, because of the libpng API for interlaced images, this
  357|       |    * means we must transform before de-interlacing.
  358|       |    */
  359|   610k|   if (png_ptr->interlaced != 0 &&
  ------------------
  |  Branch (359:8): [True: 487k, False: 122k]
  ------------------
  360|   610k|       (png_ptr->transformations & PNG_INTERLACE) != 0)
  ------------------
  |  |  635|   487k|#define PNG_INTERLACE           0x0002U
  ------------------
  |  Branch (360:8): [True: 487k, False: 0]
  ------------------
  361|   487k|   {
  362|   487k|      switch (png_ptr->pass)
  363|   487k|      {
  364|  86.9k|         case 0:
  ------------------
  |  Branch (364:10): [True: 86.9k, False: 400k]
  ------------------
  365|  86.9k|            if (png_ptr->row_number & 0x07)
  ------------------
  |  Branch (365:17): [True: 75.9k, False: 11.0k]
  ------------------
  366|  75.9k|            {
  367|  75.9k|               if (dsp_row != NULL)
  ------------------
  |  Branch (367:20): [True: 0, False: 75.9k]
  ------------------
  368|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  369|  75.9k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  75.9k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  370|  75.9k|               return;
  371|  75.9k|            }
  372|  11.0k|            break;
  373|       |
  374|  81.2k|         case 1:
  ------------------
  |  Branch (374:10): [True: 81.2k, False: 406k]
  ------------------
  375|  81.2k|            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
  ------------------
  |  Branch (375:17): [True: 71.0k, False: 10.2k]
  |  Branch (375:49): [True: 6.31k, False: 3.96k]
  ------------------
  376|  77.3k|            {
  377|  77.3k|               if (dsp_row != NULL)
  ------------------
  |  Branch (377:20): [True: 0, False: 77.3k]
  ------------------
  378|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  379|       |
  380|  77.3k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  77.3k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  381|  77.3k|               return;
  382|  77.3k|            }
  383|  3.96k|            break;
  384|       |
  385|  76.8k|         case 2:
  ------------------
  |  Branch (385:10): [True: 76.8k, False: 410k]
  ------------------
  386|  76.8k|            if ((png_ptr->row_number & 0x07) != 4)
  ------------------
  |  Branch (386:17): [True: 67.1k, False: 9.70k]
  ------------------
  387|  67.1k|            {
  388|  67.1k|               if (dsp_row != NULL && (png_ptr->row_number & 4))
  ------------------
  |  Branch (388:20): [True: 0, False: 67.1k]
  |  Branch (388:39): [True: 0, False: 0]
  ------------------
  389|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  390|       |
  391|  67.1k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  67.1k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  392|  67.1k|               return;
  393|  67.1k|            }
  394|  9.70k|            break;
  395|       |
  396|  71.4k|         case 3:
  ------------------
  |  Branch (396:10): [True: 71.4k, False: 416k]
  ------------------
  397|  71.4k|            if ((png_ptr->row_number & 3) || png_ptr->width < 3)
  ------------------
  |  Branch (397:17): [True: 53.3k, False: 18.0k]
  |  Branch (397:46): [True: 12.5k, False: 5.53k]
  ------------------
  398|  65.8k|            {
  399|  65.8k|               if (dsp_row != NULL)
  ------------------
  |  Branch (399:20): [True: 0, False: 65.8k]
  ------------------
  400|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  401|       |
  402|  65.8k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  65.8k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  403|  65.8k|               return;
  404|  65.8k|            }
  405|  5.53k|            break;
  406|       |
  407|  67.4k|         case 4:
  ------------------
  |  Branch (407:10): [True: 67.4k, False: 420k]
  ------------------
  408|  67.4k|            if ((png_ptr->row_number & 3) != 2)
  ------------------
  |  Branch (408:17): [True: 50.6k, False: 16.8k]
  ------------------
  409|  50.6k|            {
  410|  50.6k|               if (dsp_row != NULL && (png_ptr->row_number & 2))
  ------------------
  |  Branch (410:20): [True: 0, False: 50.6k]
  |  Branch (410:39): [True: 0, False: 0]
  ------------------
  411|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  412|       |
  413|  50.6k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  50.6k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  414|  50.6k|               return;
  415|  50.6k|            }
  416|  16.8k|            break;
  417|       |
  418|  52.3k|         case 5:
  ------------------
  |  Branch (418:10): [True: 52.3k, False: 435k]
  ------------------
  419|  52.3k|            if ((png_ptr->row_number & 1) || png_ptr->width < 2)
  ------------------
  |  Branch (419:17): [True: 26.0k, False: 26.3k]
  |  Branch (419:46): [True: 16.5k, False: 9.75k]
  ------------------
  420|  42.5k|            {
  421|  42.5k|               if (dsp_row != NULL)
  ------------------
  |  Branch (421:20): [True: 0, False: 42.5k]
  ------------------
  422|      0|                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  423|       |
  424|  42.5k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  42.5k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  425|  42.5k|               return;
  426|  42.5k|            }
  427|  9.75k|            break;
  428|       |
  429|  9.75k|         default:
  ------------------
  |  Branch (429:10): [True: 0, False: 487k]
  ------------------
  430|  51.1k|         case 6:
  ------------------
  |  Branch (430:10): [True: 51.1k, False: 436k]
  ------------------
  431|  51.1k|            if ((png_ptr->row_number & 1) == 0)
  ------------------
  |  Branch (431:17): [True: 25.6k, False: 25.4k]
  ------------------
  432|  25.6k|            {
  433|  25.6k|               png_read_finish_row(png_ptr);
  ------------------
  |  |   40|  25.6k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  434|  25.6k|               return;
  435|  25.6k|            }
  436|  25.4k|            break;
  437|   487k|      }
  438|   487k|   }
  439|   205k|#endif
  440|       |
  441|   205k|   if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
  ------------------
  |  |  618|   205k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (441:8): [True: 0, False: 205k]
  ------------------
  442|      0|      png_error(png_ptr, "Invalid attempt to read row data");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  443|       |
  444|       |   /* Fill the row with IDAT data: */
  445|   205k|   png_ptr->row_buf[0]=255; /* to force error if no data was found */
  446|   205k|   png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
  ------------------
  |  |   38|   205k|#define png_read_IDAT_data OSS_FUZZ_png_read_IDAT_data
  ------------------
  447|       |
  448|   205k|   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
  ------------------
  |  | 1489|   205k|#define PNG_FILTER_VALUE_NONE  0
  ------------------
  |  Branch (448:8): [True: 128k, False: 76.3k]
  ------------------
  449|   128k|   {
  450|   128k|      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
  ------------------
  |  | 1494|   128k|#define PNG_FILTER_VALUE_LAST  5
  ------------------
  |  Branch (450:11): [True: 128k, False: 229]
  ------------------
  451|   128k|         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
  ------------------
  |  |   36|   128k|#define png_read_filter_row OSS_FUZZ_png_read_filter_row
  ------------------
  452|   128k|             png_ptr->prev_row + 1, png_ptr->row_buf[0]);
  453|    229|      else
  454|    229|         png_error(png_ptr, "bad adaptive filter value");
  ------------------
  |  |  252|    229|#define png_error OSS_FUZZ_png_error
  ------------------
  455|   128k|   }
  456|       |
  457|       |   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
  458|       |    * 1.5.6, while the buffer really is this big in current versions of libpng
  459|       |    * it may not be in the future, so this was changed just to copy the
  460|       |    * interlaced count:
  461|       |    */
  462|   204k|   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);
  463|       |
  464|   204k|#ifdef PNG_MNG_FEATURES_SUPPORTED
  465|   204k|   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
  ------------------
  |  |  871|   204k|#define PNG_FLAG_MNG_FILTER_64      0x04
  ------------------
  |  Branch (465:8): [True: 0, False: 204k]
  ------------------
  466|   204k|       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
  ------------------
  |  |  681|      0|#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
  ------------------
  |  Branch (466:8): [True: 0, False: 0]
  ------------------
  467|      0|   {
  468|       |      /* Intrapixel differencing */
  469|      0|      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);
  470|      0|   }
  471|   204k|#endif
  472|       |
  473|   204k|#ifdef PNG_READ_TRANSFORMS_SUPPORTED
  474|   204k|   if (png_ptr->transformations
  ------------------
  |  Branch (474:8): [True: 204k, False: 0]
  ------------------
  475|   204k|#     ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
  476|   204k|         || png_ptr->num_palette_max >= 0
  ------------------
  |  Branch (476:13): [True: 0, False: 0]
  ------------------
  477|   204k|#     endif
  478|   204k|      )
  479|   204k|      png_do_read_transformations(png_ptr, &row_info);
  ------------------
  |  |   52|   204k|#define png_do_read_transformations OSS_FUZZ_png_do_read_transformations
  ------------------
  480|   204k|#endif
  481|       |
  482|       |   /* The transformed pixel depth should match the depth now in row_info. */
  483|   204k|   if (png_ptr->transformed_pixel_depth == 0)
  ------------------
  |  Branch (483:8): [True: 1.62k, False: 203k]
  ------------------
  484|  1.62k|   {
  485|  1.62k|      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
  486|  1.62k|      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
  ------------------
  |  Branch (486:11): [True: 0, False: 1.62k]
  ------------------
  487|      0|         png_error(png_ptr, "sequential row overflow");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  488|  1.62k|   }
  489|       |
  490|   203k|   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
  ------------------
  |  Branch (490:13): [True: 0, False: 203k]
  ------------------
  491|      0|      png_error(png_ptr, "internal sequential row size calculation error");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  492|       |
  493|   204k|#ifdef PNG_READ_INTERLACING_SUPPORTED
  494|       |   /* Expand interlaced rows to full size */
  495|   204k|   if (png_ptr->interlaced != 0 &&
  ------------------
  |  Branch (495:8): [True: 82.0k, False: 122k]
  ------------------
  496|   204k|      (png_ptr->transformations & PNG_INTERLACE) != 0)
  ------------------
  |  |  635|  82.0k|#define PNG_INTERLACE           0x0002U
  ------------------
  |  Branch (496:7): [True: 82.0k, False: 0]
  ------------------
  497|  82.0k|   {
  498|  82.0k|      if (png_ptr->pass < 6)
  ------------------
  |  Branch (498:11): [True: 56.6k, False: 25.4k]
  ------------------
  499|  56.6k|         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
  ------------------
  |  |   35|  56.6k|#define png_do_read_interlace OSS_FUZZ_png_do_read_interlace
  ------------------
  500|  56.6k|             png_ptr->transformations);
  501|       |
  502|  82.0k|      if (dsp_row != NULL)
  ------------------
  |  Branch (502:11): [True: 0, False: 82.0k]
  ------------------
  503|      0|         png_combine_row(png_ptr, dsp_row, 1/*display*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  504|       |
  505|  82.0k|      if (row != NULL)
  ------------------
  |  Branch (505:11): [True: 82.0k, False: 0]
  ------------------
  506|  82.0k|         png_combine_row(png_ptr, row, 0/*row*/);
  ------------------
  |  |   34|  82.0k|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  507|  82.0k|   }
  508|       |
  509|   122k|   else
  510|   122k|#endif
  511|   122k|   {
  512|   122k|      if (row != NULL)
  ------------------
  |  Branch (512:11): [True: 122k, False: 209]
  ------------------
  513|   122k|         png_combine_row(png_ptr, row, -1/*ignored*/);
  ------------------
  |  |   34|   122k|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  514|       |
  515|   122k|      if (dsp_row != NULL)
  ------------------
  |  Branch (515:11): [True: 0, False: 122k]
  ------------------
  516|      0|         png_combine_row(png_ptr, dsp_row, -1/*ignored*/);
  ------------------
  |  |   34|      0|#define png_combine_row OSS_FUZZ_png_combine_row
  ------------------
  517|   122k|   }
  518|   204k|   png_read_finish_row(png_ptr);
  ------------------
  |  |   40|   204k|#define png_read_finish_row OSS_FUZZ_png_read_finish_row
  ------------------
  519|       |
  520|   204k|   if (png_ptr->read_row_fn != NULL)
  ------------------
  |  Branch (520:8): [True: 0, False: 204k]
  ------------------
  521|      0|      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
  522|       |
  523|   204k|}
OSS_FUZZ_png_read_end:
  674|    623|{
  675|    623|#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
  676|    623|   int keep;
  677|    623|#endif
  678|       |
  679|    623|   png_debug(1, "in png_read_end");
  ------------------
  |  |  148|    623|#  define png_debug(l, m) ((void)0)
  ------------------
  680|       |
  681|    623|   if (png_ptr == NULL)
  ------------------
  |  Branch (681:8): [True: 0, False: 623]
  ------------------
  682|      0|      return;
  683|       |
  684|       |   /* If png_read_end is called in the middle of reading the rows there may
  685|       |    * still be pending IDAT data and an owned zstream.  Deal with this here.
  686|       |    */
  687|    623|#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
  688|    623|   if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
  ------------------
  |  |   51|    623|#define png_chunk_unknown_handling OSS_FUZZ_png_chunk_unknown_handling
  ------------------
                 if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
  ------------------
  |  |  862|    623|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|    623|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    623|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    623|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    623|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    623|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (688:8): [True: 623, False: 0]
  ------------------
  689|    623|#endif
  690|    623|      png_read_finish_IDAT(png_ptr);
  ------------------
  |  |   39|    623|#define png_read_finish_IDAT OSS_FUZZ_png_read_finish_IDAT
  ------------------
  691|       |
  692|    623|#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
  693|       |   /* Report invalid palette index; added at libng-1.5.10 */
  694|    623|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
  ------------------
  |  |  667|  1.24k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    623|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    623|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (694:8): [True: 110, False: 513]
  ------------------
  695|    623|       png_ptr->num_palette_max >= png_ptr->num_palette)
  ------------------
  |  Branch (695:8): [True: 0, False: 110]
  ------------------
  696|      0|      png_benign_error(png_ptr, "Read palette index exceeding num_palette");
  ------------------
  |  |  235|      0|#define png_benign_error OSS_FUZZ_png_benign_error
  ------------------
  697|    623|#endif
  698|       |
  699|    623|   do
  700|  3.37k|   {
  701|  3.37k|      png_uint_32 length = png_read_chunk_header(png_ptr);
  ------------------
  |  |   22|  3.37k|#define png_read_chunk_header OSS_FUZZ_png_read_chunk_header
  ------------------
  702|  3.37k|      png_uint_32 chunk_name = png_ptr->chunk_name;
  703|       |
  704|  3.37k|      if (chunk_name != png_IDAT)
  ------------------
  |  |  862|  3.37k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  3.37k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (704:11): [True: 2.95k, False: 427]
  ------------------
  705|  2.95k|         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
  ------------------
  |  |  629|  2.95k|#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
  ------------------
  706|       |
  707|  3.37k|      if (chunk_name == png_IEND)
  ------------------
  |  |  863|  3.37k|#define png_IEND PNG_U32( 73,  69,  78,  68)
  |  |  ------------------
  |  |  |  |  821|  3.37k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  3.37k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (707:11): [True: 549, False: 2.82k]
  ------------------
  708|    549|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|    549|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  709|       |
  710|  2.82k|      else if (chunk_name == png_IHDR)
  ------------------
  |  |  864|  2.82k|#define png_IHDR PNG_U32( 73,  72,  68,  82)
  |  |  ------------------
  |  |  |  |  821|  2.82k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (710:16): [True: 1, False: 2.82k]
  ------------------
  711|      1|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|      1|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  712|       |
  713|  2.82k|      else if (info_ptr == NULL)
  ------------------
  |  Branch (713:16): [True: 0, False: 2.82k]
  ------------------
  714|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  715|       |
  716|  2.82k|#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
  717|  2.82k|      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
  ------------------
  |  |   51|  2.82k|#define png_chunk_unknown_handling OSS_FUZZ_png_chunk_unknown_handling
  ------------------
  |  Branch (717:16): [True: 0, False: 2.82k]
  ------------------
  718|      0|      {
  719|      0|         if (chunk_name == png_IDAT)
  ------------------
  |  |  862|      0|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|      0|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (719:14): [True: 0, False: 0]
  ------------------
  720|      0|         {
  721|      0|            if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))
  ------------------
  |  |  674|      0|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
  |  Branch (721:18): [True: 0, False: 0]
  |  Branch (721:32): [True: 0, False: 0]
  ------------------
  722|      0|                || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
  ------------------
  |  |  629|      0|#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
  ------------------
  |  Branch (722:20): [True: 0, False: 0]
  ------------------
  723|      0|               png_benign_error(png_ptr, ".Too many IDATs found");
  ------------------
  |  |  235|      0|#define png_benign_error OSS_FUZZ_png_benign_error
  ------------------
  724|      0|         }
  725|      0|         png_handle_unknown(png_ptr, info_ptr, length, keep);
  ------------------
  |  |   49|      0|#define png_handle_unknown OSS_FUZZ_png_handle_unknown
  ------------------
  726|      0|         if (chunk_name == png_PLTE)
  ------------------
  |  |  865|      0|#define png_PLTE PNG_U32( 80,  76,  84,  69)
  |  |  ------------------
  |  |  |  |  821|      0|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|      0|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (726:14): [True: 0, False: 0]
  ------------------
  727|      0|            png_ptr->mode |= PNG_HAVE_PLTE;
  ------------------
  |  |  643|      0|#define PNG_HAVE_PLTE  0x02
  ------------------
  728|      0|      }
  729|  2.82k|#endif
  730|       |
  731|  2.82k|      else if (chunk_name == png_IDAT)
  ------------------
  |  |  862|  2.82k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  2.82k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  2.82k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (731:16): [True: 384, False: 2.44k]
  ------------------
  732|    384|      {
  733|       |         /* Zero length IDATs are legal after the last IDAT has been
  734|       |          * read, but not after other chunks have been read.  1.6 does not
  735|       |          * always read all the deflate data; specifically it cannot be relied
  736|       |          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
  737|       |          * chunks which are longer than zero as well:
  738|       |          */
  739|    384|         if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))
  ------------------
  |  |  674|    370|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
  |  Branch (739:15): [True: 370, False: 14]
  |  Branch (739:29): [True: 0, False: 370]
  ------------------
  740|    384|             || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
  ------------------
  |  |  629|    384|#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
  ------------------
  |  Branch (740:17): [True: 355, False: 29]
  ------------------
  741|    355|            png_benign_error(png_ptr, "..Too many IDATs found");
  ------------------
  |  |  235|    355|#define png_benign_error OSS_FUZZ_png_benign_error
  ------------------
  742|       |
  743|    384|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|    384|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  744|    384|      }
  745|       |
  746|  2.44k|      else
  747|  2.44k|         png_handle_chunk(png_ptr, info_ptr, length);
  ------------------
  |  |   50|  2.44k|#define png_handle_chunk OSS_FUZZ_png_handle_chunk
  ------------------
  748|  3.37k|   } while ((png_ptr->mode & PNG_HAVE_IEND) == 0);
  ------------------
  |  |  620|  3.37k|#define PNG_HAVE_IEND               0x10U
  ------------------
  |  Branch (748:13): [True: 2.75k, False: 623]
  ------------------
  749|    623|}
OSS_FUZZ_png_destroy_read_struct:
  827|  4.65k|{
  828|  4.65k|   png_structrp png_ptr = NULL;
  829|       |
  830|  4.65k|   png_debug(1, "in png_destroy_read_struct");
  ------------------
  |  |  148|  4.65k|#  define png_debug(l, m) ((void)0)
  ------------------
  831|       |
  832|  4.65k|   if (png_ptr_ptr != NULL)
  ------------------
  |  Branch (832:8): [True: 4.65k, False: 0]
  ------------------
  833|  4.65k|      png_ptr = *png_ptr_ptr;
  834|       |
  835|  4.65k|   if (png_ptr == NULL)
  ------------------
  |  Branch (835:8): [True: 2.05k, False: 2.60k]
  ------------------
  836|  2.05k|      return;
  837|       |
  838|       |   /* libpng 1.6.0: use the API to destroy info structs to ensure consistent
  839|       |    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
  840|       |    * The extra was, apparently, unnecessary yet this hides memory leak bugs.
  841|       |    */
  842|  2.60k|   png_destroy_info_struct(png_ptr, end_info_ptr_ptr);
  ------------------
  |  |  249|  2.60k|#define png_destroy_info_struct OSS_FUZZ_png_destroy_info_struct
  ------------------
  843|  2.60k|   png_destroy_info_struct(png_ptr, info_ptr_ptr);
  ------------------
  |  |  249|  2.60k|#define png_destroy_info_struct OSS_FUZZ_png_destroy_info_struct
  ------------------
  844|       |
  845|  2.60k|   *png_ptr_ptr = NULL;
  846|  2.60k|   png_read_destroy(png_ptr);
  847|  2.60k|   png_destroy_png_struct(png_ptr);
  ------------------
  |  |   12|  2.60k|#define png_destroy_png_struct OSS_FUZZ_png_destroy_png_struct
  ------------------
  848|  2.60k|}
OSS_FUZZ_png_image_begin_read_from_memory:
 1431|    548|{
 1432|    548|   if (image != NULL && image->version == PNG_IMAGE_VERSION)
  ------------------
  |  | 2773|    548|#define PNG_IMAGE_VERSION 1
  ------------------
  |  Branch (1432:8): [True: 548, False: 0]
  |  Branch (1432:25): [True: 548, False: 0]
  ------------------
 1433|    548|   {
 1434|    548|      if (memory != NULL && size > 0)
  ------------------
  |  Branch (1434:11): [True: 548, False: 0]
  |  Branch (1434:29): [True: 548, False: 0]
  ------------------
 1435|    548|      {
 1436|    548|         if (png_image_read_init(image) != 0)
  ------------------
  |  Branch (1436:14): [True: 548, False: 0]
  ------------------
 1437|    548|         {
 1438|       |            /* Now set the IO functions to read from the memory buffer and
 1439|       |             * store it into io_ptr.  Again do this in-place to avoid calling a
 1440|       |             * libpng function that requires error handling.
 1441|       |             */
 1442|    548|            image->opaque->memory = png_voidcast(png_const_bytep, memory);
  ------------------
  |  |  511|    548|#  define png_voidcast(type, value) (value)
  ------------------
 1443|    548|            image->opaque->size = size;
 1444|    548|            image->opaque->png_ptr->io_ptr = image;
 1445|    548|            image->opaque->png_ptr->read_data_fn = png_image_memory_read;
 1446|       |
 1447|    548|            return png_safe_execute(image, png_image_read_header, image);
  ------------------
  |  |  103|    548|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
 1448|    548|         }
 1449|    548|      }
 1450|       |
 1451|      0|      else
 1452|      0|         return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 1453|      0|             "png_image_begin_read_from_memory: invalid argument");
 1454|    548|   }
 1455|       |
 1456|      0|   else if (image != NULL)
  ------------------
  |  Branch (1456:13): [True: 0, False: 0]
  ------------------
 1457|      0|      return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 1458|      0|          "png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION");
 1459|       |
 1460|      0|   return 0;
 1461|    548|}
OSS_FUZZ_png_image_finish_read:
 3977|    537|{
 3978|    537|   if (image != NULL && image->version == PNG_IMAGE_VERSION)
  ------------------
  |  | 2773|    537|#define PNG_IMAGE_VERSION 1
  ------------------
  |  Branch (3978:8): [True: 537, False: 0]
  |  Branch (3978:25): [True: 537, False: 0]
  ------------------
 3979|    537|   {
 3980|       |      /* Check for row_stride overflow.  This check is not performed on the
 3981|       |       * original PNG format because it may not occur in the output PNG format
 3982|       |       * and libpng deals with the issues of reading the original.
 3983|       |       */
 3984|    537|      unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);
  ------------------
  |  | 2987|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
  |  |  ------------------
  |  |  |  | 2984|    537|   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  |  |  |  |  ------------------
  |  |  |  |                  (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2987|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2951|    537|   (((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2883|    537|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |                  (((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2882|    537|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2984:5): [True: 0, False: 537]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3985|       |
 3986|       |      /* The following checks just the 'row_stride' calculation to ensure it
 3987|       |       * fits in a signed 32-bit value.  Because channels/components can be
 3988|       |       * either 1 or 2 bytes in size the length of a row can still overflow 32
 3989|       |       * bits; this is just to verify that the 'row_stride' argument can be
 3990|       |       * represented.
 3991|       |       */
 3992|    537|      if (image->width <= 0x7fffffffU/channels) /* no overflow */
  ------------------
  |  Branch (3992:11): [True: 537, False: 0]
  ------------------
 3993|    537|      {
 3994|    537|         png_uint_32 check;
 3995|    537|         png_uint_32 png_row_stride = image->width * channels;
 3996|       |
 3997|    537|         if (row_stride == 0)
  ------------------
  |  Branch (3997:14): [True: 537, False: 0]
  ------------------
 3998|    537|            row_stride = (png_int_32)/*SAFE*/png_row_stride;
 3999|       |
 4000|    537|         if (row_stride < 0)
  ------------------
  |  Branch (4000:14): [True: 0, False: 537]
  ------------------
 4001|      0|            check = (png_uint_32)(-row_stride);
 4002|       |
 4003|    537|         else
 4004|    537|            check = (png_uint_32)row_stride;
 4005|       |
 4006|       |         /* This verifies 'check', the absolute value of the actual stride
 4007|       |          * passed in and detects overflow in the application calculation (i.e.
 4008|       |          * if the app did actually pass in a non-zero 'row_stride'.
 4009|       |          */
 4010|    537|         if (image->opaque != NULL && buffer != NULL && check >= png_row_stride)
  ------------------
  |  Branch (4010:14): [True: 537, False: 0]
  |  Branch (4010:39): [True: 537, False: 0]
  |  Branch (4010:57): [True: 537, False: 0]
  ------------------
 4011|    537|         {
 4012|       |            /* Now check for overflow of the image buffer calculation; this
 4013|       |             * limits the whole image size to 32 bits for API compatibility with
 4014|       |             * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
 4015|       |             *
 4016|       |             * The PNG_IMAGE_BUFFER_SIZE macro is:
 4017|       |             *
 4018|       |             *    (PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)*height*(row_stride))
 4019|       |             *
 4020|       |             * And the component size is always 1 or 2, so make sure that the
 4021|       |             * number of *bytes* that the application is saying are available
 4022|       |             * does actually fit into a 32-bit number.
 4023|       |             *
 4024|       |             * NOTE: this will be changed in 1.7 because PNG_IMAGE_BUFFER_SIZE
 4025|       |             * will be changed to use png_alloc_size_t; bigger images can be
 4026|       |             * accommodated on 64-bit systems.
 4027|       |             */
 4028|    537|            if (image->height <=
  ------------------
  |  Branch (4028:17): [True: 537, False: 0]
  ------------------
 4029|    537|                0xffffffffU/PNG_IMAGE_PIXEL_COMPONENT_SIZE(image->format)/check)
  ------------------
  |  | 2993|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
  |  |  ------------------
  |  |  |  | 2984|    537|   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  |  |  |  |  ------------------
  |  |  |  |                  (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2993|    537|   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2955|    537|   ((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2884|    537|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2984:5): [True: 0, False: 537]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4030|    537|            {
 4031|    537|               if ((image->format & PNG_FORMAT_FLAG_COLORMAP) == 0 ||
  ------------------
  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  ------------------
  |  Branch (4031:20): [True: 537, False: 0]
  ------------------
 4032|    537|                  (image->colormap_entries > 0 && colormap != NULL))
  ------------------
  |  Branch (4032:20): [True: 0, False: 0]
  |  Branch (4032:51): [True: 0, False: 0]
  ------------------
 4033|    537|               {
 4034|    537|                  int result;
 4035|    537|                  png_image_read_control display;
 4036|       |
 4037|    537|                  memset(&display, 0, (sizeof display));
 4038|    537|                  display.image = image;
 4039|    537|                  display.buffer = buffer;
 4040|    537|                  display.row_stride = row_stride;
 4041|    537|                  display.colormap = colormap;
 4042|    537|                  display.background = background;
 4043|    537|                  display.local_row = NULL;
 4044|       |
 4045|       |                  /* Choose the correct 'end' routine; for the color-map case
 4046|       |                   * all the setup has already been done.
 4047|       |                   */
 4048|    537|                  if ((image->format & PNG_FORMAT_FLAG_COLORMAP) != 0)
  ------------------
  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  ------------------
  |  Branch (4048:23): [True: 0, False: 537]
  ------------------
 4049|      0|                     result =
 4050|      0|                         png_safe_execute(image,
  ------------------
  |  |  103|      0|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
  |  Branch (4050:26): [True: 0, False: 0]
  ------------------
 4051|      0|                             png_image_read_colormap, &display) &&
 4052|      0|                             png_safe_execute(image,
  ------------------
  |  |  103|      0|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
  |  Branch (4052:30): [True: 0, False: 0]
  ------------------
 4053|      0|                             png_image_read_colormapped, &display);
 4054|       |
 4055|    537|                  else
 4056|    537|                     result =
 4057|    537|                        png_safe_execute(image,
  ------------------
  |  |  103|    537|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
 4058|    537|                            png_image_read_direct, &display);
 4059|       |
 4060|    537|                  png_image_free(image);
  ------------------
  |  |  344|    537|#define png_image_free OSS_FUZZ_png_image_free
  ------------------
 4061|    537|                  return result;
 4062|    537|               }
 4063|       |
 4064|      0|               else
 4065|      0|                  return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 4066|      0|                      "png_image_finish_read[color-map]: no color-map");
 4067|    537|            }
 4068|       |
 4069|      0|            else
 4070|      0|               return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 4071|      0|                   "png_image_finish_read: image too large");
 4072|    537|         }
 4073|       |
 4074|      0|         else
 4075|      0|            return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 4076|      0|                "png_image_finish_read: invalid argument");
 4077|    537|      }
 4078|       |
 4079|      0|      else
 4080|      0|         return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 4081|      0|             "png_image_finish_read: row_stride too large");
 4082|    537|   }
 4083|       |
 4084|      0|   else if (image != NULL)
  ------------------
  |  Branch (4084:13): [True: 0, False: 0]
  ------------------
 4085|      0|      return png_image_error(image,
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 4086|      0|          "png_image_finish_read: damaged PNG_IMAGE_VERSION");
 4087|       |
 4088|      0|   return 0;
 4089|    537|}
pngread.c:png_read_destroy:
  755|  2.60k|{
  756|  2.60k|   png_debug(1, "in png_read_destroy");
  ------------------
  |  |  148|  2.60k|#  define png_debug(l, m) ((void)0)
  ------------------
  757|       |
  758|  2.60k|#ifdef PNG_READ_GAMMA_SUPPORTED
  759|  2.60k|   png_destroy_gamma_table(png_ptr);
  ------------------
  |  |   96|  2.60k|#define png_destroy_gamma_table OSS_FUZZ_png_destroy_gamma_table
  ------------------
  760|  2.60k|#endif
  761|       |
  762|  2.60k|   png_free(png_ptr, png_ptr->big_row_buf);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  763|  2.60k|   png_ptr->big_row_buf = NULL;
  764|  2.60k|   png_free(png_ptr, png_ptr->big_prev_row);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  765|  2.60k|   png_ptr->big_prev_row = NULL;
  766|  2.60k|   png_free(png_ptr, png_ptr->read_buffer);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  767|  2.60k|   png_ptr->read_buffer = NULL;
  768|       |
  769|  2.60k|#ifdef PNG_READ_QUANTIZE_SUPPORTED
  770|  2.60k|   png_free(png_ptr, png_ptr->palette_lookup);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  771|  2.60k|   png_ptr->palette_lookup = NULL;
  772|  2.60k|   png_free(png_ptr, png_ptr->quantize_index);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  773|  2.60k|   png_ptr->quantize_index = NULL;
  774|  2.60k|#endif
  775|       |
  776|  2.60k|   if ((png_ptr->free_me & PNG_FREE_PLTE) != 0)
  ------------------
  |  | 1768|  2.60k|#define PNG_FREE_PLTE 0x1000U
  ------------------
  |  Branch (776:8): [True: 0, False: 2.60k]
  ------------------
  777|      0|   {
  778|      0|      png_zfree(png_ptr, png_ptr->palette);
  ------------------
  |  |   15|      0|#define png_zfree OSS_FUZZ_png_zfree
  ------------------
  779|      0|      png_ptr->palette = NULL;
  780|      0|   }
  781|  2.60k|   png_ptr->free_me &= ~PNG_FREE_PLTE;
  ------------------
  |  | 1768|  2.60k|#define PNG_FREE_PLTE 0x1000U
  ------------------
  782|       |
  783|  2.60k|#if defined(PNG_tRNS_SUPPORTED) || \
  784|  2.60k|    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
  785|  2.60k|   if ((png_ptr->free_me & PNG_FREE_TRNS) != 0)
  ------------------
  |  | 1769|  2.60k|#define PNG_FREE_TRNS 0x2000U
  ------------------
  |  Branch (785:8): [True: 0, False: 2.60k]
  ------------------
  786|      0|   {
  787|      0|      png_free(png_ptr, png_ptr->trans_alpha);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  788|      0|      png_ptr->trans_alpha = NULL;
  789|      0|   }
  790|  2.60k|   png_ptr->free_me &= ~PNG_FREE_TRNS;
  ------------------
  |  | 1769|  2.60k|#define PNG_FREE_TRNS 0x2000U
  ------------------
  791|  2.60k|#endif
  792|       |
  793|  2.60k|   inflateEnd(&png_ptr->zstream);
  794|       |
  795|  2.60k|#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
  796|  2.60k|   png_free(png_ptr, png_ptr->save_buffer);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  797|  2.60k|   png_ptr->save_buffer = NULL;
  798|  2.60k|#endif
  799|       |
  800|  2.60k|#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) && \
  801|  2.60k|   defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
  802|  2.60k|   png_free(png_ptr, png_ptr->unknown_chunk.data);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  803|  2.60k|   png_ptr->unknown_chunk.data = NULL;
  804|  2.60k|#endif
  805|       |
  806|  2.60k|#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
  807|  2.60k|   png_free(png_ptr, png_ptr->chunk_list);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  808|  2.60k|   png_ptr->chunk_list = NULL;
  809|  2.60k|#endif
  810|       |
  811|  2.60k|#if defined(PNG_READ_EXPAND_SUPPORTED) && \
  812|  2.60k|    defined(PNG_ARM_NEON_IMPLEMENTATION)
  813|  2.60k|   png_free(png_ptr, png_ptr->riffled_palette);
  ------------------
  |  |  253|  2.60k|#define png_free OSS_FUZZ_png_free
  ------------------
  814|  2.60k|   png_ptr->riffled_palette = NULL;
  815|  2.60k|#endif
  816|       |
  817|       |   /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
  818|       |    * callbacks are still set at this point.  They are required to complete the
  819|       |    * destruction of the png_struct itself.
  820|       |    */
  821|  2.60k|}
pngread.c:png_image_read_init:
 1123|    548|{
 1124|    548|   if (image->opaque == NULL)
  ------------------
  |  Branch (1124:8): [True: 548, False: 0]
  ------------------
 1125|    548|   {
 1126|    548|      png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
  ------------------
  |  |  244|    548|#define png_create_read_struct OSS_FUZZ_png_create_read_struct
  ------------------
                    png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
  ------------------
  |  |  277|    548|#define PNG_LIBPNG_VER_STRING "1.6.48.git"
  ------------------
 1127|    548|          png_safe_error, png_safe_warning);
  ------------------
  |  |  101|    548|#define png_safe_error OSS_FUZZ_png_safe_error
  ------------------
                        png_safe_error, png_safe_warning);
  ------------------
  |  |  102|    548|#define png_safe_warning OSS_FUZZ_png_safe_warning
  ------------------
 1128|       |
 1129|       |      /* And set the rest of the structure to NULL to ensure that the various
 1130|       |       * fields are consistent.
 1131|       |       */
 1132|    548|      memset(image, 0, (sizeof *image));
 1133|    548|      image->version = PNG_IMAGE_VERSION;
  ------------------
  |  | 2773|    548|#define PNG_IMAGE_VERSION 1
  ------------------
 1134|       |
 1135|    548|      if (png_ptr != NULL)
  ------------------
  |  Branch (1135:11): [True: 548, False: 0]
  ------------------
 1136|    548|      {
 1137|    548|         png_infop info_ptr = png_create_info_struct(png_ptr);
  ------------------
  |  |  243|    548|#define png_create_info_struct OSS_FUZZ_png_create_info_struct
  ------------------
 1138|       |
 1139|    548|         if (info_ptr != NULL)
  ------------------
  |  Branch (1139:14): [True: 548, False: 0]
  ------------------
 1140|    548|         {
 1141|    548|            png_controlp control = png_voidcast(png_controlp,
  ------------------
  |  |  511|    548|#  define png_voidcast(type, value) (value)
  ------------------
 1142|    548|                png_malloc_warn(png_ptr, (sizeof *control)));
 1143|       |
 1144|    548|            if (control != NULL)
  ------------------
  |  Branch (1144:17): [True: 548, False: 0]
  ------------------
 1145|    548|            {
 1146|    548|               memset(control, 0, (sizeof *control));
 1147|       |
 1148|    548|               control->png_ptr = png_ptr;
 1149|    548|               control->info_ptr = info_ptr;
 1150|    548|               control->for_write = 0;
 1151|       |
 1152|    548|               image->opaque = control;
 1153|    548|               return 1;
 1154|    548|            }
 1155|       |
 1156|       |            /* Error clean up */
 1157|      0|            png_destroy_info_struct(png_ptr, &info_ptr);
  ------------------
  |  |  249|      0|#define png_destroy_info_struct OSS_FUZZ_png_destroy_info_struct
  ------------------
 1158|      0|         }
 1159|       |
 1160|      0|         png_destroy_read_struct(&png_ptr, NULL, NULL);
  ------------------
  |  |  250|      0|#define png_destroy_read_struct OSS_FUZZ_png_destroy_read_struct
  ------------------
 1161|      0|      }
 1162|       |
 1163|      0|      return png_image_error(image, "png_image_read: out of memory");
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 1164|    548|   }
 1165|       |
 1166|      0|   return png_image_error(image, "png_image_read: opaque pointer not NULL");
  ------------------
  |  |  104|      0|#define png_image_error OSS_FUZZ_png_image_error
  ------------------
 1167|    548|}
pngread.c:png_image_memory_read:
 1401|  37.9k|{
 1402|  37.9k|   if (png_ptr != NULL)
  ------------------
  |  Branch (1402:8): [True: 37.9k, False: 0]
  ------------------
 1403|  37.9k|   {
 1404|  37.9k|      png_imagep image = png_voidcast(png_imagep, png_ptr->io_ptr);
  ------------------
  |  |  511|  37.9k|#  define png_voidcast(type, value) (value)
  ------------------
 1405|  37.9k|      if (image != NULL)
  ------------------
  |  Branch (1405:11): [True: 37.9k, False: 0]
  ------------------
 1406|  37.9k|      {
 1407|  37.9k|         png_controlp cp = image->opaque;
 1408|  37.9k|         if (cp != NULL)
  ------------------
  |  Branch (1408:14): [True: 37.9k, False: 0]
  ------------------
 1409|  37.9k|         {
 1410|  37.9k|            png_const_bytep memory = cp->memory;
 1411|  37.9k|            size_t size = cp->size;
 1412|       |
 1413|  37.9k|            if (memory != NULL && size >= need)
  ------------------
  |  Branch (1413:17): [True: 37.9k, False: 0]
  |  Branch (1413:35): [True: 37.9k, False: 0]
  ------------------
 1414|  37.9k|            {
 1415|  37.9k|               memcpy(out, memory, need);
 1416|  37.9k|               cp->memory = memory + need;
 1417|  37.9k|               cp->size = size - need;
 1418|  37.9k|               return;
 1419|  37.9k|            }
 1420|       |
 1421|      0|            png_error(png_ptr, "read beyond end of data");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 1422|  37.9k|         }
 1423|  37.9k|      }
 1424|       |
 1425|      0|      png_error(png_ptr, "invalid memory read");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 1426|  37.9k|   }
 1427|  37.9k|}
pngread.c:png_image_read_header:
 1271|    548|{
 1272|    548|   png_imagep image = png_voidcast(png_imagep, argument);
  ------------------
  |  |  511|    548|#  define png_voidcast(type, value) (value)
  ------------------
 1273|    548|   png_structrp png_ptr = image->opaque->png_ptr;
 1274|    548|   png_inforp info_ptr = image->opaque->info_ptr;
 1275|       |
 1276|    548|#ifdef PNG_BENIGN_ERRORS_SUPPORTED
 1277|    548|   png_set_benign_errors(png_ptr, 1/*warn*/);
  ------------------
  |  |  371|    548|#define png_set_benign_errors OSS_FUZZ_png_set_benign_errors
  ------------------
 1278|    548|#endif
 1279|    548|   png_read_info(png_ptr, info_ptr);
  ------------------
  |  |  357|    548|#define png_read_info OSS_FUZZ_png_read_info
  ------------------
 1280|       |
 1281|       |   /* Do this the fast way; just read directly out of png_struct. */
 1282|    548|   image->width = png_ptr->width;
 1283|    548|   image->height = png_ptr->height;
 1284|       |
 1285|    548|   {
 1286|    548|      png_uint_32 format = png_image_format(png_ptr);
 1287|       |
 1288|    548|      image->format = format;
 1289|       |
 1290|       |      /* Greyscale images don't (typically) have colour space information and
 1291|       |       * using it is pretty much impossible, so use sRGB for grayscale (it
 1292|       |       * doesn't matter r==g==b so the transform is irrelevant.)
 1293|       |       */
 1294|    548|      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 &&
  ------------------
  |  | 2883|    548|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
  |  Branch (1294:11): [True: 259, False: 289]
  ------------------
 1295|    548|          png_image_is_not_sRGB(png_ptr))
  ------------------
  |  Branch (1295:11): [True: 45, False: 214]
  ------------------
 1296|     45|         image->flags |= PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB;
  ------------------
  |  | 3042|     45|#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
  ------------------
 1297|    548|   }
 1298|       |
 1299|       |   /* We need the maximum number of entries regardless of the format the
 1300|       |    * application sets here.
 1301|       |    */
 1302|    548|   {
 1303|    548|      png_uint_32 cmap_entries;
 1304|       |
 1305|    548|      switch (png_ptr->color_type)
 1306|    548|      {
 1307|    265|         case PNG_COLOR_TYPE_GRAY:
  ------------------
  |  |  666|    265|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (1307:10): [True: 265, False: 283]
  ------------------
 1308|    265|            cmap_entries = 1U << png_ptr->bit_depth;
 1309|    265|            break;
 1310|       |
 1311|     97|         case PNG_COLOR_TYPE_PALETTE:
  ------------------
  |  |  667|     97|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|     97|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|     97|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1311:10): [True: 97, False: 451]
  ------------------
 1312|     97|            cmap_entries = (png_uint_32)png_ptr->num_palette;
 1313|     97|            break;
 1314|       |
 1315|    175|         default:
  ------------------
  |  Branch (1315:10): [True: 175, False: 373]
  ------------------
 1316|    175|            cmap_entries = 256;
 1317|    175|            break;
 1318|    548|      }
 1319|       |
 1320|    537|      if (cmap_entries > 256)
  ------------------
  |  Branch (1320:11): [True: 20, False: 517]
  ------------------
 1321|     20|         cmap_entries = 256;
 1322|       |
 1323|    537|      image->colormap_entries = cmap_entries;
 1324|    537|   }
 1325|       |
 1326|      0|   return 1;
 1327|    548|}
pngread.c:png_image_format:
 1172|  1.07k|{
 1173|  1.07k|   png_uint_32 format = 0;
 1174|       |
 1175|  1.07k|   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|  1.07k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1175:8): [True: 518, False: 556]
  ------------------
 1176|    518|      format |= PNG_FORMAT_FLAG_COLOR;
  ------------------
  |  | 2883|    518|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
 1177|       |
 1178|  1.07k|   if ((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
  ------------------
  |  |  663|  1.07k|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (1178:8): [True: 254, False: 820]
  ------------------
 1179|    254|      format |= PNG_FORMAT_FLAG_ALPHA;
  ------------------
  |  | 2882|    254|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
 1180|       |
 1181|       |   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
 1182|       |    * sets the png_struct fields; that's all we are interested in here.  The
 1183|       |    * precise interaction with an app call to png_set_tRNS and PNG file reading
 1184|       |    * is unclear.
 1185|       |    */
 1186|    820|   else if (png_ptr->num_trans > 0)
  ------------------
  |  Branch (1186:13): [True: 284, False: 536]
  ------------------
 1187|    284|      format |= PNG_FORMAT_FLAG_ALPHA;
  ------------------
  |  | 2882|    284|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
 1188|       |
 1189|  1.07k|   if (png_ptr->bit_depth == 16)
  ------------------
  |  Branch (1189:8): [True: 104, False: 970]
  ------------------
 1190|    104|      format |= PNG_FORMAT_FLAG_LINEAR;
  ------------------
  |  | 2884|    104|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
 1191|       |
 1192|  1.07k|   if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE) != 0)
  ------------------
  |  |  661|  1.07k|#define PNG_COLOR_MASK_PALETTE    1
  ------------------
  |  Branch (1192:8): [True: 194, False: 880]
  ------------------
 1193|    194|      format |= PNG_FORMAT_FLAG_COLORMAP;
  ------------------
  |  | 2885|    194|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  ------------------
 1194|       |
 1195|  1.07k|   return format;
 1196|  1.07k|}
pngread.c:png_image_is_not_sRGB:
 1244|    259|{
 1245|       |   /* Does the colorspace **not** match sRGB?  The flag is only set if the
 1246|       |    * answer can be determined reliably.
 1247|       |    *
 1248|       |    * png_struct::chromaticities always exists since the simplified API
 1249|       |    * requires rgb-to-gray.  The mDCV, cICP and cHRM chunks may all set it to
 1250|       |    * a non-sRGB value, so it needs to be checked but **only** if one of
 1251|       |    * those chunks occured in the file.
 1252|       |    */
 1253|       |   /* Highest priority: check to be safe. */
 1254|    259|   if (png_has_chunk(png_ptr, cICP) || png_has_chunk(png_ptr, mDCV))
  ------------------
  |  |  194|    259|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    518|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    259|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 45, False: 214]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                 if (png_has_chunk(png_ptr, cICP) || png_has_chunk(png_ptr, mDCV))
  ------------------
  |  |  194|    214|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    214|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    214|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 5, False: 209]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1255|     50|      return !chromaticities_match_sRGB(&png_ptr->chromaticities);
 1256|       |
 1257|       |   /* If the image is marked as sRGB then it is... */
 1258|    209|   if (png_has_chunk(png_ptr, sRGB))
  ------------------
  |  |  194|    209|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    209|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    209|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 30, False: 179]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1259|     30|      return 0;
 1260|       |
 1261|       |   /* Last stop: cHRM, must check: */
 1262|    179|   if (png_has_chunk(png_ptr, cHRM))
  ------------------
  |  |  194|    179|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    179|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    179|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 32, False: 147]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1263|     32|      return !chromaticities_match_sRGB(&png_ptr->chromaticities);
 1264|       |
 1265|       |   /* Else default to sRGB */
 1266|    147|   return 0;
 1267|    179|}
pngread.c:chromaticities_match_sRGB:
 1200|     82|{
 1201|     82|#  define sRGB_TOLERANCE 1000
 1202|     82|   static const png_xy sRGB_xy = /* From ITU-R BT.709-3 */
 1203|     82|   {
 1204|       |      /* color      x       y */
 1205|     82|      /* red   */ 64000, 33000,
 1206|     82|      /* green */ 30000, 60000,
 1207|     82|      /* blue  */ 15000,  6000,
 1208|     82|      /* white */ 31270, 32900
 1209|     82|   };
 1210|       |
 1211|     82|   if (PNG_OUT_OF_RANGE(xy->whitex, sRGB_xy.whitex,sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    164|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 45, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1212|     82|       PNG_OUT_OF_RANGE(xy->whitey, sRGB_xy.whitey,sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1213|     82|       PNG_OUT_OF_RANGE(xy->redx,   sRGB_xy.redx,  sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1214|     82|       PNG_OUT_OF_RANGE(xy->redy,   sRGB_xy.redy,  sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1215|     82|       PNG_OUT_OF_RANGE(xy->greenx, sRGB_xy.greenx,sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1216|     82|       PNG_OUT_OF_RANGE(xy->greeny, sRGB_xy.greeny,sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1217|     82|       PNG_OUT_OF_RANGE(xy->bluex,  sRGB_xy.bluex, sRGB_TOLERANCE) ||
  ------------------
  |  |  759|    119|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1218|     82|       PNG_OUT_OF_RANGE(xy->bluey,  sRGB_xy.bluey, sRGB_TOLERANCE))
  ------------------
  |  |  759|     37|   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )
  |  |  ------------------
  |  |  |  Branch (759:6): [True: 0, False: 37]
  |  |  |  Branch (759:35): [True: 0, False: 37]
  |  |  ------------------
  ------------------
 1219|     45|      return 0;
 1220|     37|   return 1;
 1221|     82|}
pngread.c:png_image_skip_unused_chunks:
 1469|    537|{
 1470|       |   /* Prepare the reader to ignore all recognized chunks whose data will not
 1471|       |    * be used, i.e., all chunks recognized by libpng except for those
 1472|       |    * involved in basic image reading:
 1473|       |    *
 1474|       |    *    IHDR, PLTE, IDAT, IEND
 1475|       |    *
 1476|       |    * Or image data handling:
 1477|       |    *
 1478|       |    *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.
 1479|       |    *
 1480|       |    * This provides a small performance improvement and eliminates any
 1481|       |    * potential vulnerability to security problems in the unused chunks.
 1482|       |    *
 1483|       |    * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored
 1484|       |    * too.  This allows the simplified API to be compiled without iCCP support.
 1485|       |    */
 1486|    537|   {
 1487|    537|         static const png_byte chunks_to_process[] = {
 1488|    537|            98,  75,  71,  68, '\0',  /* bKGD */
 1489|    537|            99,  72,  82,  77, '\0',  /* cHRM */
 1490|    537|            99,  73,  67,  80, '\0',  /* cICP */
 1491|    537|           103,  65,  77,  65, '\0',  /* gAMA */
 1492|    537|           109,  68,  67,  86, '\0',  /* mDCV */
 1493|    537|           115,  66,  73,  84, '\0',  /* sBIT */
 1494|    537|           115,  82,  71,  66, '\0',  /* sRGB */
 1495|    537|         };
 1496|       |
 1497|       |       /* Ignore unknown chunks and all other chunks except for the
 1498|       |        * IHDR, PLTE, tRNS, IDAT, and IEND chunks.
 1499|       |        */
 1500|    537|       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,
  ------------------
  |  |  403|    537|#define png_set_keep_unknown_chunks OSS_FUZZ_png_set_keep_unknown_chunks
  ------------------
                     png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,
  ------------------
  |  | 2450|    537|#define PNG_HANDLE_CHUNK_NEVER        1
  ------------------
 1501|    537|           NULL, -1);
 1502|       |
 1503|       |       /* But do not ignore image data handling chunks */
 1504|    537|       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,
  ------------------
  |  |  403|    537|#define png_set_keep_unknown_chunks OSS_FUZZ_png_set_keep_unknown_chunks
  ------------------
                     png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,
  ------------------
  |  | 2449|    537|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
 1505|    537|           chunks_to_process, (int)/*SAFE*/(sizeof chunks_to_process)/5);
 1506|    537|   }
 1507|    537|}
pngread.c:png_image_read_direct:
 3533|    537|{
 3534|    537|   png_image_read_control *display = png_voidcast(png_image_read_control*,
  ------------------
  |  |  511|    537|#  define png_voidcast(type, value) (value)
  ------------------
 3535|    537|       argument);
 3536|    537|   png_imagep image = display->image;
 3537|    537|   png_structrp png_ptr = image->opaque->png_ptr;
 3538|    537|   png_inforp info_ptr = image->opaque->info_ptr;
 3539|       |
 3540|    537|   png_uint_32 format = image->format;
 3541|    537|   int linear = (format & PNG_FORMAT_FLAG_LINEAR) != 0;
  ------------------
  |  | 2884|    537|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
 3542|    537|   int do_local_compose = 0;
 3543|    537|   int do_local_background = 0; /* to avoid double gamma correction bug */
 3544|    537|   int passes = 0;
 3545|       |
 3546|       |   /* Add transforms to ensure the correct output format is produced then check
 3547|       |    * that the required implementation support is there.  Always expand; always
 3548|       |    * need 8 bits minimum, no palette and expanded tRNS.
 3549|       |    */
 3550|    537|   png_set_expand(png_ptr);
  ------------------
  |  |  388|    537|#define png_set_expand OSS_FUZZ_png_set_expand
  ------------------
 3551|       |
 3552|       |   /* Now check the format to see if it was modified. */
 3553|    537|   {
 3554|    537|      png_uint_32 base_format = png_image_format(png_ptr) &
 3555|    537|         ~PNG_FORMAT_FLAG_COLORMAP /* removed by png_set_expand */;
  ------------------
  |  | 2885|    537|#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
  ------------------
 3556|    537|      png_uint_32 change = format ^ base_format;
 3557|    537|      png_fixed_point output_gamma;
 3558|    537|      int mode; /* alpha mode */
 3559|       |
 3560|       |      /* Do this first so that we have a record if rgb to gray is happening. */
 3561|    537|      if ((change & PNG_FORMAT_FLAG_COLOR) != 0)
  ------------------
  |  | 2883|    537|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
  |  Branch (3561:11): [True: 278, False: 259]
  ------------------
 3562|    278|      {
 3563|       |         /* gray<->color transformation required. */
 3564|    278|         if ((format & PNG_FORMAT_FLAG_COLOR) != 0)
  ------------------
  |  | 2883|    278|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
  |  Branch (3564:14): [True: 278, False: 0]
  ------------------
 3565|    278|            png_set_gray_to_rgb(png_ptr);
  ------------------
  |  |  396|    278|#define png_set_gray_to_rgb OSS_FUZZ_png_set_gray_to_rgb
  ------------------
 3566|       |
 3567|      0|         else
 3568|      0|         {
 3569|       |            /* libpng can't do both rgb to gray and
 3570|       |             * background/pre-multiplication if there is also significant gamma
 3571|       |             * correction, because both operations require linear colors and
 3572|       |             * the code only supports one transform doing the gamma correction.
 3573|       |             * Handle this by doing the pre-multiplication or background
 3574|       |             * operation in this code, if necessary.
 3575|       |             *
 3576|       |             * TODO: fix this by rewriting pngrtran.c (!)
 3577|       |             *
 3578|       |             * For the moment (given that fixing this in pngrtran.c is an
 3579|       |             * enormous change) 'do_local_background' is used to indicate that
 3580|       |             * the problem exists.
 3581|       |             */
 3582|      0|            if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|      0|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3582:17): [True: 0, False: 0]
  ------------------
 3583|      0|               do_local_background = 1/*maybe*/;
 3584|       |
 3585|      0|            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,
  ------------------
  |  |  422|      0|#define png_set_rgb_to_gray_fixed OSS_FUZZ_png_set_rgb_to_gray_fixed
  ------------------
                          png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,
  ------------------
  |  | 1089|      0|#define PNG_ERROR_ACTION_NONE  1
  ------------------
 3586|      0|                PNG_RGB_TO_GRAY_DEFAULT, PNG_RGB_TO_GRAY_DEFAULT);
  ------------------
  |  | 1092|      0|#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/
  ------------------
                              PNG_RGB_TO_GRAY_DEFAULT, PNG_RGB_TO_GRAY_DEFAULT);
  ------------------
  |  | 1092|      0|#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/
  ------------------
 3587|      0|         }
 3588|       |
 3589|    278|         change &= ~PNG_FORMAT_FLAG_COLOR;
  ------------------
  |  | 2883|    278|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
 3590|    278|      }
 3591|       |
 3592|       |      /* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.
 3593|       |       */
 3594|    537|      {
 3595|       |         /* This is safe but should no longer be necessary as
 3596|       |          * png_ptr->default_gamma should have been set after the
 3597|       |          * info-before-IDAT was read in png_image_read_header.
 3598|       |          *
 3599|       |          * TODO: 1.8: remove this and see what happens.
 3600|       |          */
 3601|    537|         png_fixed_point input_gamma_default;
 3602|       |
 3603|    537|         if ((base_format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
  ------------------
  |  | 2884|    537|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
  |  Branch (3603:14): [True: 52, False: 485]
  ------------------
 3604|    537|             (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)
  ------------------
  |  | 3058|     52|#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
  ------------------
  |  Branch (3604:14): [True: 52, False: 0]
  ------------------
 3605|     52|            input_gamma_default = PNG_GAMMA_LINEAR;
  ------------------
  |  | 1163|     52|#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
  |  |  ------------------
  |  |  |  |  654|     52|#define PNG_FP_1    100000
  |  |  ------------------
  ------------------
 3606|    485|         else
 3607|    485|            input_gamma_default = PNG_DEFAULT_sRGB;
  ------------------
  |  | 1160|    485|#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
  ------------------
 3608|       |
 3609|       |         /* Call png_set_alpha_mode to set the default for the input gamma; the
 3610|       |          * output gamma is set by a second call below.
 3611|       |          */
 3612|    537|         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);
  ------------------
  |  |  367|    537|#define png_set_alpha_mode_fixed OSS_FUZZ_png_set_alpha_mode_fixed
  ------------------
                       png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);
  ------------------
  |  | 1143|    537|#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
  ------------------
 3613|    537|      }
 3614|       |
 3615|    537|      if (linear != 0)
  ------------------
  |  Branch (3615:11): [True: 0, False: 537]
  ------------------
 3616|      0|      {
 3617|       |         /* If there *is* an alpha channel in the input it must be multiplied
 3618|       |          * out; use PNG_ALPHA_STANDARD, otherwise just use PNG_ALPHA_PNG.
 3619|       |          */
 3620|      0|         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|      0|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3620:14): [True: 0, False: 0]
  ------------------
 3621|      0|            mode = PNG_ALPHA_STANDARD; /* associated alpha */
  ------------------
  |  | 1144|      0|#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
  ------------------
 3622|       |
 3623|      0|         else
 3624|      0|            mode = PNG_ALPHA_PNG;
  ------------------
  |  | 1143|      0|#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
  ------------------
 3625|       |
 3626|      0|         output_gamma = PNG_GAMMA_LINEAR;
  ------------------
  |  | 1163|      0|#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
  |  |  ------------------
  |  |  |  |  654|      0|#define PNG_FP_1    100000
  |  |  ------------------
  ------------------
 3627|      0|      }
 3628|       |
 3629|    537|      else
 3630|    537|      {
 3631|    537|         mode = PNG_ALPHA_PNG;
  ------------------
  |  | 1143|    537|#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
  ------------------
 3632|    537|         output_gamma = PNG_DEFAULT_sRGB;
  ------------------
  |  | 1160|    537|#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
  ------------------
 3633|    537|      }
 3634|       |
 3635|    537|      if ((change & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0)
  ------------------
  |  | 2895|    537|#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
  ------------------
  |  Branch (3635:11): [True: 0, False: 537]
  ------------------
 3636|      0|      {
 3637|      0|         mode = PNG_ALPHA_OPTIMIZED;
  ------------------
  |  | 1147|      0|#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
  ------------------
 3638|      0|         change &= ~PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;
  ------------------
  |  | 2895|      0|#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
  ------------------
 3639|      0|      }
 3640|       |
 3641|       |      /* If 'do_local_background' is set check for the presence of gamma
 3642|       |       * correction; this is part of the work-round for the libpng bug
 3643|       |       * described above.
 3644|       |       *
 3645|       |       * TODO: fix libpng and remove this.
 3646|       |       */
 3647|    537|      if (do_local_background != 0)
  ------------------
  |  Branch (3647:11): [True: 0, False: 537]
  ------------------
 3648|      0|      {
 3649|      0|         png_fixed_point gtest;
 3650|       |
 3651|       |         /* This is 'png_gamma_threshold' from pngrtran.c; the test used for
 3652|       |          * gamma correction, the screen gamma hasn't been set on png_struct
 3653|       |          * yet; it's set below.  png_struct::gamma, however, is set to the
 3654|       |          * final value.
 3655|       |          */
 3656|      0|         if (png_muldiv(&gtest, output_gamma,
  ------------------
  |  |   88|      0|#define png_muldiv OSS_FUZZ_png_muldiv
  ------------------
  |  Branch (3656:14): [True: 0, False: 0]
  ------------------
 3657|      0|                  png_resolve_file_gamma(png_ptr), PNG_FP_1) != 0 &&
  ------------------
  |  |   92|      0|#define png_resolve_file_gamma OSS_FUZZ_png_resolve_file_gamma
  ------------------
                                png_resolve_file_gamma(png_ptr), PNG_FP_1) != 0 &&
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 3658|      0|             png_gamma_significant(gtest) == 0)
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (3658:14): [True: 0, False: 0]
  ------------------
 3659|      0|            do_local_background = 0;
 3660|       |
 3661|      0|         else if (mode == PNG_ALPHA_STANDARD)
  ------------------
  |  | 1144|      0|#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
  ------------------
  |  Branch (3661:19): [True: 0, False: 0]
  ------------------
 3662|      0|         {
 3663|      0|            do_local_background = 2/*required*/;
 3664|      0|            mode = PNG_ALPHA_PNG; /* prevent libpng doing it */
  ------------------
  |  | 1143|      0|#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
  ------------------
 3665|      0|         }
 3666|       |
 3667|       |         /* else leave as 1 for the checks below */
 3668|      0|      }
 3669|       |
 3670|       |      /* If the bit-depth changes then handle that here. */
 3671|    537|      if ((change & PNG_FORMAT_FLAG_LINEAR) != 0)
  ------------------
  |  | 2884|    537|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
  |  Branch (3671:11): [True: 52, False: 485]
  ------------------
 3672|     52|      {
 3673|     52|         if (linear != 0 /*16-bit output*/)
  ------------------
  |  Branch (3673:14): [True: 0, False: 52]
  ------------------
 3674|      0|            png_set_expand_16(png_ptr);
  ------------------
  |  |  389|      0|#define png_set_expand_16 OSS_FUZZ_png_set_expand_16
  ------------------
 3675|       |
 3676|     52|         else /* 8-bit output */
 3677|     52|            png_set_scale_16(png_ptr);
  ------------------
  |  |  431|     52|#define png_set_scale_16 OSS_FUZZ_png_set_scale_16
  ------------------
 3678|       |
 3679|     52|         change &= ~PNG_FORMAT_FLAG_LINEAR;
  ------------------
  |  | 2884|     52|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
 3680|     52|      }
 3681|       |
 3682|       |      /* Now the background/alpha channel changes. */
 3683|    537|      if ((change & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|    537|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3683:11): [True: 268, False: 269]
  ------------------
 3684|    268|      {
 3685|       |         /* Removing an alpha channel requires composition for the 8-bit
 3686|       |          * formats; for the 16-bit it is already done, above, by the
 3687|       |          * pre-multiplication and the channel just needs to be stripped.
 3688|       |          */
 3689|    268|         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|    268|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3689:14): [True: 0, False: 268]
  ------------------
 3690|      0|         {
 3691|       |            /* If RGB->gray is happening the alpha channel must be left and the
 3692|       |             * operation completed locally.
 3693|       |             *
 3694|       |             * TODO: fix libpng and remove this.
 3695|       |             */
 3696|      0|            if (do_local_background != 0)
  ------------------
  |  Branch (3696:17): [True: 0, False: 0]
  ------------------
 3697|      0|               do_local_background = 2/*required*/;
 3698|       |
 3699|       |            /* 16-bit output: just remove the channel */
 3700|      0|            else if (linear != 0) /* compose on black (well, pre-multiply) */
  ------------------
  |  Branch (3700:22): [True: 0, False: 0]
  ------------------
 3701|      0|               png_set_strip_alpha(png_ptr);
  ------------------
  |  |  435|      0|#define png_set_strip_alpha OSS_FUZZ_png_set_strip_alpha
  ------------------
 3702|       |
 3703|       |            /* 8-bit output: do an appropriate compose */
 3704|      0|            else if (display->background != NULL)
  ------------------
  |  Branch (3704:22): [True: 0, False: 0]
  ------------------
 3705|      0|            {
 3706|      0|               png_color_16 c;
 3707|       |
 3708|      0|               c.index = 0; /*unused*/
 3709|      0|               c.red = display->background->red;
 3710|      0|               c.green = display->background->green;
 3711|      0|               c.blue = display->background->blue;
 3712|      0|               c.gray = display->background->green;
 3713|       |
 3714|       |               /* This is always an 8-bit sRGB value, using the 'green' channel
 3715|       |                * for gray is much better than calculating the luminance here;
 3716|       |                * we can get off-by-one errors in that calculation relative to
 3717|       |                * the app expectations and that will show up in transparent
 3718|       |                * pixels.
 3719|       |                */
 3720|      0|               png_set_background_fixed(png_ptr, &c,
  ------------------
  |  |  370|      0|#define png_set_background_fixed OSS_FUZZ_png_set_background_fixed
  ------------------
 3721|      0|                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
  ------------------
  |  | 1321|      0|#  define PNG_BACKGROUND_GAMMA_SCREEN  1
  ------------------
 3722|      0|                   0/*gamma: not used*/);
 3723|      0|            }
 3724|       |
 3725|      0|            else /* compose on row: implemented below. */
 3726|      0|            {
 3727|      0|               do_local_compose = 1;
 3728|       |               /* This leaves the alpha channel in the output, so it has to be
 3729|       |                * removed by the code below.  Set the encoding to the 'OPTIMIZE'
 3730|       |                * one so the code only has to hack on the pixels that require
 3731|       |                * composition.
 3732|       |                */
 3733|      0|               mode = PNG_ALPHA_OPTIMIZED;
  ------------------
  |  | 1147|      0|#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
  ------------------
 3734|      0|            }
 3735|      0|         }
 3736|       |
 3737|    268|         else /* output needs an alpha channel */
 3738|    268|         {
 3739|       |            /* This is tricky because it happens before the swap operation has
 3740|       |             * been accomplished; however, the swap does *not* swap the added
 3741|       |             * alpha channel (weird API), so it must be added in the correct
 3742|       |             * place.
 3743|       |             */
 3744|    268|            png_uint_32 filler; /* opaque filler */
 3745|    268|            int where;
 3746|       |
 3747|    268|            if (linear != 0)
  ------------------
  |  Branch (3747:17): [True: 0, False: 268]
  ------------------
 3748|      0|               filler = 65535;
 3749|       |
 3750|    268|            else
 3751|    268|               filler = 255;
 3752|       |
 3753|    268|#ifdef PNG_FORMAT_AFIRST_SUPPORTED
 3754|    268|            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
  ------------------
  |  | 2892|    268|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
  |  Branch (3754:17): [True: 0, False: 268]
  ------------------
 3755|      0|            {
 3756|      0|               where = PNG_FILLER_BEFORE;
  ------------------
  |  | 1261|      0|#  define PNG_FILLER_BEFORE 0
  ------------------
 3757|      0|               change &= ~PNG_FORMAT_FLAG_AFIRST;
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
 3758|      0|            }
 3759|       |
 3760|    268|            else
 3761|    268|#endif
 3762|    268|            where = PNG_FILLER_AFTER;
  ------------------
  |  | 1262|    268|#  define PNG_FILLER_AFTER 1
  ------------------
 3763|       |
 3764|    268|            png_set_add_alpha(png_ptr, filler, where);
  ------------------
  |  |  365|    268|#define png_set_add_alpha OSS_FUZZ_png_set_add_alpha
  ------------------
 3765|    268|         }
 3766|       |
 3767|       |         /* This stops the (irrelevant) call to swap_alpha below. */
 3768|    268|         change &= ~PNG_FORMAT_FLAG_ALPHA;
  ------------------
  |  | 2882|    268|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
 3769|    268|      }
 3770|       |
 3771|       |      /* Now set the alpha mode correctly; this is always done, even if there is
 3772|       |       * no alpha channel in either the input or the output because it correctly
 3773|       |       * sets the output gamma.
 3774|       |       */
 3775|    537|      png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);
  ------------------
  |  |  367|    537|#define png_set_alpha_mode_fixed OSS_FUZZ_png_set_alpha_mode_fixed
  ------------------
 3776|       |
 3777|    537|#     ifdef PNG_FORMAT_BGR_SUPPORTED
 3778|    537|         if ((change & PNG_FORMAT_FLAG_BGR) != 0)
  ------------------
  |  | 2888|    537|#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
  ------------------
  |  Branch (3778:14): [True: 0, False: 537]
  ------------------
 3779|      0|         {
 3780|       |            /* Check only the output format; PNG is never BGR; don't do this if
 3781|       |             * the output is gray, but fix up the 'format' value in that case.
 3782|       |             */
 3783|      0|            if ((format & PNG_FORMAT_FLAG_COLOR) != 0)
  ------------------
  |  | 2883|      0|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
  |  Branch (3783:17): [True: 0, False: 0]
  ------------------
 3784|      0|               png_set_bgr(png_ptr);
  ------------------
  |  |  372|      0|#define png_set_bgr OSS_FUZZ_png_set_bgr
  ------------------
 3785|       |
 3786|      0|            else
 3787|      0|               format &= ~PNG_FORMAT_FLAG_BGR;
  ------------------
  |  | 2888|      0|#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
  ------------------
 3788|       |
 3789|      0|            change &= ~PNG_FORMAT_FLAG_BGR;
  ------------------
  |  | 2888|      0|#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
  ------------------
 3790|      0|         }
 3791|    537|#     endif
 3792|       |
 3793|    537|#     ifdef PNG_FORMAT_AFIRST_SUPPORTED
 3794|    537|         if ((change & PNG_FORMAT_FLAG_AFIRST) != 0)
  ------------------
  |  | 2892|    537|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
  |  Branch (3794:14): [True: 0, False: 537]
  ------------------
 3795|      0|         {
 3796|       |            /* Only relevant if there is an alpha channel - it's particularly
 3797|       |             * important to handle this correctly because do_local_compose may
 3798|       |             * be set above and then libpng will keep the alpha channel for this
 3799|       |             * code to remove.
 3800|       |             */
 3801|      0|            if ((format & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|      0|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3801:17): [True: 0, False: 0]
  ------------------
 3802|      0|            {
 3803|       |               /* Disable this if doing a local background,
 3804|       |                * TODO: remove this when local background is no longer required.
 3805|       |                */
 3806|      0|               if (do_local_background != 2)
  ------------------
  |  Branch (3806:20): [True: 0, False: 0]
  ------------------
 3807|      0|                  png_set_swap_alpha(png_ptr);
  ------------------
  |  |  437|      0|#define png_set_swap_alpha OSS_FUZZ_png_set_swap_alpha
  ------------------
 3808|      0|            }
 3809|       |
 3810|      0|            else
 3811|      0|               format &= ~PNG_FORMAT_FLAG_AFIRST;
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
 3812|       |
 3813|      0|            change &= ~PNG_FORMAT_FLAG_AFIRST;
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
 3814|      0|         }
 3815|    537|#     endif
 3816|       |
 3817|       |      /* If the *output* is 16-bit then we need to check for a byte-swap on this
 3818|       |       * architecture.
 3819|       |       */
 3820|    537|      if (linear != 0)
  ------------------
  |  Branch (3820:11): [True: 0, False: 537]
  ------------------
 3821|      0|      {
 3822|      0|         png_uint_16 le = 0x0001;
 3823|       |
 3824|      0|         if ((*(png_const_bytep) & le) != 0)
  ------------------
  |  Branch (3824:14): [True: 0, False: 0]
  ------------------
 3825|      0|            png_set_swap(png_ptr);
  ------------------
  |  |  436|      0|#define png_set_swap OSS_FUZZ_png_set_swap
  ------------------
 3826|      0|      }
 3827|       |
 3828|       |      /* If change is not now 0 some transformation is missing - error out. */
 3829|    537|      if (change != 0)
  ------------------
  |  Branch (3829:11): [True: 0, False: 537]
  ------------------
 3830|      0|         png_error(png_ptr, "png_read_image: unsupported transformation");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3831|    537|   }
 3832|       |
 3833|    537|   PNG_SKIP_CHUNKS(png_ptr);
  ------------------
  |  | 1509|    537|#  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
  ------------------
 3834|       |
 3835|       |   /* Update the 'info' structure and make sure the result is as required; first
 3836|       |    * make sure to turn on the interlace handling if it will be required
 3837|       |    * (because it can't be turned on *after* the call to png_read_update_info!)
 3838|       |    *
 3839|       |    * TODO: remove the do_local_background fixup below.
 3840|       |    */
 3841|    537|   if (do_local_compose == 0 && do_local_background != 2)
  ------------------
  |  Branch (3841:8): [True: 537, False: 0]
  |  Branch (3841:33): [True: 537, False: 0]
  ------------------
 3842|    537|      passes = png_set_interlace_handling(png_ptr);
  ------------------
  |  |  399|    537|#define png_set_interlace_handling OSS_FUZZ_png_set_interlace_handling
  ------------------
 3843|       |
 3844|    537|   png_read_update_info(png_ptr, info_ptr);
  ------------------
  |  |  361|    537|#define png_read_update_info OSS_FUZZ_png_read_update_info
  ------------------
 3845|       |
 3846|    537|   {
 3847|    537|      png_uint_32 info_format = 0;
 3848|       |
 3849|    537|      if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|    537|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (3849:11): [True: 537, False: 0]
  ------------------
 3850|    537|         info_format |= PNG_FORMAT_FLAG_COLOR;
  ------------------
  |  | 2883|    537|#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
  ------------------
 3851|       |
 3852|    537|      if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
  ------------------
  |  |  663|    537|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (3852:11): [True: 537, False: 0]
  ------------------
 3853|    537|      {
 3854|       |         /* do_local_compose removes this channel below. */
 3855|    537|         if (do_local_compose == 0)
  ------------------
  |  Branch (3855:14): [True: 537, False: 0]
  ------------------
 3856|    537|         {
 3857|       |            /* do_local_background does the same if required. */
 3858|    537|            if (do_local_background != 2 ||
  ------------------
  |  Branch (3858:17): [True: 537, False: 0]
  ------------------
 3859|    537|               (format & PNG_FORMAT_FLAG_ALPHA) != 0)
  ------------------
  |  | 2882|      0|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
  |  Branch (3859:16): [True: 0, False: 0]
  ------------------
 3860|    537|               info_format |= PNG_FORMAT_FLAG_ALPHA;
  ------------------
  |  | 2882|    537|#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
  ------------------
 3861|    537|         }
 3862|    537|      }
 3863|       |
 3864|      0|      else if (do_local_compose != 0) /* internal error */
  ------------------
  |  Branch (3864:16): [True: 0, False: 0]
  ------------------
 3865|      0|         png_error(png_ptr, "png_image_read: alpha channel lost");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3866|       |
 3867|    537|      if ((format & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0) {
  ------------------
  |  | 2895|    537|#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
  ------------------
  |  Branch (3867:11): [True: 0, False: 537]
  ------------------
 3868|      0|         info_format |= PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;
  ------------------
  |  | 2895|      0|#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
  ------------------
 3869|      0|      }
 3870|       |
 3871|    537|      if (info_ptr->bit_depth == 16)
  ------------------
  |  Branch (3871:11): [True: 0, False: 537]
  ------------------
 3872|      0|         info_format |= PNG_FORMAT_FLAG_LINEAR;
  ------------------
  |  | 2884|      0|#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
  ------------------
 3873|       |
 3874|    537|#ifdef PNG_FORMAT_BGR_SUPPORTED
 3875|    537|      if ((png_ptr->transformations & PNG_BGR) != 0)
  ------------------
  |  |  634|    537|#define PNG_BGR                 0x0001U
  ------------------
  |  Branch (3875:11): [True: 0, False: 537]
  ------------------
 3876|      0|         info_format |= PNG_FORMAT_FLAG_BGR;
  ------------------
  |  | 2888|      0|#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
  ------------------
 3877|    537|#endif
 3878|       |
 3879|    537|#ifdef PNG_FORMAT_AFIRST_SUPPORTED
 3880|    537|         if (do_local_background == 2)
  ------------------
  |  Branch (3880:14): [True: 0, False: 537]
  ------------------
 3881|      0|         {
 3882|      0|            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
  |  Branch (3882:17): [True: 0, False: 0]
  ------------------
 3883|      0|               info_format |= PNG_FORMAT_FLAG_AFIRST;
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
 3884|      0|         }
 3885|       |
 3886|    537|         if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0 ||
  ------------------
  |  |  651|    537|#define PNG_SWAP_ALPHA         0x20000U
  ------------------
  |  Branch (3886:14): [True: 0, False: 537]
  ------------------
 3887|    537|            ((png_ptr->transformations & PNG_ADD_ALPHA) != 0 &&
  ------------------
  |  |  659|    537|#define PNG_ADD_ALPHA        0x1000000U /* Added to libpng-1.2.7 */
  ------------------
  |  Branch (3887:14): [True: 268, False: 269]
  ------------------
 3888|    537|            (png_ptr->flags & PNG_FLAG_FILLER_AFTER) == 0))
  ------------------
  |  |  678|    268|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  |  Branch (3888:13): [True: 0, False: 268]
  ------------------
 3889|      0|         {
 3890|      0|            if (do_local_background == 2)
  ------------------
  |  Branch (3890:17): [True: 0, False: 0]
  ------------------
 3891|      0|               png_error(png_ptr, "unexpected alpha swap transformation");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3892|       |
 3893|      0|            info_format |= PNG_FORMAT_FLAG_AFIRST;
  ------------------
  |  | 2892|      0|#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
  ------------------
 3894|      0|         }
 3895|    537|#     endif
 3896|       |
 3897|       |      /* This is actually an internal error. */
 3898|    537|      if (info_format != format)
  ------------------
  |  Branch (3898:11): [True: 0, False: 537]
  ------------------
 3899|      0|         png_error(png_ptr, "png_read_image: invalid transformations");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3900|    537|   }
 3901|       |
 3902|       |   /* Now read the rows.  If do_local_compose is set then it is necessary to use
 3903|       |    * a local row buffer.  The output will be GA, RGBA or BGRA and must be
 3904|       |    * converted to G, RGB or BGR as appropriate.  The 'local_row' member of the
 3905|       |    * display acts as a flag.
 3906|       |    */
 3907|    537|   {
 3908|    537|      png_voidp first_row = display->buffer;
 3909|    537|      ptrdiff_t row_bytes = display->row_stride;
 3910|       |
 3911|    537|      if (linear != 0)
  ------------------
  |  Branch (3911:11): [True: 0, False: 537]
  ------------------
 3912|      0|         row_bytes *= 2;
 3913|       |
 3914|       |      /* The following expression is designed to work correctly whether it gives
 3915|       |       * a signed or an unsigned result.
 3916|       |       */
 3917|    537|      if (row_bytes < 0)
  ------------------
  |  Branch (3917:11): [True: 0, False: 537]
  ------------------
 3918|      0|      {
 3919|      0|         char *ptr = png_voidcast(char*, first_row);
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
 3920|      0|         ptr += (image->height-1) * (-row_bytes);
 3921|      0|         first_row = png_voidcast(png_voidp, ptr);
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
 3922|      0|      }
 3923|       |
 3924|    537|      display->first_row = first_row;
 3925|    537|      display->row_bytes = row_bytes;
 3926|    537|   }
 3927|       |
 3928|    537|   if (do_local_compose != 0)
  ------------------
  |  Branch (3928:8): [True: 0, False: 537]
  ------------------
 3929|      0|   {
 3930|      0|      int result;
 3931|      0|      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));
  ------------------
  |  |  347|      0|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
                    png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));
  ------------------
  |  |  308|      0|#define png_get_rowbytes OSS_FUZZ_png_get_rowbytes
  ------------------
 3932|       |
 3933|      0|      display->local_row = row;
 3934|      0|      result = png_safe_execute(image, png_image_read_composite, display);
  ------------------
  |  |  103|      0|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
 3935|      0|      display->local_row = NULL;
 3936|      0|      png_free(png_ptr, row);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3937|       |
 3938|      0|      return result;
 3939|      0|   }
 3940|       |
 3941|    537|   else if (do_local_background == 2)
  ------------------
  |  Branch (3941:13): [True: 0, False: 537]
  ------------------
 3942|      0|   {
 3943|      0|      int result;
 3944|      0|      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));
  ------------------
  |  |  347|      0|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
                    png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));
  ------------------
  |  |  308|      0|#define png_get_rowbytes OSS_FUZZ_png_get_rowbytes
  ------------------
 3945|       |
 3946|      0|      display->local_row = row;
 3947|      0|      result = png_safe_execute(image, png_image_read_background, display);
  ------------------
  |  |  103|      0|#define png_safe_execute OSS_FUZZ_png_safe_execute
  ------------------
 3948|      0|      display->local_row = NULL;
 3949|      0|      png_free(png_ptr, row);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 3950|       |
 3951|      0|      return result;
 3952|      0|   }
 3953|       |
 3954|    537|   else
 3955|    537|   {
 3956|    537|      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;
 3957|       |
 3958|  1.87k|      while (--passes >= 0)
  ------------------
  |  Branch (3958:14): [True: 1.34k, False: 537]
  ------------------
 3959|  1.34k|      {
 3960|  1.34k|         png_uint_32      y = image->height;
 3961|  1.34k|         png_bytep        row = png_voidcast(png_bytep, display->first_row);
  ------------------
  |  |  511|  1.34k|#  define png_voidcast(type, value) (value)
  ------------------
 3962|       |
 3963|  78.5k|         for (; y > 0; --y)
  ------------------
  |  Branch (3963:17): [True: 77.2k, False: 1.34k]
  ------------------
 3964|  77.2k|         {
 3965|  77.2k|            png_read_row(png_ptr, row, NULL);
  ------------------
  |  |  359|  77.2k|#define png_read_row OSS_FUZZ_png_read_row
  ------------------
 3966|  77.2k|            row += row_bytes;
 3967|  77.2k|         }
 3968|  1.34k|      }
 3969|       |
 3970|    537|      return 1;
 3971|    537|   }
 3972|    537|}

OSS_FUZZ_png_read_data:
   32|   165k|{
   33|   165k|   png_debug1(4, "reading %d bytes", (int)length);
  ------------------
  |  |  151|   165k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
   34|       |
   35|   165k|   if (png_ptr->read_data_fn != NULL)
  ------------------
  |  Branch (35:8): [True: 165k, False: 0]
  ------------------
   36|   165k|      (*(png_ptr->read_data_fn))(png_ptr, data, length);
   37|       |
   38|      0|   else
   39|      0|      png_error(png_ptr, "Call to NULL read function");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
   40|   165k|}
OSS_FUZZ_png_set_read_fn:
   88|  4.65k|{
   89|  4.65k|   if (png_ptr == NULL)
  ------------------
  |  Branch (89:8): [True: 0, False: 4.65k]
  ------------------
   90|      0|      return;
   91|       |
   92|  4.65k|   png_ptr->io_ptr = io_ptr;
   93|       |
   94|       |#ifdef PNG_STDIO_SUPPORTED
   95|       |   if (read_data_fn != NULL)
   96|       |      png_ptr->read_data_fn = read_data_fn;
   97|       |
   98|       |   else
   99|       |      png_ptr->read_data_fn = png_default_read_data;
  100|       |#else
  101|  4.65k|   png_ptr->read_data_fn = read_data_fn;
  102|  4.65k|#endif
  103|       |
  104|       |#ifdef PNG_WRITE_SUPPORTED
  105|       |   /* It is an error to write to a read device */
  106|       |   if (png_ptr->write_data_fn != NULL)
  107|       |   {
  108|       |      png_ptr->write_data_fn = NULL;
  109|       |      png_warning(png_ptr,
  110|       |          "Can't set both read_data_fn and write_data_fn in the"
  111|       |          " same structure");
  112|       |   }
  113|       |#endif
  114|       |
  115|       |#ifdef PNG_WRITE_FLUSH_SUPPORTED
  116|       |   png_ptr->output_flush_fn = NULL;
  117|       |#endif
  118|  4.65k|}

OSS_FUZZ_png_set_crc_action:
   36|  2.05k|{
   37|  2.05k|   png_debug(1, "in png_set_crc_action");
  ------------------
  |  |  148|  2.05k|#  define png_debug(l, m) ((void)0)
  ------------------
   38|       |
   39|  2.05k|   if (png_ptr == NULL)
  ------------------
  |  Branch (39:8): [True: 0, False: 2.05k]
  ------------------
   40|      0|      return;
   41|       |
   42|       |   /* Tell libpng how we react to CRC errors in critical chunks */
   43|  2.05k|   switch (crit_action)
   44|  2.05k|   {
   45|      0|      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
  ------------------
  |  | 1454|      0|#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */
  ------------------
  |  Branch (45:7): [True: 0, False: 2.05k]
  ------------------
   46|      0|         break;
   47|       |
   48|      0|      case PNG_CRC_WARN_USE:                               /* Warn/use data */
  ------------------
  |  | 1452|      0|#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
  ------------------
  |  Branch (48:7): [True: 0, False: 2.05k]
  ------------------
   49|      0|         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
  ------------------
  |  |  706|      0|#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
  |  |  ------------------
  |  |  |  |  681|      0|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  |  |  ------------------
  |  |  707|      0|                                     PNG_FLAG_CRC_CRITICAL_IGNORE)
  |  |  ------------------
  |  |  |  |  682|      0|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  |  |  ------------------
  ------------------
   50|      0|         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
  ------------------
  |  |  681|      0|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  ------------------
   51|      0|         break;
   52|       |
   53|  2.05k|      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
  ------------------
  |  | 1453|  2.05k|#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
  ------------------
  |  Branch (53:7): [True: 2.05k, False: 0]
  ------------------
   54|  2.05k|         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
  ------------------
  |  |  706|  2.05k|#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
  |  |  ------------------
  |  |  |  |  681|  2.05k|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  |  |  ------------------
  |  |  707|  2.05k|                                     PNG_FLAG_CRC_CRITICAL_IGNORE)
  |  |  ------------------
  |  |  |  |  682|  2.05k|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  |  |  ------------------
  ------------------
   55|  2.05k|         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
  ------------------
  |  |  681|  2.05k|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  ------------------
   56|  2.05k|                           PNG_FLAG_CRC_CRITICAL_IGNORE;
  ------------------
  |  |  682|  2.05k|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  ------------------
   57|  2.05k|         break;
   58|       |
   59|      0|      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
  ------------------
  |  | 1451|      0|#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
  ------------------
  |  Branch (59:7): [True: 0, False: 2.05k]
  ------------------
   60|      0|         png_warning(png_ptr,
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
   61|      0|             "Can't discard critical data on CRC error");
   62|       |         /* FALLTHROUGH */
   63|      0|      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
  ------------------
  |  | 1450|      0|#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
  ------------------
  |  Branch (63:7): [True: 0, False: 2.05k]
  ------------------
   64|       |
   65|      0|      case PNG_CRC_DEFAULT:
  ------------------
  |  | 1449|      0|#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
  ------------------
  |  Branch (65:7): [True: 0, False: 2.05k]
  ------------------
   66|      0|      default:
  ------------------
  |  Branch (66:7): [True: 0, False: 2.05k]
  ------------------
   67|      0|         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
  ------------------
  |  |  706|      0|#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
  |  |  ------------------
  |  |  |  |  681|      0|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  |  |  ------------------
  |  |  707|      0|                                     PNG_FLAG_CRC_CRITICAL_IGNORE)
  |  |  ------------------
  |  |  |  |  682|      0|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  |  |  ------------------
  ------------------
   68|      0|         break;
   69|  2.05k|   }
   70|       |
   71|       |   /* Tell libpng how we react to CRC errors in ancillary chunks */
   72|  2.05k|   switch (ancil_action)
   73|  2.05k|   {
   74|      0|      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
  ------------------
  |  | 1454|      0|#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */
  ------------------
  |  Branch (74:7): [True: 0, False: 2.05k]
  ------------------
   75|      0|         break;
   76|       |
   77|      0|      case PNG_CRC_WARN_USE:                              /* Warn/use data */
  ------------------
  |  | 1452|      0|#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
  ------------------
  |  Branch (77:7): [True: 0, False: 2.05k]
  ------------------
   78|      0|         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
  ------------------
  |  |  703|      0|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|      0|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|      0|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|      0|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
   79|      0|         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
  ------------------
  |  |  679|      0|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  ------------------
   80|      0|         break;
   81|       |
   82|  2.05k|      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
  ------------------
  |  | 1453|  2.05k|#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
  ------------------
  |  Branch (82:7): [True: 2.05k, False: 0]
  ------------------
   83|  2.05k|         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
  ------------------
  |  |  703|  2.05k|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|  2.05k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|  2.05k|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|  2.05k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
   84|  2.05k|         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
  ------------------
  |  |  679|  2.05k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  ------------------
   85|  2.05k|                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
  ------------------
  |  |  680|  2.05k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  ------------------
   86|  2.05k|         break;
   87|       |
   88|      0|      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
  ------------------
  |  | 1450|      0|#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
  ------------------
  |  Branch (88:7): [True: 0, False: 2.05k]
  ------------------
   89|      0|         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
  ------------------
  |  |  703|      0|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|      0|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|      0|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|      0|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
   90|      0|         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
  ------------------
  |  |  680|      0|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  ------------------
   91|      0|         break;
   92|       |
   93|      0|      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */
  ------------------
  |  | 1451|      0|#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
  ------------------
  |  Branch (93:7): [True: 0, False: 2.05k]
  ------------------
   94|       |
   95|      0|      case PNG_CRC_DEFAULT:
  ------------------
  |  | 1449|      0|#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
  ------------------
  |  Branch (95:7): [True: 0, False: 2.05k]
  ------------------
   96|      0|      default:
  ------------------
  |  Branch (96:7): [True: 0, False: 2.05k]
  ------------------
   97|      0|         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
  ------------------
  |  |  703|      0|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|      0|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|      0|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|      0|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
   98|      0|         break;
   99|  2.05k|   }
  100|  2.05k|}
OSS_FUZZ_png_set_scale_16:
  183|  1.16k|{
  184|  1.16k|   png_debug(1, "in png_set_scale_16");
  ------------------
  |  |  148|  1.16k|#  define png_debug(l, m) ((void)0)
  ------------------
  185|       |
  186|  1.16k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (186:8): [True: 0, False: 1.16k]
  ------------------
  187|      0|      return;
  188|       |
  189|  1.16k|   png_ptr->transformations |= PNG_SCALE_16_TO_8;
  ------------------
  |  |  661|  1.16k|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  190|  1.16k|}
OSS_FUZZ_png_set_alpha_mode_fixed:
  357|  1.07k|{
  358|  1.07k|   png_fixed_point file_gamma;
  359|  1.07k|   int compose = 0;
  360|       |
  361|  1.07k|   png_debug(1, "in png_set_alpha_mode_fixed");
  ------------------
  |  |  148|  1.07k|#  define png_debug(l, m) ((void)0)
  ------------------
  362|       |
  363|  1.07k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (363:8): [True: 0, False: 1.07k]
  ------------------
  364|      0|      return;
  365|       |
  366|  1.07k|   output_gamma = translate_gamma_flags(output_gamma, 1/*screen*/);
  367|  1.07k|   if (unsupported_gamma(png_ptr, output_gamma, 0/*error*/))
  ------------------
  |  Branch (367:8): [True: 0, False: 1.07k]
  ------------------
  368|      0|      return;
  369|       |
  370|       |   /* The default file gamma is the inverse of the output gamma; the output
  371|       |    * gamma may be changed below so get the file value first.  The default_gamma
  372|       |    * is set here and from the simplified API (which uses a different algorithm)
  373|       |    * so don't overwrite a set value:
  374|       |    */
  375|  1.07k|   file_gamma = png_ptr->default_gamma;
  376|  1.07k|   if (file_gamma == 0)
  ------------------
  |  Branch (376:8): [True: 537, False: 537]
  ------------------
  377|    537|   {
  378|    537|      file_gamma = png_reciprocal(output_gamma);
  ------------------
  |  |   89|    537|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
  379|    537|      png_ptr->default_gamma = file_gamma;
  380|    537|   }
  381|       |
  382|       |   /* There are really 8 possibilities here, composed of any combination
  383|       |    * of:
  384|       |    *
  385|       |    *    premultiply the color channels
  386|       |    *    do not encode non-opaque pixels
  387|       |    *    encode the alpha as well as the color channels
  388|       |    *
  389|       |    * The differences disappear if the input/output ('screen') gamma is 1.0,
  390|       |    * because then the encoding is a no-op and there is only the choice of
  391|       |    * premultiplying the color channels or not.
  392|       |    *
  393|       |    * png_set_alpha_mode and png_set_background interact because both use
  394|       |    * png_compose to do the work.  Calling both is only useful when
  395|       |    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along
  396|       |    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.
  397|       |    */
  398|  1.07k|   switch (mode)
  399|  1.07k|   {
  400|  1.07k|      case PNG_ALPHA_PNG:        /* default: png standard */
  ------------------
  |  | 1143|  1.07k|#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
  ------------------
  |  Branch (400:7): [True: 1.07k, False: 0]
  ------------------
  401|       |         /* No compose, but it may be set by png_set_background! */
  402|  1.07k|         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|  1.07k|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  403|  1.07k|         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|  1.07k|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
  404|  1.07k|         break;
  405|       |
  406|      0|      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */
  ------------------
  |  | 1145|      0|#define PNG_ALPHA_ASSOCIATED    1 /* as above; this is the normal practice */
  ------------------
  |  Branch (406:7): [True: 0, False: 1.07k]
  ------------------
  407|      0|         compose = 1;
  408|      0|         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|      0|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  409|      0|         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|      0|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
  410|       |         /* The output is linear: */
  411|      0|         output_gamma = PNG_FP_1;
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
  412|      0|         break;
  413|       |
  414|      0|      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
  ------------------
  |  | 1147|      0|#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
  ------------------
  |  Branch (414:7): [True: 0, False: 1.07k]
  ------------------
  415|      0|         compose = 1;
  416|      0|         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|      0|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  417|      0|         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|      0|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
  418|       |         /* output_gamma records the encoding of opaque pixels! */
  419|      0|         break;
  420|       |
  421|      0|      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */
  ------------------
  |  | 1148|      0|#define PNG_ALPHA_BROKEN        3 /* the alpha channel is gamma encoded */
  ------------------
  |  Branch (421:7): [True: 0, False: 1.07k]
  ------------------
  422|      0|         compose = 1;
  423|      0|         png_ptr->transformations |= PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|      0|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  424|      0|         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|      0|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
  425|      0|         break;
  426|       |
  427|      0|      default:
  ------------------
  |  Branch (427:7): [True: 0, False: 1.07k]
  ------------------
  428|      0|         png_error(png_ptr, "invalid alpha mode");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  429|  1.07k|   }
  430|       |
  431|       |   /* Set the screen gamma values: */
  432|  1.07k|   png_ptr->screen_gamma = output_gamma;
  433|       |
  434|       |   /* Finally, if pre-multiplying, set the background fields to achieve the
  435|       |    * desired result.
  436|       |    */
  437|  1.07k|   if (compose != 0)
  ------------------
  |  Branch (437:8): [True: 0, False: 1.07k]
  ------------------
  438|      0|   {
  439|       |      /* And obtain alpha pre-multiplication by composing on black: */
  440|      0|      memset(&png_ptr->background, 0, (sizeof png_ptr->background));
  441|      0|      png_ptr->background_gamma = file_gamma; /* just in case */
  442|      0|      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;
  ------------------
  |  | 1322|      0|#  define PNG_BACKGROUND_GAMMA_FILE    2
  ------------------
  443|      0|      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
  ------------------
  |  |  642|      0|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  444|       |
  445|      0|      if ((png_ptr->transformations & PNG_COMPOSE) != 0)
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (445:11): [True: 0, False: 0]
  ------------------
  446|      0|         png_error(png_ptr,
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  447|      0|             "conflicting calls to set alpha mode and background");
  448|       |
  449|      0|      png_ptr->transformations |= PNG_COMPOSE;
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  450|      0|   }
  451|  1.07k|}
OSS_FUZZ_png_set_expand:
  927|  1.64k|{
  928|  1.64k|   png_debug(1, "in png_set_expand");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
  929|       |
  930|  1.64k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (930:8): [True: 0, False: 1.64k]
  ------------------
  931|      0|      return;
  932|       |
  933|  1.64k|   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
  ------------------
  |  |  646|  1.64k|#define PNG_EXPAND              0x1000U
  ------------------
                 png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
  ------------------
  |  |  660|  1.64k|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  934|  1.64k|}
OSS_FUZZ_png_set_expand_gray_1_2_4_to_8:
  969|  1.39k|{
  970|  1.39k|   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
  ------------------
  |  |  148|  1.39k|#  define png_debug(l, m) ((void)0)
  ------------------
  971|       |
  972|  1.39k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (972:8): [True: 0, False: 1.39k]
  ------------------
  973|      0|      return;
  974|       |
  975|  1.39k|   png_ptr->transformations |= PNG_EXPAND;
  ------------------
  |  |  646|  1.39k|#define PNG_EXPAND              0x1000U
  ------------------
  976|  1.39k|}
OSS_FUZZ_png_set_tRNS_to_alpha:
  981|  1.11k|{
  982|  1.11k|   png_debug(1, "in png_set_tRNS_to_alpha");
  ------------------
  |  |  148|  1.11k|#  define png_debug(l, m) ((void)0)
  ------------------
  983|       |
  984|  1.11k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (984:8): [True: 0, False: 1.11k]
  ------------------
  985|      0|      return;
  986|       |
  987|  1.11k|   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
  ------------------
  |  |  646|  1.11k|#define PNG_EXPAND              0x1000U
  ------------------
                 png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
  ------------------
  |  |  660|  1.11k|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  988|  1.11k|}
OSS_FUZZ_png_set_gray_to_rgb:
 1010|  1.39k|{
 1011|  1.39k|   png_debug(1, "in png_set_gray_to_rgb");
  ------------------
  |  |  148|  1.39k|#  define png_debug(l, m) ((void)0)
  ------------------
 1012|       |
 1013|  1.39k|   if (png_rtran_ok(png_ptr, 0) == 0)
  ------------------
  |  Branch (1013:8): [True: 0, False: 1.39k]
  ------------------
 1014|      0|      return;
 1015|       |
 1016|       |   /* Because rgb must be 8 bits or more: */
 1017|  1.39k|   png_set_expand_gray_1_2_4_to_8(png_ptr);
  ------------------
  |  |  390|  1.39k|#define png_set_expand_gray_1_2_4_to_8 OSS_FUZZ_png_set_expand_gray_1_2_4_to_8
  ------------------
 1018|  1.39k|   png_ptr->transformations |= PNG_GRAY_TO_RGB;
  ------------------
  |  |  648|  1.39k|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
 1019|  1.39k|}
OSS_FUZZ_png_resolve_file_gamma:
 1330|  1.64k|{
 1331|  1.64k|   png_fixed_point file_gamma;
 1332|       |
 1333|       |   /* The file gamma is determined by these precedence rules, in this order
 1334|       |    * (i.e. use the first value found):
 1335|       |    *
 1336|       |    *    png_set_gamma; png_struct::file_gammma if not zero, then:
 1337|       |    *    png_struct::chunk_gamma if not 0 (determined the PNGv3 rules), then:
 1338|       |    *    png_set_gamma; 1/png_struct::screen_gamma if not zero
 1339|       |    *
 1340|       |    *    0 (i.e. do no gamma handling)
 1341|       |    */
 1342|  1.64k|   file_gamma = png_ptr->file_gamma;
 1343|  1.64k|   if (file_gamma != 0)
  ------------------
  |  Branch (1343:8): [True: 0, False: 1.64k]
  ------------------
 1344|      0|      return file_gamma;
 1345|       |
 1346|  1.64k|   file_gamma = png_ptr->chunk_gamma;
 1347|  1.64k|   if (file_gamma != 0)
  ------------------
  |  Branch (1347:8): [True: 696, False: 953]
  ------------------
 1348|    696|      return file_gamma;
 1349|       |
 1350|    953|   file_gamma = png_ptr->default_gamma;
 1351|    953|   if (file_gamma != 0)
  ------------------
  |  Branch (1351:8): [True: 288, False: 665]
  ------------------
 1352|    288|      return file_gamma;
 1353|       |
 1354|       |   /* If png_reciprocal oveflows it returns 0 which indicates to the caller that
 1355|       |    * there is no usable file gamma.  (The checks added to png_set_gamma and
 1356|       |    * png_set_alpha_mode should prevent a screen_gamma which would overflow.)
 1357|       |    */
 1358|    665|   if (png_ptr->screen_gamma != 0)
  ------------------
  |  Branch (1358:8): [True: 0, False: 665]
  ------------------
 1359|      0|      file_gamma = png_reciprocal(png_ptr->screen_gamma);
  ------------------
  |  |   89|      0|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1360|       |
 1361|    665|   return file_gamma;
 1362|    953|}
OSS_FUZZ_png_init_read_transformations:
 1403|  1.64k|{
 1404|  1.64k|   png_debug(1, "in png_init_read_transformations");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
 1405|       |
 1406|       |   /* This internal function is called from png_read_start_row in pngrutil.c
 1407|       |    * and it is called before the 'rowbytes' calculation is done, so the code
 1408|       |    * in here can change or update the transformations flags.
 1409|       |    *
 1410|       |    * First do updates that do not depend on the details of the PNG image data
 1411|       |    * being processed.
 1412|       |    */
 1413|       |
 1414|  1.64k|#ifdef PNG_READ_GAMMA_SUPPORTED
 1415|       |   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
 1416|       |    * png_set_alpha_mode and this is another source for a default file gamma so
 1417|       |    * the test needs to be performed later - here.  In addition prior to 1.5.4
 1418|       |    * the tests were repeated for the PALETTE color type here - this is no
 1419|       |    * longer necessary (and doesn't seem to have been necessary before.)
 1420|       |    *
 1421|       |    * PNGv3: the new mandatory precedence/priority rules for colour space chunks
 1422|       |    * are handled here (by calling the above function).
 1423|       |    *
 1424|       |    * Turn the gamma transformation on or off as appropriate.  Notice that
 1425|       |    * PNG_GAMMA just refers to the file->screen correction.  Alpha composition
 1426|       |    * may independently cause gamma correction because it needs linear data
 1427|       |    * (e.g. if the file has a gAMA chunk but the screen gamma hasn't been
 1428|       |    * specified.)  In any case this flag may get turned off in the code
 1429|       |    * immediately below if the transform can be handled outside the row loop.
 1430|       |    */
 1431|  1.64k|   if (png_init_gamma_values(png_ptr) != 0)
  ------------------
  |  Branch (1431:8): [True: 162, False: 1.48k]
  ------------------
 1432|    162|      png_ptr->transformations |= PNG_GAMMA;
  ------------------
  |  |  647|    162|#define PNG_GAMMA               0x2000U
  ------------------
 1433|       |
 1434|  1.48k|   else
 1435|  1.48k|      png_ptr->transformations &= ~PNG_GAMMA;
  ------------------
  |  |  647|  1.48k|#define PNG_GAMMA               0x2000U
  ------------------
 1436|  1.64k|#endif
 1437|       |
 1438|       |   /* Certain transformations have the effect of preventing other
 1439|       |    * transformations that happen afterward in png_do_read_transformations;
 1440|       |    * resolve the interdependencies here.  From the code of
 1441|       |    * png_do_read_transformations the order is:
 1442|       |    *
 1443|       |    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)
 1444|       |    *  2) PNG_STRIP_ALPHA (if no compose)
 1445|       |    *  3) PNG_RGB_TO_GRAY
 1446|       |    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY
 1447|       |    *  5) PNG_COMPOSE
 1448|       |    *  6) PNG_GAMMA
 1449|       |    *  7) PNG_STRIP_ALPHA (if compose)
 1450|       |    *  8) PNG_ENCODE_ALPHA
 1451|       |    *  9) PNG_SCALE_16_TO_8
 1452|       |    * 10) PNG_16_TO_8
 1453|       |    * 11) PNG_QUANTIZE (converts to palette)
 1454|       |    * 12) PNG_EXPAND_16
 1455|       |    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY
 1456|       |    * 14) PNG_INVERT_MONO
 1457|       |    * 15) PNG_INVERT_ALPHA
 1458|       |    * 16) PNG_SHIFT
 1459|       |    * 17) PNG_PACK
 1460|       |    * 18) PNG_BGR
 1461|       |    * 19) PNG_PACKSWAP
 1462|       |    * 20) PNG_FILLER (includes PNG_ADD_ALPHA)
 1463|       |    * 21) PNG_SWAP_ALPHA
 1464|       |    * 22) PNG_SWAP_BYTES
 1465|       |    * 23) PNG_USER_TRANSFORM [must be last]
 1466|       |    */
 1467|  1.64k|#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 1468|  1.64k|   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
  ------------------
  |  |  652|  1.64k|#define PNG_STRIP_ALPHA        0x40000U
  ------------------
  |  Branch (1468:8): [True: 0, False: 1.64k]
  ------------------
 1469|  1.64k|       (png_ptr->transformations & PNG_COMPOSE) == 0)
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1469:8): [True: 0, False: 0]
  ------------------
 1470|      0|   {
 1471|       |      /* Stripping the alpha channel happens immediately after the 'expand'
 1472|       |       * transformations, before all other transformation, so it cancels out
 1473|       |       * the alpha handling.  It has the side effect negating the effect of
 1474|       |       * PNG_EXPAND_tRNS too:
 1475|       |       */
 1476|      0|      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
  ------------------
  |  |  642|      0|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
                    png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
  ------------------
  |  |  658|      0|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
 1477|      0|         PNG_EXPAND_tRNS);
  ------------------
  |  |  660|      0|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
 1478|      0|      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|      0|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
 1479|       |
 1480|       |      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
 1481|       |       * so transparency information would remain just so long as it wasn't
 1482|       |       * expanded.  This produces unexpected API changes if the set of things
 1483|       |       * that do PNG_EXPAND_tRNS changes (perfectly possible given the
 1484|       |       * documentation - which says ask for what you want, accept what you
 1485|       |       * get.)  This makes the behavior consistent from 1.5.4:
 1486|       |       */
 1487|      0|      png_ptr->num_trans = 0;
 1488|      0|   }
 1489|  1.64k|#endif /* STRIP_ALPHA supported, no COMPOSE */
 1490|       |
 1491|  1.64k|#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
 1492|       |   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
 1493|       |    * settings will have no effect.
 1494|       |    */
 1495|  1.64k|   if (png_gamma_significant(png_ptr->screen_gamma) == 0)
  ------------------
  |  |   91|  1.64k|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1495:8): [True: 910, False: 739]
  ------------------
 1496|    910|   {
 1497|    910|      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|    910|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
 1498|    910|      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|    910|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
 1499|    910|   }
 1500|  1.64k|#endif
 1501|       |
 1502|  1.64k|#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 1503|       |   /* Make sure the coefficients for the rgb to gray conversion are set
 1504|       |    * appropriately.
 1505|       |    */
 1506|  1.64k|   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
  ------------------
  |  |  657|  1.64k|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (1506:8): [True: 0, False: 1.64k]
  ------------------
 1507|      0|      png_set_rgb_coefficients(png_ptr);
  ------------------
  |  |   98|      0|#define png_set_rgb_coefficients OSS_FUZZ_png_set_rgb_coefficients
  ------------------
 1508|  1.64k|#endif
 1509|       |
 1510|  1.64k|#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 1511|  1.64k|#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
 1512|       |   /* Detect gray background and attempt to enable optimization for
 1513|       |    * gray --> RGB case.
 1514|       |    *
 1515|       |    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
 1516|       |    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
 1517|       |    * background color might actually be gray yet not be flagged as such.
 1518|       |    * This is not a problem for the current code, which uses
 1519|       |    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
 1520|       |    * png_do_gray_to_rgb() transformation.
 1521|       |    *
 1522|       |    * TODO: this code needs to be revised to avoid the complexity and
 1523|       |    * interdependencies.  The color type of the background should be recorded in
 1524|       |    * png_set_background, along with the bit depth, then the code has a record
 1525|       |    * of exactly what color space the background is currently in.
 1526|       |    */
 1527|  1.64k|   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0)
  ------------------
  |  |  642|  1.64k|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  |  Branch (1527:8): [True: 0, False: 1.64k]
  ------------------
 1528|      0|   {
 1529|       |      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
 1530|       |       * the file was grayscale the background value is gray.
 1531|       |       */
 1532|      0|      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
  ------------------
  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1532:11): [True: 0, False: 0]
  ------------------
 1533|      0|         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
  ------------------
  |  |  627|      0|#define PNG_BACKGROUND_IS_GRAY     0x800U
  ------------------
 1534|      0|   }
 1535|       |
 1536|  1.64k|   else if ((png_ptr->transformations & PNG_COMPOSE) != 0)
  ------------------
  |  |  641|  1.64k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1536:13): [True: 0, False: 1.64k]
  ------------------
 1537|      0|   {
 1538|       |      /* PNG_COMPOSE: png_set_background was called with need_expand false,
 1539|       |       * so the color is in the color space of the output or png_set_alpha_mode
 1540|       |       * was called and the color is black.  Ignore RGB_TO_GRAY because that
 1541|       |       * happens before GRAY_TO_RGB.
 1542|       |       */
 1543|      0|      if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
  ------------------
  |  |  648|      0|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
  |  Branch (1543:11): [True: 0, False: 0]
  ------------------
 1544|      0|      {
 1545|      0|         if (png_ptr->background.red == png_ptr->background.green &&
  ------------------
  |  Branch (1545:14): [True: 0, False: 0]
  ------------------
 1546|      0|             png_ptr->background.red == png_ptr->background.blue)
  ------------------
  |  Branch (1546:14): [True: 0, False: 0]
  ------------------
 1547|      0|         {
 1548|      0|            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
  ------------------
  |  |  627|      0|#define PNG_BACKGROUND_IS_GRAY     0x800U
  ------------------
 1549|      0|            png_ptr->background.gray = png_ptr->background.red;
 1550|      0|         }
 1551|      0|      }
 1552|      0|   }
 1553|  1.64k|#endif /* READ_EXPAND && READ_BACKGROUND */
 1554|  1.64k|#endif /* READ_GRAY_TO_RGB */
 1555|       |
 1556|       |   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
 1557|       |    * can be performed directly on the palette, and some (such as rgb to gray)
 1558|       |    * can be optimized inside the palette.  This is particularly true of the
 1559|       |    * composite (background and alpha) stuff, which can be pretty much all done
 1560|       |    * in the palette even if the result is expanded to RGB or gray afterward.
 1561|       |    *
 1562|       |    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and
 1563|       |    * earlier and the palette stuff is actually handled on the first row.  This
 1564|       |    * leads to the reported bug that the palette returned by png_get_PLTE is not
 1565|       |    * updated.
 1566|       |    */
 1567|  1.64k|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  1.64k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.64k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1567:8): [True: 307, False: 1.34k]
  ------------------
 1568|    307|      png_init_palette_transformations(png_ptr);
 1569|       |
 1570|  1.34k|   else
 1571|  1.34k|      png_init_rgb_transformations(png_ptr);
 1572|       |
 1573|  1.64k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
 1574|  1.64k|   defined(PNG_READ_EXPAND_16_SUPPORTED)
 1575|  1.64k|   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&
  ------------------
  |  |  643|  1.64k|#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
  ------------------
  |  Branch (1575:8): [True: 0, False: 1.64k]
  ------------------
 1576|  1.64k|       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1576:8): [True: 0, False: 0]
  ------------------
 1577|  1.64k|       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&
  ------------------
  |  |  642|      0|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  |  Branch (1577:8): [True: 0, False: 0]
  ------------------
 1578|  1.64k|       png_ptr->bit_depth != 16)
  ------------------
  |  Branch (1578:8): [True: 0, False: 0]
  ------------------
 1579|      0|   {
 1580|       |      /* TODO: fix this.  Because the expand_16 operation is after the compose
 1581|       |       * handling the background color must be 8, not 16, bits deep, but the
 1582|       |       * application will supply a 16-bit value so reduce it here.
 1583|       |       *
 1584|       |       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
 1585|       |       * present, so that case is ok (until do_expand_16 is moved.)
 1586|       |       *
 1587|       |       * NOTE: this discards the low 16 bits of the user supplied background
 1588|       |       * color, but until expand_16 works properly there is no choice!
 1589|       |       */
 1590|      0|#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
 1591|      0|      CHOP(png_ptr->background.red);
  ------------------
  |  | 1590|      0|#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
  |  |  ------------------
  |  |  |  |  727|      0|#define PNG_DIV257(v16) PNG_DIV65535((png_uint_32)(v16) * 255)
  |  |  |  |  ------------------
  |  |  |  |  |  |  726|      0|#define PNG_DIV65535(v24) (((v24) + 32895) >> 16)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1592|      0|      CHOP(png_ptr->background.green);
  ------------------
  |  | 1590|      0|#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
  |  |  ------------------
  |  |  |  |  727|      0|#define PNG_DIV257(v16) PNG_DIV65535((png_uint_32)(v16) * 255)
  |  |  |  |  ------------------
  |  |  |  |  |  |  726|      0|#define PNG_DIV65535(v24) (((v24) + 32895) >> 16)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1593|      0|      CHOP(png_ptr->background.blue);
  ------------------
  |  | 1590|      0|#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
  |  |  ------------------
  |  |  |  |  727|      0|#define PNG_DIV257(v16) PNG_DIV65535((png_uint_32)(v16) * 255)
  |  |  |  |  ------------------
  |  |  |  |  |  |  726|      0|#define PNG_DIV65535(v24) (((v24) + 32895) >> 16)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1594|      0|      CHOP(png_ptr->background.gray);
  ------------------
  |  | 1590|      0|#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
  |  |  ------------------
  |  |  |  |  727|      0|#define PNG_DIV257(v16) PNG_DIV65535((png_uint_32)(v16) * 255)
  |  |  |  |  ------------------
  |  |  |  |  |  |  726|      0|#define PNG_DIV65535(v24) (((v24) + 32895) >> 16)
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1595|      0|#     undef CHOP
 1596|      0|   }
 1597|  1.64k|#endif /* READ_BACKGROUND && READ_EXPAND_16 */
 1598|       |
 1599|  1.64k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
 1600|  1.64k|   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \
 1601|  1.64k|   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))
 1602|  1.64k|   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) != 0 &&
  ------------------
  |  |  644|  1.64k|#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
  ------------------
                 if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) != 0 &&
  ------------------
  |  |  661|  1.64k|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (1602:8): [True: 1.16k, False: 485]
  ------------------
 1603|  1.64k|       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|  1.16k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1603:8): [True: 0, False: 1.16k]
  ------------------
 1604|  1.64k|       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&
  ------------------
  |  |  642|      0|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  |  Branch (1604:8): [True: 0, False: 0]
  ------------------
 1605|  1.64k|       png_ptr->bit_depth == 16)
  ------------------
  |  Branch (1605:8): [True: 0, False: 0]
  ------------------
 1606|      0|   {
 1607|       |      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per
 1608|       |       * component this will also happen after PNG_COMPOSE and so the background
 1609|       |       * color must be pre-expanded here.
 1610|       |       *
 1611|       |       * TODO: fix this too.
 1612|       |       */
 1613|      0|      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);
 1614|      0|      png_ptr->background.green =
 1615|      0|         (png_uint_16)(png_ptr->background.green * 257);
 1616|      0|      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);
 1617|      0|      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);
 1618|      0|   }
 1619|  1.64k|#endif
 1620|       |
 1621|       |   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
 1622|       |    * background support (see the comments in scripts/pnglibconf.dfa), this
 1623|       |    * allows pre-multiplication of the alpha channel to be implemented as
 1624|       |    * compositing on black.  This is probably sub-optimal and has been done in
 1625|       |    * 1.5.4 betas simply to enable external critique and testing (i.e. to
 1626|       |    * implement the new API quickly, without lots of internal changes.)
 1627|       |    */
 1628|       |
 1629|  1.64k|#ifdef PNG_READ_GAMMA_SUPPORTED
 1630|  1.64k|#  ifdef PNG_READ_BACKGROUND_SUPPORTED
 1631|       |      /* Includes ALPHA_MODE */
 1632|  1.64k|      png_ptr->background_1 = png_ptr->background;
 1633|  1.64k|#  endif
 1634|       |
 1635|       |   /* This needs to change - in the palette image case a whole set of tables are
 1636|       |    * built when it would be quicker to just calculate the correct value for
 1637|       |    * each palette entry directly.  Also, the test is too tricky - why check
 1638|       |    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that
 1639|       |    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
 1640|       |    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction
 1641|       |    * the gamma tables will not be built even if composition is required on a
 1642|       |    * gamma encoded value.
 1643|       |    *
 1644|       |    * In 1.5.4 this is addressed below by an additional check on the individual
 1645|       |    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the
 1646|       |    * tables.
 1647|       |    */
 1648|  1.64k|   if ((png_ptr->transformations & PNG_GAMMA) != 0 ||
  ------------------
  |  |  647|  1.64k|#define PNG_GAMMA               0x2000U
  ------------------
  |  Branch (1648:8): [True: 162, False: 1.48k]
  ------------------
 1649|  1.64k|       ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0 &&
  ------------------
  |  |  657|  1.48k|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (1649:9): [True: 0, False: 1.48k]
  ------------------
 1650|  1.48k|        (png_gamma_significant(png_ptr->file_gamma) != 0 ||
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1650:10): [True: 0, False: 0]
  ------------------
 1651|      0|         png_gamma_significant(png_ptr->screen_gamma) != 0)) ||
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1651:10): [True: 0, False: 0]
  ------------------
 1652|  1.64k|        ((png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|  1.48k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1652:10): [True: 0, False: 1.48k]
  ------------------
 1653|  1.48k|         (png_gamma_significant(png_ptr->file_gamma) != 0 ||
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1653:11): [True: 0, False: 0]
  ------------------
 1654|      0|          png_gamma_significant(png_ptr->screen_gamma) != 0
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1654:11): [True: 0, False: 0]
  ------------------
 1655|      0|#  ifdef PNG_READ_BACKGROUND_SUPPORTED
 1656|      0|         || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE &&
  ------------------
  |  | 1323|      0|#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
  ------------------
  |  Branch (1656:14): [True: 0, False: 0]
  ------------------
 1657|      0|           png_gamma_significant(png_ptr->background_gamma) != 0)
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1657:12): [True: 0, False: 0]
  ------------------
 1658|      0|#  endif
 1659|  1.48k|        )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&
  ------------------
  |  |  658|  1.48k|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (1659:16): [True: 0, False: 1.48k]
  ------------------
 1660|  1.48k|       png_gamma_significant(png_ptr->screen_gamma) != 0))
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1660:8): [True: 0, False: 0]
  ------------------
 1661|    162|   {
 1662|    162|      png_build_gamma_table(png_ptr, png_ptr->bit_depth);
  ------------------
  |  |   97|    162|#define png_build_gamma_table OSS_FUZZ_png_build_gamma_table
  ------------------
 1663|       |
 1664|    162|#ifdef PNG_READ_BACKGROUND_SUPPORTED
 1665|    162|      if ((png_ptr->transformations & PNG_COMPOSE) != 0)
  ------------------
  |  |  641|    162|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1665:11): [True: 0, False: 162]
  ------------------
 1666|      0|      {
 1667|       |         /* Issue a warning about this combination: because RGB_TO_GRAY is
 1668|       |          * optimized to do the gamma transform if present yet do_background has
 1669|       |          * to do the same thing if both options are set a
 1670|       |          * double-gamma-correction happens.  This is true in all versions of
 1671|       |          * libpng to date.
 1672|       |          */
 1673|      0|         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
  ------------------
  |  |  657|      0|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (1673:14): [True: 0, False: 0]
  ------------------
 1674|      0|            png_warning(png_ptr,
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1675|      0|                "libpng does not support gamma+background+rgb_to_gray");
 1676|       |
 1677|      0|         if ((png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) != 0)
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1677:14): [True: 0, False: 0]
  ------------------
 1678|      0|         {
 1679|       |            /* We don't get to here unless there is a tRNS chunk with non-opaque
 1680|       |             * entries - see the checking code at the start of this function.
 1681|       |             */
 1682|      0|            png_color back, back_1;
 1683|      0|            png_colorp palette = png_ptr->palette;
 1684|      0|            int num_palette = png_ptr->num_palette;
 1685|      0|            int i;
 1686|      0|            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
  ------------------
  |  | 1322|      0|#  define PNG_BACKGROUND_GAMMA_FILE    2
  ------------------
  |  Branch (1686:17): [True: 0, False: 0]
  ------------------
 1687|      0|            {
 1688|       |
 1689|      0|               back.red = png_ptr->gamma_table[png_ptr->background.red];
 1690|      0|               back.green = png_ptr->gamma_table[png_ptr->background.green];
 1691|      0|               back.blue = png_ptr->gamma_table[png_ptr->background.blue];
 1692|       |
 1693|      0|               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
 1694|      0|               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
 1695|      0|               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
 1696|      0|            }
 1697|      0|            else
 1698|      0|            {
 1699|      0|               png_fixed_point g, gs;
 1700|       |
 1701|      0|               switch (png_ptr->background_gamma_type)
 1702|      0|               {
 1703|      0|                  case PNG_BACKGROUND_GAMMA_SCREEN:
  ------------------
  |  | 1321|      0|#  define PNG_BACKGROUND_GAMMA_SCREEN  1
  ------------------
  |  Branch (1703:19): [True: 0, False: 0]
  ------------------
 1704|      0|                     g = (png_ptr->screen_gamma);
 1705|      0|                     gs = PNG_FP_1;
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 1706|      0|                     break;
 1707|       |
 1708|      0|                  case PNG_BACKGROUND_GAMMA_FILE:
  ------------------
  |  | 1322|      0|#  define PNG_BACKGROUND_GAMMA_FILE    2
  ------------------
  |  Branch (1708:19): [True: 0, False: 0]
  ------------------
 1709|      0|                     g = png_reciprocal(png_ptr->file_gamma);
  ------------------
  |  |   89|      0|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1710|      0|                     gs = png_reciprocal2(png_ptr->file_gamma,
  ------------------
  |  |   90|      0|#define png_reciprocal2 OSS_FUZZ_png_reciprocal2
  ------------------
 1711|      0|                         png_ptr->screen_gamma);
 1712|      0|                     break;
 1713|       |
 1714|      0|                  case PNG_BACKGROUND_GAMMA_UNIQUE:
  ------------------
  |  | 1323|      0|#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
  ------------------
  |  Branch (1714:19): [True: 0, False: 0]
  ------------------
 1715|      0|                     g = png_reciprocal(png_ptr->background_gamma);
  ------------------
  |  |   89|      0|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1716|      0|                     gs = png_reciprocal2(png_ptr->background_gamma,
  ------------------
  |  |   90|      0|#define png_reciprocal2 OSS_FUZZ_png_reciprocal2
  ------------------
 1717|      0|                         png_ptr->screen_gamma);
 1718|      0|                     break;
 1719|      0|                  default:
  ------------------
  |  Branch (1719:19): [True: 0, False: 0]
  ------------------
 1720|      0|                     g = PNG_FP_1;    /* back_1 */
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 1721|      0|                     gs = PNG_FP_1;   /* back */
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 1722|      0|                     break;
 1723|      0|               }
 1724|       |
 1725|      0|               if (png_gamma_significant(gs) != 0)
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1725:20): [True: 0, False: 0]
  ------------------
 1726|      0|               {
 1727|      0|                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1728|      0|                      gs);
 1729|      0|                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1730|      0|                      gs);
 1731|      0|                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1732|      0|                      gs);
 1733|      0|               }
 1734|       |
 1735|      0|               else
 1736|      0|               {
 1737|      0|                  back.red   = (png_byte)png_ptr->background.red;
 1738|      0|                  back.green = (png_byte)png_ptr->background.green;
 1739|      0|                  back.blue  = (png_byte)png_ptr->background.blue;
 1740|      0|               }
 1741|       |
 1742|      0|               if (png_gamma_significant(g) != 0)
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1742:20): [True: 0, False: 0]
  ------------------
 1743|      0|               {
 1744|      0|                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1745|      0|                      g);
 1746|      0|                  back_1.green = png_gamma_8bit_correct(
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1747|      0|                      png_ptr->background.green, g);
 1748|      0|                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
  ------------------
  |  |   95|      0|#define png_gamma_8bit_correct OSS_FUZZ_png_gamma_8bit_correct
  ------------------
 1749|      0|                      g);
 1750|      0|               }
 1751|       |
 1752|      0|               else
 1753|      0|               {
 1754|      0|                  back_1.red   = (png_byte)png_ptr->background.red;
 1755|      0|                  back_1.green = (png_byte)png_ptr->background.green;
 1756|      0|                  back_1.blue  = (png_byte)png_ptr->background.blue;
 1757|      0|               }
 1758|      0|            }
 1759|       |
 1760|      0|            for (i = 0; i < num_palette; i++)
  ------------------
  |  Branch (1760:25): [True: 0, False: 0]
  ------------------
 1761|      0|            {
 1762|      0|               if (i < (int)png_ptr->num_trans &&
  ------------------
  |  Branch (1762:20): [True: 0, False: 0]
  ------------------
 1763|      0|                   png_ptr->trans_alpha[i] != 0xff)
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|               {
 1765|      0|                  if (png_ptr->trans_alpha[i] == 0)
  ------------------
  |  Branch (1765:23): [True: 0, False: 0]
  ------------------
 1766|      0|                  {
 1767|      0|                     palette[i] = back;
 1768|      0|                  }
 1769|      0|                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
 1770|      0|                  {
 1771|      0|                     png_byte v, w;
 1772|       |
 1773|      0|                     v = png_ptr->gamma_to_1[palette[i].red];
 1774|      0|                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1775|      0|                     palette[i].red = png_ptr->gamma_from_1[w];
 1776|       |
 1777|      0|                     v = png_ptr->gamma_to_1[palette[i].green];
 1778|      0|                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1779|      0|                     palette[i].green = png_ptr->gamma_from_1[w];
 1780|       |
 1781|      0|                     v = png_ptr->gamma_to_1[palette[i].blue];
 1782|      0|                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1783|      0|                     palette[i].blue = png_ptr->gamma_from_1[w];
 1784|      0|                  }
 1785|      0|               }
 1786|      0|               else
 1787|      0|               {
 1788|      0|                  palette[i].red = png_ptr->gamma_table[palette[i].red];
 1789|      0|                  palette[i].green = png_ptr->gamma_table[palette[i].green];
 1790|      0|                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
 1791|      0|               }
 1792|      0|            }
 1793|       |
 1794|       |            /* Prevent the transformations being done again.
 1795|       |             *
 1796|       |             * NOTE: this is highly dubious; it removes the transformations in
 1797|       |             * place.  This seems inconsistent with the general treatment of the
 1798|       |             * transformations elsewhere.
 1799|       |             */
 1800|      0|            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
                          png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
  ------------------
  |  |  647|      0|#define PNG_GAMMA               0x2000U
  ------------------
 1801|      0|         } /* color_type == PNG_COLOR_TYPE_PALETTE */
 1802|       |
 1803|       |         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
 1804|      0|         else /* color_type != PNG_COLOR_TYPE_PALETTE */
 1805|      0|         {
 1806|      0|            int gs_sig, g_sig;
 1807|      0|            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 1808|      0|            png_fixed_point gs = PNG_FP_1; /* Correction to screen */
  ------------------
  |  |  654|      0|#define PNG_FP_1    100000
  ------------------
 1809|       |
 1810|      0|            switch (png_ptr->background_gamma_type)
 1811|      0|            {
 1812|      0|               case PNG_BACKGROUND_GAMMA_SCREEN:
  ------------------
  |  | 1321|      0|#  define PNG_BACKGROUND_GAMMA_SCREEN  1
  ------------------
  |  Branch (1812:16): [True: 0, False: 0]
  ------------------
 1813|      0|                  g = png_ptr->screen_gamma;
 1814|       |                  /* gs = PNG_FP_1; */
 1815|      0|                  break;
 1816|       |
 1817|      0|               case PNG_BACKGROUND_GAMMA_FILE:
  ------------------
  |  | 1322|      0|#  define PNG_BACKGROUND_GAMMA_FILE    2
  ------------------
  |  Branch (1817:16): [True: 0, False: 0]
  ------------------
 1818|      0|                  g = png_reciprocal(png_ptr->file_gamma);
  ------------------
  |  |   89|      0|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1819|      0|                  gs = png_reciprocal2(png_ptr->file_gamma,
  ------------------
  |  |   90|      0|#define png_reciprocal2 OSS_FUZZ_png_reciprocal2
  ------------------
 1820|      0|                      png_ptr->screen_gamma);
 1821|      0|                  break;
 1822|       |
 1823|      0|               case PNG_BACKGROUND_GAMMA_UNIQUE:
  ------------------
  |  | 1323|      0|#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
  ------------------
  |  Branch (1823:16): [True: 0, False: 0]
  ------------------
 1824|      0|                  g = png_reciprocal(png_ptr->background_gamma);
  ------------------
  |  |   89|      0|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1825|      0|                  gs = png_reciprocal2(png_ptr->background_gamma,
  ------------------
  |  |   90|      0|#define png_reciprocal2 OSS_FUZZ_png_reciprocal2
  ------------------
 1826|      0|                      png_ptr->screen_gamma);
 1827|      0|                  break;
 1828|       |
 1829|      0|               default:
  ------------------
  |  Branch (1829:16): [True: 0, False: 0]
  ------------------
 1830|      0|                  png_error(png_ptr, "invalid background gamma type");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 1831|      0|            }
 1832|       |
 1833|      0|            g_sig = png_gamma_significant(g);
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
 1834|      0|            gs_sig = png_gamma_significant(gs);
  ------------------
  |  |   91|      0|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
 1835|       |
 1836|      0|            if (g_sig != 0)
  ------------------
  |  Branch (1836:17): [True: 0, False: 0]
  ------------------
 1837|      0|               png_ptr->background_1.gray = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1838|      0|                   png_ptr->background.gray, g);
 1839|       |
 1840|      0|            if (gs_sig != 0)
  ------------------
  |  Branch (1840:17): [True: 0, False: 0]
  ------------------
 1841|      0|               png_ptr->background.gray = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1842|      0|                   png_ptr->background.gray, gs);
 1843|       |
 1844|      0|            if ((png_ptr->background.red != png_ptr->background.green) ||
  ------------------
  |  Branch (1844:17): [True: 0, False: 0]
  ------------------
 1845|      0|                (png_ptr->background.red != png_ptr->background.blue) ||
  ------------------
  |  Branch (1845:17): [True: 0, False: 0]
  ------------------
 1846|      0|                (png_ptr->background.red != png_ptr->background.gray))
  ------------------
  |  Branch (1846:17): [True: 0, False: 0]
  ------------------
 1847|      0|            {
 1848|       |               /* RGB or RGBA with color background */
 1849|      0|               if (g_sig != 0)
  ------------------
  |  Branch (1849:20): [True: 0, False: 0]
  ------------------
 1850|      0|               {
 1851|      0|                  png_ptr->background_1.red = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1852|      0|                      png_ptr->background.red, g);
 1853|       |
 1854|      0|                  png_ptr->background_1.green = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1855|      0|                      png_ptr->background.green, g);
 1856|       |
 1857|      0|                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1858|      0|                      png_ptr->background.blue, g);
 1859|      0|               }
 1860|       |
 1861|      0|               if (gs_sig != 0)
  ------------------
  |  Branch (1861:20): [True: 0, False: 0]
  ------------------
 1862|      0|               {
 1863|      0|                  png_ptr->background.red = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1864|      0|                      png_ptr->background.red, gs);
 1865|       |
 1866|      0|                  png_ptr->background.green = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1867|      0|                      png_ptr->background.green, gs);
 1868|       |
 1869|      0|                  png_ptr->background.blue = png_gamma_correct(png_ptr,
  ------------------
  |  |   93|      0|#define png_gamma_correct OSS_FUZZ_png_gamma_correct
  ------------------
 1870|      0|                      png_ptr->background.blue, gs);
 1871|      0|               }
 1872|      0|            }
 1873|       |
 1874|      0|            else
 1875|      0|            {
 1876|       |               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
 1877|      0|               png_ptr->background_1.red = png_ptr->background_1.green
 1878|      0|                   = png_ptr->background_1.blue = png_ptr->background_1.gray;
 1879|       |
 1880|      0|               png_ptr->background.red = png_ptr->background.green
 1881|      0|                   = png_ptr->background.blue = png_ptr->background.gray;
 1882|      0|            }
 1883|       |
 1884|       |            /* The background is now in screen gamma: */
 1885|      0|            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;
  ------------------
  |  | 1321|      0|#  define PNG_BACKGROUND_GAMMA_SCREEN  1
  ------------------
 1886|      0|         } /* color_type != PNG_COLOR_TYPE_PALETTE */
 1887|      0|      }/* png_ptr->transformations & PNG_BACKGROUND */
 1888|       |
 1889|    162|      else
 1890|       |      /* Transformation does not include PNG_BACKGROUND */
 1891|    162|#endif /* READ_BACKGROUND */
 1892|    162|      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE
  ------------------
  |  |  667|    324|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    162|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    162|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1892:11): [True: 32, False: 130]
  ------------------
 1893|    162|#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 1894|       |         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */
 1895|    162|         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||
  ------------------
  |  |  646|     32|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (1895:14): [True: 0, False: 32]
  ------------------
 1896|     32|         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
  ------------------
  |  |  657|     32|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (1896:10): [True: 32, False: 0]
  ------------------
 1897|    162|#endif
 1898|    162|         )
 1899|     32|      {
 1900|     32|         png_colorp palette = png_ptr->palette;
 1901|     32|         int num_palette = png_ptr->num_palette;
 1902|     32|         int i;
 1903|       |
 1904|       |         /* NOTE: there are other transformations that should probably be in
 1905|       |          * here too.
 1906|       |          */
 1907|  3.68k|         for (i = 0; i < num_palette; i++)
  ------------------
  |  Branch (1907:22): [True: 3.64k, False: 32]
  ------------------
 1908|  3.64k|         {
 1909|  3.64k|            palette[i].red = png_ptr->gamma_table[palette[i].red];
 1910|  3.64k|            palette[i].green = png_ptr->gamma_table[palette[i].green];
 1911|  3.64k|            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
 1912|  3.64k|         }
 1913|       |
 1914|       |         /* Done the gamma correction. */
 1915|     32|         png_ptr->transformations &= ~PNG_GAMMA;
  ------------------
  |  |  647|     32|#define PNG_GAMMA               0x2000U
  ------------------
 1916|     32|      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */
 1917|    162|   }
 1918|  1.48k|#ifdef PNG_READ_BACKGROUND_SUPPORTED
 1919|  1.48k|   else
 1920|  1.48k|#endif
 1921|  1.48k|#endif /* READ_GAMMA */
 1922|       |
 1923|  1.48k|#ifdef PNG_READ_BACKGROUND_SUPPORTED
 1924|       |   /* No GAMMA transformation (see the hanging else 4 lines above) */
 1925|  1.48k|   if ((png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|  1.48k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (1925:8): [True: 0, False: 1.48k]
  ------------------
 1926|  1.48k|       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1926:8): [True: 0, False: 0]
  ------------------
 1927|      0|   {
 1928|      0|      int i;
 1929|      0|      int istop = (int)png_ptr->num_trans;
 1930|      0|      png_color back;
 1931|      0|      png_colorp palette = png_ptr->palette;
 1932|       |
 1933|      0|      back.red   = (png_byte)png_ptr->background.red;
 1934|      0|      back.green = (png_byte)png_ptr->background.green;
 1935|      0|      back.blue  = (png_byte)png_ptr->background.blue;
 1936|       |
 1937|      0|      for (i = 0; i < istop; i++)
  ------------------
  |  Branch (1937:19): [True: 0, False: 0]
  ------------------
 1938|      0|      {
 1939|      0|         if (png_ptr->trans_alpha[i] == 0)
  ------------------
  |  Branch (1939:14): [True: 0, False: 0]
  ------------------
 1940|      0|         {
 1941|      0|            palette[i] = back;
 1942|      0|         }
 1943|       |
 1944|      0|         else if (png_ptr->trans_alpha[i] != 0xff)
  ------------------
  |  Branch (1944:19): [True: 0, False: 0]
  ------------------
 1945|      0|         {
 1946|       |            /* The png_composite() macro is defined in png.h */
 1947|      0|            png_composite(palette[i].red, palette[i].red,
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1948|      0|                png_ptr->trans_alpha[i], back.red);
 1949|       |
 1950|      0|            png_composite(palette[i].green, palette[i].green,
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1951|      0|                png_ptr->trans_alpha[i], back.green);
 1952|       |
 1953|      0|            png_composite(palette[i].blue, palette[i].blue,
  ------------------
  |  | 2615|      0|   {                                                     \
  |  | 2616|      0|      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
  |  | 2617|      0|          * (png_uint_16)(alpha)                         \
  |  | 2618|      0|          + (png_uint_16)(bg)*(png_uint_16)(255          \
  |  | 2619|      0|          - (png_uint_16)(alpha)) + 128);                \
  |  | 2620|      0|      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
  |  | 2621|      0|   }
  ------------------
 1954|      0|                png_ptr->trans_alpha[i], back.blue);
 1955|      0|         }
 1956|      0|      }
 1957|       |
 1958|      0|      png_ptr->transformations &= ~PNG_COMPOSE;
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
 1959|      0|   }
 1960|  1.64k|#endif /* READ_BACKGROUND */
 1961|       |
 1962|  1.64k|#ifdef PNG_READ_SHIFT_SUPPORTED
 1963|  1.64k|   if ((png_ptr->transformations & PNG_SHIFT) != 0 &&
  ------------------
  |  |  637|  1.64k|#define PNG_SHIFT               0x0008U
  ------------------
  |  Branch (1963:8): [True: 0, False: 1.64k]
  ------------------
 1964|  1.64k|       (png_ptr->transformations & PNG_EXPAND) == 0 &&
  ------------------
  |  |  646|      0|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (1964:8): [True: 0, False: 0]
  ------------------
 1965|  1.64k|       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1965:8): [True: 0, False: 0]
  ------------------
 1966|      0|   {
 1967|      0|      int i;
 1968|      0|      int istop = png_ptr->num_palette;
 1969|      0|      int shift = 8 - png_ptr->sig_bit.red;
 1970|       |
 1971|      0|      png_ptr->transformations &= ~PNG_SHIFT;
  ------------------
  |  |  637|      0|#define PNG_SHIFT               0x0008U
  ------------------
 1972|       |
 1973|       |      /* significant bits can be in the range 1 to 7 for a meaningful result, if
 1974|       |       * the number of significant bits is 0 then no shift is done (this is an
 1975|       |       * error condition which is silently ignored.)
 1976|       |       */
 1977|      0|      if (shift > 0 && shift < 8)
  ------------------
  |  Branch (1977:11): [True: 0, False: 0]
  |  Branch (1977:24): [True: 0, False: 0]
  ------------------
 1978|      0|         for (i=0; i<istop; ++i)
  ------------------
  |  Branch (1978:20): [True: 0, False: 0]
  ------------------
 1979|      0|         {
 1980|      0|            int component = png_ptr->palette[i].red;
 1981|       |
 1982|      0|            component >>= shift;
 1983|      0|            png_ptr->palette[i].red = (png_byte)component;
 1984|      0|         }
 1985|       |
 1986|      0|      shift = 8 - png_ptr->sig_bit.green;
 1987|      0|      if (shift > 0 && shift < 8)
  ------------------
  |  Branch (1987:11): [True: 0, False: 0]
  |  Branch (1987:24): [True: 0, False: 0]
  ------------------
 1988|      0|         for (i=0; i<istop; ++i)
  ------------------
  |  Branch (1988:20): [True: 0, False: 0]
  ------------------
 1989|      0|         {
 1990|      0|            int component = png_ptr->palette[i].green;
 1991|       |
 1992|      0|            component >>= shift;
 1993|      0|            png_ptr->palette[i].green = (png_byte)component;
 1994|      0|         }
 1995|       |
 1996|      0|      shift = 8 - png_ptr->sig_bit.blue;
 1997|      0|      if (shift > 0 && shift < 8)
  ------------------
  |  Branch (1997:11): [True: 0, False: 0]
  |  Branch (1997:24): [True: 0, False: 0]
  ------------------
 1998|      0|         for (i=0; i<istop; ++i)
  ------------------
  |  Branch (1998:20): [True: 0, False: 0]
  ------------------
 1999|      0|         {
 2000|      0|            int component = png_ptr->palette[i].blue;
 2001|       |
 2002|      0|            component >>= shift;
 2003|      0|            png_ptr->palette[i].blue = (png_byte)component;
 2004|      0|         }
 2005|      0|   }
 2006|  1.64k|#endif /* READ_SHIFT */
 2007|  1.64k|}
OSS_FUZZ_png_read_transform_info:
 2015|  1.64k|{
 2016|  1.64k|   png_debug(1, "in png_read_transform_info");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
 2017|       |
 2018|  1.64k|#ifdef PNG_READ_EXPAND_SUPPORTED
 2019|  1.64k|   if ((png_ptr->transformations & PNG_EXPAND) != 0)
  ------------------
  |  |  646|  1.64k|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (2019:8): [True: 1.64k, False: 0]
  ------------------
 2020|  1.64k|   {
 2021|  1.64k|      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  1.64k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.64k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (2021:11): [True: 307, False: 1.34k]
  ------------------
 2022|    307|      {
 2023|       |         /* This check must match what actually happens in
 2024|       |          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
 2025|       |          * it is all opaque we must do the same (at present it does not.)
 2026|       |          */
 2027|    307|         if (png_ptr->num_trans > 0)
  ------------------
  |  Branch (2027:14): [True: 102, False: 205]
  ------------------
 2028|    102|            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
  ------------------
  |  |  669|    102|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|    102|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|    102|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
 2029|       |
 2030|    205|         else
 2031|    205|            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
  ------------------
  |  |  668|    205|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    205|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
 2032|       |
 2033|    307|         info_ptr->bit_depth = 8;
 2034|    307|         info_ptr->num_trans = 0;
 2035|       |
 2036|    307|         if (png_ptr->palette == NULL)
  ------------------
  |  Branch (2036:14): [True: 0, False: 307]
  ------------------
 2037|      0|            png_error (png_ptr, "Palette is NULL in indexed image");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 2038|    307|      }
 2039|  1.34k|      else
 2040|  1.34k|      {
 2041|  1.34k|         if (png_ptr->num_trans != 0)
  ------------------
  |  Branch (2041:14): [True: 415, False: 925]
  ------------------
 2042|    415|         {
 2043|    415|            if ((png_ptr->transformations & PNG_EXPAND_tRNS) != 0)
  ------------------
  |  |  660|    415|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  |  Branch (2043:17): [True: 415, False: 0]
  ------------------
 2044|    415|               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
  ------------------
  |  |  663|    415|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
 2045|    415|         }
 2046|  1.34k|         if (info_ptr->bit_depth < 8)
  ------------------
  |  Branch (2046:14): [True: 620, False: 720]
  ------------------
 2047|    620|            info_ptr->bit_depth = 8;
 2048|       |
 2049|  1.34k|         info_ptr->num_trans = 0;
 2050|  1.34k|      }
 2051|  1.64k|   }
 2052|  1.64k|#endif
 2053|       |
 2054|  1.64k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
 2055|  1.64k|   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
 2056|       |   /* The following is almost certainly wrong unless the background value is in
 2057|       |    * the screen space!
 2058|       |    */
 2059|  1.64k|   if ((png_ptr->transformations & PNG_COMPOSE) != 0)
  ------------------
  |  |  641|  1.64k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (2059:8): [True: 0, False: 1.64k]
  ------------------
 2060|      0|      info_ptr->background = png_ptr->background;
 2061|  1.64k|#endif
 2062|       |
 2063|  1.64k|#ifdef PNG_READ_GAMMA_SUPPORTED
 2064|       |   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
 2065|       |    * however it seems that the code in png_init_read_transformations, which has
 2066|       |    * been called before this from png_read_update_info->png_read_start_row
 2067|       |    * sometimes does the gamma transform and cancels the flag.
 2068|       |    *
 2069|       |    * TODO: this is confusing.  It only changes the result of png_get_gAMA and,
 2070|       |    * yes, it does return the value that the transformed data effectively has
 2071|       |    * but does any app really understand this?
 2072|       |    */
 2073|  1.64k|   info_ptr->gamma = png_ptr->file_gamma;
 2074|  1.64k|#endif
 2075|       |
 2076|  1.64k|   if (info_ptr->bit_depth == 16)
  ------------------
  |  Branch (2076:8): [True: 252, False: 1.39k]
  ------------------
 2077|    252|   {
 2078|    252|#  ifdef PNG_READ_16BIT_SUPPORTED
 2079|    252|#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
 2080|    252|         if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)
  ------------------
  |  |  661|    252|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (2080:14): [True: 252, False: 0]
  ------------------
 2081|    252|            info_ptr->bit_depth = 8;
 2082|    252|#     endif
 2083|       |
 2084|    252|#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
 2085|    252|         if ((png_ptr->transformations & PNG_16_TO_8) != 0)
  ------------------
  |  |  644|    252|#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
  ------------------
  |  Branch (2085:14): [True: 0, False: 252]
  ------------------
 2086|      0|            info_ptr->bit_depth = 8;
 2087|    252|#     endif
 2088|       |
 2089|       |#  else
 2090|       |      /* No 16-bit support: force chopping 16-bit input down to 8, in this case
 2091|       |       * the app program can chose if both APIs are available by setting the
 2092|       |       * correct scaling to use.
 2093|       |       */
 2094|       |#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
 2095|       |         /* For compatibility with previous versions use the strip method by
 2096|       |          * default.  This code works because if PNG_SCALE_16_TO_8 is already
 2097|       |          * set the code below will do that in preference to the chop.
 2098|       |          */
 2099|       |         png_ptr->transformations |= PNG_16_TO_8;
 2100|       |         info_ptr->bit_depth = 8;
 2101|       |#     else
 2102|       |
 2103|       |#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
 2104|       |            png_ptr->transformations |= PNG_SCALE_16_TO_8;
 2105|       |            info_ptr->bit_depth = 8;
 2106|       |#        else
 2107|       |
 2108|       |            CONFIGURATION ERROR: you must enable at least one 16 to 8 method
 2109|       |#        endif
 2110|       |#    endif
 2111|       |#endif /* !READ_16BIT */
 2112|    252|   }
 2113|       |
 2114|  1.64k|#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 2115|  1.64k|   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
  ------------------
  |  |  648|  1.64k|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
  |  Branch (2115:8): [True: 1.38k, False: 259]
  ------------------
 2116|  1.38k|      info_ptr->color_type = (png_byte)(info_ptr->color_type |
 2117|  1.38k|         PNG_COLOR_MASK_COLOR);
  ------------------
  |  |  662|  1.38k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
 2118|  1.64k|#endif
 2119|       |
 2120|  1.64k|#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 2121|  1.64k|   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
  ------------------
  |  |  657|  1.64k|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (2121:8): [True: 0, False: 1.64k]
  ------------------
 2122|      0|      info_ptr->color_type = (png_byte)(info_ptr->color_type &
 2123|      0|         ~PNG_COLOR_MASK_COLOR);
  ------------------
  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  ------------------
 2124|  1.64k|#endif
 2125|       |
 2126|  1.64k|#ifdef PNG_READ_QUANTIZE_SUPPORTED
 2127|  1.64k|   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)
  ------------------
  |  |  640|  1.64k|#define PNG_QUANTIZE            0x0040U
  ------------------
  |  Branch (2127:8): [True: 0, False: 1.64k]
  ------------------
 2128|      0|   {
 2129|      0|      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
  ------------------
  |  |  668|      0|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (2129:12): [True: 0, False: 0]
  ------------------
 2130|      0|          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
  ------------------
  |  |  669|      0|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (2130:11): [True: 0, False: 0]
  ------------------
 2131|      0|          png_ptr->palette_lookup != 0 && info_ptr->bit_depth == 8)
  ------------------
  |  Branch (2131:11): [True: 0, False: 0]
  |  Branch (2131:43): [True: 0, False: 0]
  ------------------
 2132|      0|      {
 2133|      0|         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
 2134|      0|      }
 2135|      0|   }
 2136|  1.64k|#endif
 2137|       |
 2138|  1.64k|#ifdef PNG_READ_EXPAND_16_SUPPORTED
 2139|  1.64k|   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&
  ------------------
  |  |  643|  1.64k|#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
  ------------------
  |  Branch (2139:8): [True: 0, False: 1.64k]
  ------------------
 2140|  1.64k|       info_ptr->bit_depth == 8 &&
  ------------------
  |  Branch (2140:8): [True: 0, False: 0]
  ------------------
 2141|  1.64k|       info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (2141:8): [True: 0, False: 0]
  ------------------
 2142|      0|   {
 2143|      0|      info_ptr->bit_depth = 16;
 2144|      0|   }
 2145|  1.64k|#endif
 2146|       |
 2147|  1.64k|#ifdef PNG_READ_PACK_SUPPORTED
 2148|  1.64k|   if ((png_ptr->transformations & PNG_PACK) != 0 &&
  ------------------
  |  |  636|  1.64k|#define PNG_PACK                0x0004U
  ------------------
  |  Branch (2148:8): [True: 544, False: 1.10k]
  ------------------
 2149|  1.64k|       (info_ptr->bit_depth < 8))
  ------------------
  |  Branch (2149:8): [True: 0, False: 544]
  ------------------
 2150|      0|      info_ptr->bit_depth = 8;
 2151|  1.64k|#endif
 2152|       |
 2153|  1.64k|   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  1.64k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.64k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (2153:8): [True: 0, False: 1.64k]
  ------------------
 2154|      0|      info_ptr->channels = 1;
 2155|       |
 2156|  1.64k|   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (2156:13): [True: 1.64k, False: 0]
  ------------------
 2157|  1.64k|      info_ptr->channels = 3;
 2158|       |
 2159|      0|   else
 2160|      0|      info_ptr->channels = 1;
 2161|       |
 2162|  1.64k|#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 2163|  1.64k|   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0)
  ------------------
  |  |  652|  1.64k|#define PNG_STRIP_ALPHA        0x40000U
  ------------------
  |  Branch (2163:8): [True: 0, False: 1.64k]
  ------------------
 2164|      0|   {
 2165|      0|      info_ptr->color_type = (png_byte)(info_ptr->color_type &
 2166|      0|         ~PNG_COLOR_MASK_ALPHA);
  ------------------
  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
 2167|      0|      info_ptr->num_trans = 0;
 2168|      0|   }
 2169|  1.64k|#endif
 2170|       |
 2171|  1.64k|   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
  ------------------
  |  |  663|  1.64k|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (2171:8): [True: 843, False: 804]
  ------------------
 2172|    843|      info_ptr->channels++;
 2173|       |
 2174|  1.64k|#ifdef PNG_READ_FILLER_SUPPORTED
 2175|       |   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
 2176|  1.64k|   if ((png_ptr->transformations & PNG_FILLER) != 0 &&
  ------------------
  |  |  649|  1.64k|#define PNG_FILLER              0x8000U
  ------------------
  |  Branch (2176:8): [True: 268, False: 1.37k]
  ------------------
 2177|  1.64k|       (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
  ------------------
  |  |  668|    536|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    268|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (2177:9): [True: 268, False: 0]
  ------------------
 2178|    268|       info_ptr->color_type == PNG_COLOR_TYPE_GRAY))
  ------------------
  |  |  666|      0|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (2178:8): [True: 0, False: 0]
  ------------------
 2179|    268|   {
 2180|    268|      info_ptr->channels++;
 2181|       |      /* If adding a true alpha channel not just filler */
 2182|    268|      if ((png_ptr->transformations & PNG_ADD_ALPHA) != 0)
  ------------------
  |  |  659|    268|#define PNG_ADD_ALPHA        0x1000000U /* Added to libpng-1.2.7 */
  ------------------
  |  Branch (2182:11): [True: 268, False: 0]
  ------------------
 2183|    268|         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
  ------------------
  |  |  663|    268|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
 2184|    268|   }
 2185|  1.64k|#endif
 2186|       |
 2187|  1.64k|#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
 2188|  1.64k|defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
 2189|  1.64k|   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
  ------------------
  |  |  654|  1.64k|#define PNG_USER_TRANSFORM    0x100000U
  ------------------
  |  Branch (2189:8): [True: 0, False: 1.64k]
  ------------------
 2190|      0|   {
 2191|      0|      if (png_ptr->user_transform_depth != 0)
  ------------------
  |  Branch (2191:11): [True: 0, False: 0]
  ------------------
 2192|      0|         info_ptr->bit_depth = png_ptr->user_transform_depth;
 2193|       |
 2194|      0|      if (png_ptr->user_transform_channels != 0)
  ------------------
  |  Branch (2194:11): [True: 0, False: 0]
  ------------------
 2195|      0|         info_ptr->channels = png_ptr->user_transform_channels;
 2196|      0|   }
 2197|  1.64k|#endif
 2198|       |
 2199|  1.64k|   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
 2200|  1.64k|       info_ptr->bit_depth);
 2201|       |
 2202|  1.64k|   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
  ------------------
  |  |  731|  1.64k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 1.64k, False: 0]
  |  |  ------------------
  |  |  732|  1.64k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  1.64k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 2203|       |
 2204|       |   /* Adding in 1.5.4: cache the above value in png_struct so that we can later
 2205|       |    * check in png_rowbytes that the user buffer won't get overwritten.  Note
 2206|       |    * that the field is not always set - if png_read_update_info isn't called
 2207|       |    * the application has to either not do any transforms or get the calculation
 2208|       |    * right itself.
 2209|       |    */
 2210|  1.64k|   png_ptr->info_rowbytes = info_ptr->rowbytes;
 2211|       |
 2212|       |#ifndef PNG_READ_EXPAND_SUPPORTED
 2213|       |   if (png_ptr != NULL)
 2214|       |      return;
 2215|       |#endif
 2216|  1.64k|}
OSS_FUZZ_png_do_read_transformations:
 4815|   204k|{
 4816|   204k|   png_debug(1, "in png_do_read_transformations");
  ------------------
  |  |  148|   204k|#  define png_debug(l, m) ((void)0)
  ------------------
 4817|       |
 4818|   204k|   if (png_ptr->row_buf == NULL)
  ------------------
  |  Branch (4818:8): [True: 0, False: 204k]
  ------------------
 4819|      0|   {
 4820|       |      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
 4821|       |       * error is incredibly rare and incredibly easy to debug without this
 4822|       |       * information.
 4823|       |       */
 4824|      0|      png_error(png_ptr, "NULL row buffer");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 4825|      0|   }
 4826|       |
 4827|       |   /* The following is debugging; prior to 1.5.4 the code was never compiled in;
 4828|       |    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro
 4829|       |    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.6 the new flag is set only for
 4830|       |    * all transformations, however in practice the ROW_INIT always gets done on
 4831|       |    * demand, if necessary.
 4832|       |    */
 4833|   204k|   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&
  ------------------
  |  |  685|   204k|#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (4833:8): [True: 204k, False: 0]
  ------------------
 4834|   204k|       (png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
  ------------------
  |  |  677|   204k|#define PNG_FLAG_ROW_INIT                 0x0040U
  ------------------
  |  Branch (4834:8): [True: 0, False: 204k]
  ------------------
 4835|      0|   {
 4836|       |      /* Application has failed to call either png_read_start_image() or
 4837|       |       * png_read_update_info() after setting transforms that expand pixels.
 4838|       |       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).
 4839|       |       */
 4840|      0|      png_error(png_ptr, "Uninitialized row");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 4841|      0|   }
 4842|       |
 4843|   204k|#ifdef PNG_READ_EXPAND_SUPPORTED
 4844|   204k|   if ((png_ptr->transformations & PNG_EXPAND) != 0)
  ------------------
  |  |  646|   204k|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (4844:8): [True: 204k, False: 0]
  ------------------
 4845|   204k|   {
 4846|   204k|      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|   204k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|   204k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|   204k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (4846:11): [True: 14.0k, False: 190k]
  ------------------
 4847|  14.0k|      {
 4848|       |#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
 4849|       |         if ((png_ptr->num_trans > 0) && (png_ptr->bit_depth == 8))
 4850|       |         {
 4851|       |            if (png_ptr->riffled_palette == NULL)
 4852|       |            {
 4853|       |               /* Initialize the accelerated palette expansion. */
 4854|       |               png_ptr->riffled_palette =
 4855|       |                   (png_bytep)png_malloc(png_ptr, 256 * 4);
 4856|       |               png_riffle_palette_neon(png_ptr);
 4857|       |            }
 4858|       |         }
 4859|       |#endif
 4860|  14.0k|         png_do_expand_palette(png_ptr, row_info, png_ptr->row_buf + 1,
 4861|  14.0k|             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
 4862|  14.0k|      }
 4863|       |
 4864|   190k|      else
 4865|   190k|      {
 4866|   190k|         if (png_ptr->num_trans != 0 &&
  ------------------
  |  Branch (4866:14): [True: 16.5k, False: 174k]
  ------------------
 4867|   190k|             (png_ptr->transformations & PNG_EXPAND_tRNS) != 0)
  ------------------
  |  |  660|  16.5k|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  |  Branch (4867:14): [True: 16.5k, False: 0]
  ------------------
 4868|  16.5k|            png_do_expand(row_info, png_ptr->row_buf + 1,
 4869|  16.5k|                &(png_ptr->trans_color));
 4870|       |
 4871|   174k|         else
 4872|   174k|            png_do_expand(row_info, png_ptr->row_buf + 1, NULL);
 4873|   190k|      }
 4874|   204k|   }
 4875|   204k|#endif
 4876|       |
 4877|   204k|#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 4878|   204k|   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
  ------------------
  |  |  652|   204k|#define PNG_STRIP_ALPHA        0x40000U
  ------------------
  |  Branch (4878:8): [True: 0, False: 204k]
  ------------------
 4879|   204k|       (png_ptr->transformations & PNG_COMPOSE) == 0 &&
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (4879:8): [True: 0, False: 0]
  ------------------
 4880|   204k|       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
  ------------------
  |  |  669|      0|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4880:9): [True: 0, False: 0]
  ------------------
 4881|      0|       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
  ------------------
  |  |  670|      0|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4881:8): [True: 0, False: 0]
  ------------------
 4882|      0|      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
  ------------------
  |  |   44|      0|#define png_do_strip_channel OSS_FUZZ_png_do_strip_channel
  ------------------
 4883|      0|          0 /* at_start == false, because SWAP_ALPHA happens later */);
 4884|   204k|#endif
 4885|       |
 4886|   204k|#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 4887|   204k|   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
  ------------------
  |  |  657|   204k|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (4887:8): [True: 0, False: 204k]
  ------------------
 4888|      0|   {
 4889|      0|      int rgb_error =
 4890|      0|          png_do_rgb_to_gray(png_ptr, row_info,
 4891|      0|              png_ptr->row_buf + 1);
 4892|       |
 4893|      0|      if (rgb_error != 0)
  ------------------
  |  Branch (4893:11): [True: 0, False: 0]
  ------------------
 4894|      0|      {
 4895|      0|         png_ptr->rgb_to_gray_status=1;
 4896|      0|         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
  ------------------
  |  |  657|      0|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (4896:14): [True: 0, False: 0]
  ------------------
 4897|      0|             PNG_RGB_TO_GRAY_WARN)
  ------------------
  |  |  656|      0|#define PNG_RGB_TO_GRAY_WARN  0x400000U
  ------------------
 4898|      0|            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 4899|       |
 4900|      0|         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
  ------------------
  |  |  657|      0|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (4900:14): [True: 0, False: 0]
  ------------------
 4901|      0|             PNG_RGB_TO_GRAY_ERR)
  ------------------
  |  |  655|      0|#define PNG_RGB_TO_GRAY_ERR   0x200000U
  ------------------
 4902|      0|            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 4903|      0|      }
 4904|      0|   }
 4905|   204k|#endif
 4906|       |
 4907|       |/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
 4908|       | *
 4909|       | *   In most cases, the "simple transparency" should be done prior to doing
 4910|       | *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
 4911|       | *   pixel is transparent.  You would also need to make sure that the
 4912|       | *   transparency information is upgraded to RGB.
 4913|       | *
 4914|       | *   To summarize, the current flow is:
 4915|       | *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
 4916|       | *                                   with background "in place" if transparent,
 4917|       | *                                   convert to RGB if necessary
 4918|       | *   - Gray + alpha -> composite with gray background and remove alpha bytes,
 4919|       | *                                   convert to RGB if necessary
 4920|       | *
 4921|       | *   To support RGB backgrounds for gray images we need:
 4922|       | *   - Gray + simple transparency -> convert to RGB + simple transparency,
 4923|       | *                                   compare 3 or 6 bytes and composite with
 4924|       | *                                   background "in place" if transparent
 4925|       | *                                   (3x compare/pixel compared to doing
 4926|       | *                                   composite with gray bkgrnd)
 4927|       | *   - Gray + alpha -> convert to RGB + alpha, composite with background and
 4928|       | *                                   remove alpha bytes (3x float
 4929|       | *                                   operations/pixel compared with composite
 4930|       | *                                   on gray background)
 4931|       | *
 4932|       | *  Greg's change will do this.  The reason it wasn't done before is for
 4933|       | *  performance, as this increases the per-pixel operations.  If we would check
 4934|       | *  in advance if the background was gray or RGB, and position the gray-to-RGB
 4935|       | *  transform appropriately, then it would save a lot of work/time.
 4936|       | */
 4937|       |
 4938|   204k|#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 4939|       |   /* If gray -> RGB, do so now only if background is non-gray; else do later
 4940|       |    * for performance reasons
 4941|       |    */
 4942|   204k|   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&
  ------------------
  |  |  648|   204k|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
  |  Branch (4942:8): [True: 178k, False: 26.7k]
  ------------------
 4943|   204k|       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) == 0)
  ------------------
  |  |  627|   178k|#define PNG_BACKGROUND_IS_GRAY     0x800U
  ------------------
  |  Branch (4943:8): [True: 178k, False: 0]
  ------------------
 4944|   178k|      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
 4945|   204k|#endif
 4946|       |
 4947|   204k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
 4948|   204k|   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
 4949|   204k|   if ((png_ptr->transformations & PNG_COMPOSE) != 0)
  ------------------
  |  |  641|   204k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (4949:8): [True: 0, False: 204k]
  ------------------
 4950|      0|      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
 4951|   204k|#endif
 4952|       |
 4953|   204k|#ifdef PNG_READ_GAMMA_SUPPORTED
 4954|   204k|   if ((png_ptr->transformations & PNG_GAMMA) != 0 &&
  ------------------
  |  |  647|   204k|#define PNG_GAMMA               0x2000U
  ------------------
  |  Branch (4954:8): [True: 9.96k, False: 194k]
  ------------------
 4955|   204k|#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 4956|       |      /* Because RGB_TO_GRAY does the gamma transform. */
 4957|   204k|      (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0 &&
  ------------------
  |  |  657|  9.96k|#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
  ------------------
  |  Branch (4957:7): [True: 9.96k, False: 0]
  ------------------
 4958|   204k|#endif
 4959|   204k|#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
 4960|   204k|   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
 4961|       |      /* Because PNG_COMPOSE does the gamma transform if there is something to
 4962|       |       * do (if there is an alpha channel or transparency.)
 4963|       |       */
 4964|   204k|       !((png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|  9.96k|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (4964:10): [True: 0, False: 9.96k]
  ------------------
 4965|  9.96k|       ((png_ptr->num_trans != 0) ||
  ------------------
  |  Branch (4965:9): [True: 0, False: 0]
  ------------------
 4966|      0|       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)) &&
  ------------------
  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (4966:8): [True: 0, False: 0]
  ------------------
 4967|   204k|#endif
 4968|       |      /* Because png_init_read_transformations transforms the palette, unless
 4969|       |       * RGB_TO_GRAY will do the transform.
 4970|       |       */
 4971|   204k|       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
  ------------------
  |  |  667|  9.96k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  9.96k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  9.96k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (4971:8): [True: 9.96k, False: 0]
  ------------------
 4972|  9.96k|      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
 4973|   204k|#endif
 4974|       |
 4975|   204k|#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
 4976|   204k|   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
  ------------------
  |  |  652|   204k|#define PNG_STRIP_ALPHA        0x40000U
  ------------------
  |  Branch (4976:8): [True: 0, False: 204k]
  ------------------
 4977|   204k|       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
  ------------------
  |  |  641|      0|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
  |  Branch (4977:8): [True: 0, False: 0]
  ------------------
 4978|   204k|       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
  ------------------
  |  |  669|      0|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4978:9): [True: 0, False: 0]
  ------------------
 4979|      0|       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
  ------------------
  |  |  670|      0|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4979:8): [True: 0, False: 0]
  ------------------
 4980|      0|      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
  ------------------
  |  |   44|      0|#define png_do_strip_channel OSS_FUZZ_png_do_strip_channel
  ------------------
 4981|      0|          0 /* at_start == false, because SWAP_ALPHA happens later */);
 4982|   204k|#endif
 4983|       |
 4984|   204k|#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
 4985|   204k|   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&
  ------------------
  |  |  658|   204k|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (4985:8): [True: 0, False: 204k]
  ------------------
 4986|   204k|       (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)
  ------------------
  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (4986:8): [True: 0, False: 0]
  ------------------
 4987|      0|      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
 4988|   204k|#endif
 4989|       |
 4990|   204k|#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
 4991|   204k|   if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)
  ------------------
  |  |  661|   204k|#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
  ------------------
  |  Branch (4991:8): [True: 179k, False: 25.5k]
  ------------------
 4992|   179k|      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
 4993|   204k|#endif
 4994|       |
 4995|   204k|#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
 4996|       |   /* There is no harm in doing both of these because only one has any effect,
 4997|       |    * by putting the 'scale' option first if the app asks for scale (either by
 4998|       |    * calling the API or in a TRANSFORM flag) this is what happens.
 4999|       |    */
 5000|   204k|   if ((png_ptr->transformations & PNG_16_TO_8) != 0)
  ------------------
  |  |  644|   204k|#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
  ------------------
  |  Branch (5000:8): [True: 0, False: 204k]
  ------------------
 5001|      0|      png_do_chop(row_info, png_ptr->row_buf + 1);
 5002|   204k|#endif
 5003|       |
 5004|   204k|#ifdef PNG_READ_QUANTIZE_SUPPORTED
 5005|   204k|   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)
  ------------------
  |  |  640|   204k|#define PNG_QUANTIZE            0x0040U
  ------------------
  |  Branch (5005:8): [True: 0, False: 204k]
  ------------------
 5006|      0|   {
 5007|      0|      png_do_quantize(row_info, png_ptr->row_buf + 1,
 5008|      0|          png_ptr->palette_lookup, png_ptr->quantize_index);
 5009|       |
 5010|      0|      if (row_info->rowbytes == 0)
  ------------------
  |  Branch (5010:11): [True: 0, False: 0]
  ------------------
 5011|      0|         png_error(png_ptr, "png_do_quantize returned rowbytes=0");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 5012|      0|   }
 5013|   204k|#endif /* READ_QUANTIZE */
 5014|       |
 5015|   204k|#ifdef PNG_READ_EXPAND_16_SUPPORTED
 5016|       |   /* Do the expansion now, after all the arithmetic has been done.  Notice
 5017|       |    * that previous transformations can handle the PNG_EXPAND_16 flag if this
 5018|       |    * is efficient (particularly true in the case of gamma correction, where
 5019|       |    * better accuracy results faster!)
 5020|       |    */
 5021|   204k|   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)
  ------------------
  |  |  643|   204k|#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
  ------------------
  |  Branch (5021:8): [True: 0, False: 204k]
  ------------------
 5022|      0|      png_do_expand_16(row_info, png_ptr->row_buf + 1);
 5023|   204k|#endif
 5024|       |
 5025|   204k|#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 5026|       |   /* NOTE: moved here in 1.5.4 (from much later in this list.) */
 5027|   204k|   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&
  ------------------
  |  |  648|   204k|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
  |  Branch (5027:8): [True: 178k, False: 26.7k]
  ------------------
 5028|   204k|       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) != 0)
  ------------------
  |  |  627|   178k|#define PNG_BACKGROUND_IS_GRAY     0x800U
  ------------------
  |  Branch (5028:8): [True: 0, False: 178k]
  ------------------
 5029|      0|      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
 5030|   204k|#endif
 5031|       |
 5032|   204k|#ifdef PNG_READ_INVERT_SUPPORTED
 5033|   204k|   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
  ------------------
  |  |  639|   204k|#define PNG_INVERT_MONO         0x0020U
  ------------------
  |  Branch (5033:8): [True: 0, False: 204k]
  ------------------
 5034|      0|      png_do_invert(row_info, png_ptr->row_buf + 1);
  ------------------
  |  |   47|      0|#define png_do_invert OSS_FUZZ_png_do_invert
  ------------------
 5035|   204k|#endif
 5036|       |
 5037|   204k|#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
 5038|   204k|   if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
  ------------------
  |  |  653|   204k|#define PNG_INVERT_ALPHA       0x80000U
  ------------------
  |  Branch (5038:8): [True: 0, False: 204k]
  ------------------
 5039|      0|      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
 5040|   204k|#endif
 5041|       |
 5042|   204k|#ifdef PNG_READ_SHIFT_SUPPORTED
 5043|   204k|   if ((png_ptr->transformations & PNG_SHIFT) != 0)
  ------------------
  |  |  637|   204k|#define PNG_SHIFT               0x0008U
  ------------------
  |  Branch (5043:8): [True: 0, False: 204k]
  ------------------
 5044|      0|      png_do_unshift(row_info, png_ptr->row_buf + 1,
 5045|      0|          &(png_ptr->shift));
 5046|   204k|#endif
 5047|       |
 5048|   204k|#ifdef PNG_READ_PACK_SUPPORTED
 5049|   204k|   if ((png_ptr->transformations & PNG_PACK) != 0)
  ------------------
  |  |  636|   204k|#define PNG_PACK                0x0004U
  ------------------
  |  Branch (5049:8): [True: 10.0k, False: 194k]
  ------------------
 5050|  10.0k|      png_do_unpack(row_info, png_ptr->row_buf + 1);
 5051|   204k|#endif
 5052|       |
 5053|   204k|#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
 5054|       |   /* Added at libpng-1.5.10 */
 5055|   204k|   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
  ------------------
  |  |  667|   409k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|   204k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|   204k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (5055:8): [True: 0, False: 204k]
  ------------------
 5056|   204k|       png_ptr->num_palette_max >= 0)
  ------------------
  |  Branch (5056:8): [True: 0, False: 0]
  ------------------
 5057|      0|      png_do_check_palette_indexes(png_ptr, row_info);
  ------------------
  |  |   73|      0|#define png_do_check_palette_indexes OSS_FUZZ_png_do_check_palette_indexes
  ------------------
 5058|   204k|#endif
 5059|       |
 5060|   204k|#ifdef PNG_READ_BGR_SUPPORTED
 5061|   204k|   if ((png_ptr->transformations & PNG_BGR) != 0)
  ------------------
  |  |  634|   204k|#define PNG_BGR                 0x0001U
  ------------------
  |  Branch (5061:8): [True: 0, False: 204k]
  ------------------
 5062|      0|      png_do_bgr(row_info, png_ptr->row_buf + 1);
  ------------------
  |  |   48|      0|#define png_do_bgr OSS_FUZZ_png_do_bgr
  ------------------
 5063|   204k|#endif
 5064|       |
 5065|   204k|#ifdef PNG_READ_PACKSWAP_SUPPORTED
 5066|   204k|   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|   204k|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (5066:8): [True: 0, False: 204k]
  ------------------
 5067|      0|      png_do_packswap(row_info, png_ptr->row_buf + 1);
  ------------------
  |  |   46|      0|#define png_do_packswap OSS_FUZZ_png_do_packswap
  ------------------
 5068|   204k|#endif
 5069|       |
 5070|   204k|#ifdef PNG_READ_FILLER_SUPPORTED
 5071|   204k|   if ((png_ptr->transformations & PNG_FILLER) != 0)
  ------------------
  |  |  649|   204k|#define PNG_FILLER              0x8000U
  ------------------
  |  Branch (5071:8): [True: 11.5k, False: 193k]
  ------------------
 5072|  11.5k|      png_do_read_filler(row_info, png_ptr->row_buf + 1,
 5073|  11.5k|          (png_uint_32)png_ptr->filler, png_ptr->flags);
 5074|   204k|#endif
 5075|       |
 5076|   204k|#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
 5077|   204k|   if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0)
  ------------------
  |  |  651|   204k|#define PNG_SWAP_ALPHA         0x20000U
  ------------------
  |  Branch (5077:8): [True: 0, False: 204k]
  ------------------
 5078|      0|      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
 5079|   204k|#endif
 5080|       |
 5081|   204k|#ifdef PNG_READ_16BIT_SUPPORTED
 5082|   204k|#ifdef PNG_READ_SWAP_SUPPORTED
 5083|   204k|   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
  ------------------
  |  |  638|   204k|#define PNG_SWAP_BYTES          0x0010U
  ------------------
  |  Branch (5083:8): [True: 0, False: 204k]
  ------------------
 5084|      0|      png_do_swap(row_info, png_ptr->row_buf + 1);
  ------------------
  |  |   45|      0|#define png_do_swap OSS_FUZZ_png_do_swap
  ------------------
 5085|   204k|#endif
 5086|   204k|#endif
 5087|       |
 5088|   204k|#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
 5089|   204k|   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
  ------------------
  |  |  654|   204k|#define PNG_USER_TRANSFORM    0x100000U
  ------------------
  |  Branch (5089:8): [True: 0, False: 204k]
  ------------------
 5090|      0|   {
 5091|      0|      if (png_ptr->read_user_transform_fn != NULL)
  ------------------
  |  Branch (5091:11): [True: 0, False: 0]
  ------------------
 5092|      0|         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
 5093|      0|             (png_ptr,     /* png_ptr */
 5094|      0|             row_info,     /* row_info: */
 5095|       |                /*  png_uint_32 width;       width of row */
 5096|       |                /*  size_t rowbytes;         number of bytes in row */
 5097|       |                /*  png_byte color_type;     color type of pixels */
 5098|       |                /*  png_byte bit_depth;      bit depth of samples */
 5099|       |                /*  png_byte channels;       number of channels (1-4) */
 5100|       |                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
 5101|      0|             png_ptr->row_buf + 1);    /* start of pixel data for row */
 5102|      0|#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
 5103|      0|      if (png_ptr->user_transform_depth != 0)
  ------------------
  |  Branch (5103:11): [True: 0, False: 0]
  ------------------
 5104|      0|         row_info->bit_depth = png_ptr->user_transform_depth;
 5105|       |
 5106|      0|      if (png_ptr->user_transform_channels != 0)
  ------------------
  |  Branch (5106:11): [True: 0, False: 0]
  ------------------
 5107|      0|         row_info->channels = png_ptr->user_transform_channels;
 5108|      0|#endif
 5109|      0|      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
 5110|      0|          row_info->channels);
 5111|       |
 5112|      0|      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
  ------------------
  |  |  731|      0|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  732|      0|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|      0|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 5113|      0|   }
 5114|   204k|#endif
 5115|   204k|}
pngrtran.c:png_rtran_ok:
  110|  7.77k|{
  111|  7.77k|   if (png_ptr != NULL)
  ------------------
  |  Branch (111:8): [True: 7.77k, False: 0]
  ------------------
  112|  7.77k|   {
  113|  7.77k|      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)
  ------------------
  |  |  677|  7.77k|#define PNG_FLAG_ROW_INIT                 0x0040U
  ------------------
  |  Branch (113:11): [True: 0, False: 7.77k]
  ------------------
  114|      0|         png_app_error(png_ptr,
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
  115|      0|             "invalid after png_start_read_image or png_read_update_info");
  116|       |
  117|  7.77k|      else if (need_IHDR && (png_ptr->mode & PNG_HAVE_IHDR) == 0)
  ------------------
  |  |  642|      0|#define PNG_HAVE_IHDR  0x01
  ------------------
  |  Branch (117:16): [True: 0, False: 7.77k]
  |  Branch (117:29): [True: 0, False: 0]
  ------------------
  118|      0|         png_app_error(png_ptr, "invalid before the PNG header has been read");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
  119|       |
  120|  7.77k|      else
  121|  7.77k|      {
  122|       |         /* Turn on failure to initialize correctly for all transforms. */
  123|  7.77k|         png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
  ------------------
  |  |  685|  7.77k|#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000U /* Added to libpng-1.5.4 */
  ------------------
  124|       |
  125|  7.77k|         return 1; /* Ok */
  126|  7.77k|      }
  127|  7.77k|   }
  128|       |
  129|      0|   return 0; /* no png_error possible! */
  130|  7.77k|}
pngrtran.c:translate_gamma_flags:
  274|  1.07k|{
  275|       |   /* Check for flag values.  The main reason for having the old Mac value as a
  276|       |    * flag is that it is pretty near impossible to work out what the correct
  277|       |    * value is from Apple documentation - a working Mac system is needed to
  278|       |    * discover the value!
  279|       |    */
  280|  1.07k|   if (output_gamma == PNG_DEFAULT_sRGB ||
  ------------------
  |  | 1160|  2.14k|#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
  ------------------
  |  Branch (280:8): [True: 1.02k, False: 52]
  ------------------
  281|  1.07k|      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
  ------------------
  |  |  654|     52|#define PNG_FP_1    100000
  ------------------
                    output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
  ------------------
  |  | 1160|     52|#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
  ------------------
  |  Branch (281:7): [True: 0, False: 52]
  ------------------
  282|  1.02k|   {
  283|  1.02k|      if (is_screen != 0)
  ------------------
  |  Branch (283:11): [True: 1.02k, False: 0]
  ------------------
  284|  1.02k|         output_gamma = PNG_GAMMA_sRGB;
  ------------------
  |  | 1162|  1.02k|#define PNG_GAMMA_sRGB   220000   /* Television standards--matches sRGB gamma */
  ------------------
  285|      0|      else
  286|      0|         output_gamma = PNG_GAMMA_sRGB_INVERSE;
  ------------------
  |  |  976|      0|#define PNG_GAMMA_sRGB_INVERSE 45455
  ------------------
  287|  1.02k|   }
  288|       |
  289|     52|   else if (output_gamma == PNG_GAMMA_MAC_18 ||
  ------------------
  |  | 1161|    104|#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
  ------------------
  |  Branch (289:13): [True: 0, False: 52]
  ------------------
  290|     52|      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
  ------------------
  |  |  654|     52|#define PNG_FP_1    100000
  ------------------
                    output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
  ------------------
  |  | 1161|     52|#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
  ------------------
  |  Branch (290:7): [True: 0, False: 52]
  ------------------
  291|      0|   {
  292|      0|      if (is_screen != 0)
  ------------------
  |  Branch (292:11): [True: 0, False: 0]
  ------------------
  293|      0|         output_gamma = PNG_GAMMA_MAC_OLD;
  ------------------
  |  |  974|      0|#define PNG_GAMMA_MAC_OLD 151724  /* Assume '1.8' is really 2.2/1.45! */
  ------------------
  294|      0|      else
  295|      0|         output_gamma = PNG_GAMMA_MAC_INVERSE;
  ------------------
  |  |  975|      0|#define PNG_GAMMA_MAC_INVERSE 65909
  ------------------
  296|      0|   }
  297|       |
  298|  1.07k|   return output_gamma;
  299|  1.07k|}
pngrtran.c:unsupported_gamma:
  327|  1.07k|{
  328|       |   /* Validate a gamma value to ensure it is in a reasonable range.  The value
  329|       |    * is expected to be 1 or greater, but this range test allows for some
  330|       |    * viewing correction values.  The intent is to weed out the API users
  331|       |    * who might use the inverse of the gamma value accidentally!
  332|       |    *
  333|       |    * 1.6.47: apply the test in png_set_gamma as well but only warn and return
  334|       |    * false if it fires.
  335|       |    *
  336|       |    * TODO: 1.8: make this an app_error in png_set_gamma as well.
  337|       |    */
  338|  1.07k|   if (gamma < PNG_LIB_GAMMA_MIN || gamma > PNG_LIB_GAMMA_MAX)
  ------------------
  |  |  988|  2.14k|#define PNG_LIB_GAMMA_MIN 1000
  ------------------
                 if (gamma < PNG_LIB_GAMMA_MIN || gamma > PNG_LIB_GAMMA_MAX)
  ------------------
  |  |  989|  1.07k|#define PNG_LIB_GAMMA_MAX 10000000
  ------------------
  |  Branch (338:8): [True: 0, False: 1.07k]
  |  Branch (338:37): [True: 0, False: 1.07k]
  ------------------
  339|      0|   {
  340|      0|#     define msg "gamma out of supported range"
  341|      0|      if (warn)
  ------------------
  |  Branch (341:11): [True: 0, False: 0]
  ------------------
  342|      0|         png_app_warning(png_ptr, msg);
  ------------------
  |  |   81|      0|#define png_app_warning OSS_FUZZ_png_app_warning
  ------------------
                       png_app_warning(png_ptr, msg);
  ------------------
  |  |  340|      0|#     define msg "gamma out of supported range"
  ------------------
  343|      0|      else
  344|      0|         png_app_error(png_ptr, msg);
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
                       png_app_error(png_ptr, msg);
  ------------------
  |  |  340|      0|#     define msg "gamma out of supported range"
  ------------------
  345|      0|      return 1;
  346|      0|#     undef msg
  347|      0|   }
  348|       |
  349|  1.07k|   return 0;
  350|  1.07k|}
pngrtran.c:png_init_gamma_values:
 1366|  1.64k|{
 1367|       |   /* The following temporary indicates if overall gamma correction is
 1368|       |    * required.
 1369|       |    */
 1370|  1.64k|   int gamma_correction = 0;
 1371|  1.64k|   png_fixed_point file_gamma, screen_gamma;
 1372|       |
 1373|       |   /* Resolve the file_gamma.  See above: if png_ptr::screen_gamma is set
 1374|       |    * file_gamma will always be set here:
 1375|       |    */
 1376|  1.64k|   file_gamma = png_resolve_file_gamma(png_ptr);
  ------------------
  |  |   92|  1.64k|#define png_resolve_file_gamma OSS_FUZZ_png_resolve_file_gamma
  ------------------
 1377|  1.64k|   screen_gamma = png_ptr->screen_gamma;
 1378|       |
 1379|  1.64k|   if (file_gamma > 0) /* file has been set */
  ------------------
  |  Branch (1379:8): [True: 984, False: 665]
  ------------------
 1380|    984|   {
 1381|    984|      if (screen_gamma > 0) /* screen set too */
  ------------------
  |  Branch (1381:11): [True: 537, False: 447]
  ------------------
 1382|    537|         gamma_correction = png_gamma_threshold(file_gamma, screen_gamma);
 1383|       |
 1384|    447|      else
 1385|       |         /* Assume the output matches the input; a long time default behavior
 1386|       |          * of libpng, although the standard has nothing to say about this.
 1387|       |          */
 1388|    447|         screen_gamma = png_reciprocal(file_gamma);
  ------------------
  |  |   89|    447|#define png_reciprocal OSS_FUZZ_png_reciprocal
  ------------------
 1389|    984|   }
 1390|       |
 1391|    665|   else /* both unset, prevent corrections: */
 1392|    665|      file_gamma = screen_gamma = PNG_FP_1;
  ------------------
  |  |  654|    665|#define PNG_FP_1    100000
  ------------------
 1393|       |
 1394|  1.64k|   png_ptr->file_gamma = file_gamma;
 1395|  1.64k|   png_ptr->screen_gamma = screen_gamma;
 1396|  1.64k|   return gamma_correction;
 1397|       |
 1398|  1.64k|}
pngrtran.c:png_gamma_threshold:
 1130|    537|{
 1131|       |   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
 1132|       |    * correction as a difference of the overall transform from 1.0
 1133|       |    *
 1134|       |    * We want to compare the threshold with s*f - 1, if we get
 1135|       |    * overflow here it is because of wacky gamma values so we
 1136|       |    * turn on processing anyway.
 1137|       |    */
 1138|    537|   png_fixed_point gtest;
 1139|    537|   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
  ------------------
  |  |   88|    537|#define png_muldiv OSS_FUZZ_png_muldiv
  ------------------
                 return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
  ------------------
  |  |  654|    537|#define PNG_FP_1    100000
  ------------------
  |  Branch (1139:11): [True: 0, False: 537]
  ------------------
 1140|    537|       png_gamma_significant(gtest);
  ------------------
  |  |   91|    537|#define png_gamma_significant OSS_FUZZ_png_gamma_significant
  ------------------
  |  Branch (1140:8): [True: 162, False: 375]
  ------------------
 1141|    537|}
pngrtran.c:png_init_palette_transformations:
 1155|    307|{
 1156|       |   /* Called to handle the (input) palette case.  In png_do_read_transformations
 1157|       |    * the first step is to expand the palette if requested, so this code must
 1158|       |    * take care to only make changes that are invariant with respect to the
 1159|       |    * palette expansion, or only do them if there is no expansion.
 1160|       |    *
 1161|       |    * STRIP_ALPHA has already been handled in the caller (by setting num_trans
 1162|       |    * to 0.)
 1163|       |    */
 1164|    307|   int input_has_alpha = 0;
 1165|    307|   int input_has_transparency = 0;
 1166|       |
 1167|    307|   if (png_ptr->num_trans > 0)
  ------------------
  |  Branch (1167:8): [True: 102, False: 205]
  ------------------
 1168|    102|   {
 1169|    102|      int i;
 1170|       |
 1171|       |      /* Ignore if all the entries are opaque (unlikely!) */
 1172|    241|      for (i=0; i<png_ptr->num_trans; ++i)
  ------------------
  |  Branch (1172:17): [True: 195, False: 46]
  ------------------
 1173|    195|      {
 1174|    195|         if (png_ptr->trans_alpha[i] == 255)
  ------------------
  |  Branch (1174:14): [True: 53, False: 142]
  ------------------
 1175|     53|            continue;
 1176|    142|         else if (png_ptr->trans_alpha[i] == 0)
  ------------------
  |  Branch (1176:19): [True: 86, False: 56]
  ------------------
 1177|     86|            input_has_transparency = 1;
 1178|     56|         else
 1179|     56|         {
 1180|     56|            input_has_transparency = 1;
 1181|     56|            input_has_alpha = 1;
 1182|     56|            break;
 1183|     56|         }
 1184|    195|      }
 1185|    102|   }
 1186|       |
 1187|       |   /* If no alpha we can optimize. */
 1188|    307|   if (input_has_alpha == 0)
  ------------------
  |  Branch (1188:8): [True: 251, False: 56]
  ------------------
 1189|    251|   {
 1190|       |      /* Any alpha means background and associative alpha processing is
 1191|       |       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA
 1192|       |       * and ENCODE_ALPHA are irrelevant.
 1193|       |       */
 1194|    251|      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|    251|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
 1195|    251|      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|    251|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
 1196|       |
 1197|    251|      if (input_has_transparency == 0)
  ------------------
  |  Branch (1197:11): [True: 205, False: 46]
  ------------------
 1198|    205|         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
  ------------------
  |  |  641|    205|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
                       png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
  ------------------
  |  |  642|    205|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
 1199|    251|   }
 1200|       |
 1201|    307|#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
 1202|       |   /* png_set_background handling - deals with the complexity of whether the
 1203|       |    * background color is in the file format or the screen format in the case
 1204|       |    * where an 'expand' will happen.
 1205|       |    */
 1206|       |
 1207|       |   /* The following code cannot be entered in the alpha pre-multiplication case
 1208|       |    * because PNG_BACKGROUND_EXPAND is cancelled below.
 1209|       |    */
 1210|    307|   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&
  ------------------
  |  |  642|    307|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  |  Branch (1210:8): [True: 0, False: 307]
  ------------------
 1211|    307|       (png_ptr->transformations & PNG_EXPAND) != 0)
  ------------------
  |  |  646|      0|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (1211:8): [True: 0, False: 0]
  ------------------
 1212|      0|   {
 1213|      0|      {
 1214|      0|         png_ptr->background.red   =
 1215|      0|             png_ptr->palette[png_ptr->background.index].red;
 1216|      0|         png_ptr->background.green =
 1217|      0|             png_ptr->palette[png_ptr->background.index].green;
 1218|      0|         png_ptr->background.blue  =
 1219|      0|             png_ptr->palette[png_ptr->background.index].blue;
 1220|       |
 1221|      0|#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
 1222|      0|         if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
  ------------------
  |  |  653|      0|#define PNG_INVERT_ALPHA       0x80000U
  ------------------
  |  Branch (1222:14): [True: 0, False: 0]
  ------------------
 1223|      0|         {
 1224|      0|            if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
  ------------------
  |  |  660|      0|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  |  Branch (1224:17): [True: 0, False: 0]
  ------------------
 1225|      0|            {
 1226|       |               /* Invert the alpha channel (in tRNS) unless the pixels are
 1227|       |                * going to be expanded, in which case leave it for later
 1228|       |                */
 1229|      0|               int i, istop = png_ptr->num_trans;
 1230|       |
 1231|      0|               for (i = 0; i < istop; i++)
  ------------------
  |  Branch (1231:28): [True: 0, False: 0]
  ------------------
 1232|      0|                  png_ptr->trans_alpha[i] =
 1233|      0|                      (png_byte)(255 - png_ptr->trans_alpha[i]);
 1234|      0|            }
 1235|      0|         }
 1236|      0|#endif /* READ_INVERT_ALPHA */
 1237|      0|      }
 1238|      0|   } /* background expand and (therefore) no alpha association. */
 1239|    307|#endif /* READ_EXPAND && READ_BACKGROUND */
 1240|    307|}
pngrtran.c:png_init_rgb_transformations:
 1244|  1.34k|{
 1245|       |   /* Added to libpng-1.5.4: check the color type to determine whether there
 1246|       |    * is any alpha or transparency in the image and simply cancel the
 1247|       |    * background and alpha mode stuff if there isn't.
 1248|       |    */
 1249|  1.34k|   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;
  ------------------
  |  |  663|  1.34k|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
 1250|  1.34k|   int input_has_transparency = png_ptr->num_trans > 0;
 1251|       |
 1252|       |   /* If no alpha we can optimize. */
 1253|  1.34k|   if (input_has_alpha == 0)
  ------------------
  |  Branch (1253:8): [True: 1.01k, False: 327]
  ------------------
 1254|  1.01k|   {
 1255|       |      /* Any alpha means background and associative alpha processing is
 1256|       |       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA
 1257|       |       * and ENCODE_ALPHA are irrelevant.
 1258|       |       */
 1259|  1.01k|#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
 1260|  1.01k|         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
  ------------------
  |  |  658|  1.01k|#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
  ------------------
 1261|  1.01k|         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
  ------------------
  |  |  684|  1.01k|#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
  ------------------
 1262|  1.01k|#     endif
 1263|       |
 1264|  1.01k|      if (input_has_transparency == 0)
  ------------------
  |  Branch (1264:11): [True: 599, False: 416]
  ------------------
 1265|    599|         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
  ------------------
  |  |  641|    599|#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
  ------------------
                       png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
  ------------------
  |  |  642|    599|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
 1266|  1.01k|   }
 1267|       |
 1268|  1.34k|#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
 1269|       |   /* png_set_background handling - deals with the complexity of whether the
 1270|       |    * background color is in the file format or the screen format in the case
 1271|       |    * where an 'expand' will happen.
 1272|       |    */
 1273|       |
 1274|       |   /* The following code cannot be entered in the alpha pre-multiplication case
 1275|       |    * because PNG_BACKGROUND_EXPAND is cancelled below.
 1276|       |    */
 1277|  1.34k|   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&
  ------------------
  |  |  642|  1.34k|#define PNG_BACKGROUND_EXPAND   0x0100U
  ------------------
  |  Branch (1277:8): [True: 0, False: 1.34k]
  ------------------
 1278|  1.34k|       (png_ptr->transformations & PNG_EXPAND) != 0 &&
  ------------------
  |  |  646|      0|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (1278:8): [True: 0, False: 0]
  ------------------
 1279|  1.34k|       (png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
  ------------------
  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1279:8): [True: 0, False: 0]
  ------------------
 1280|       |       /* i.e., GRAY or GRAY_ALPHA */
 1281|      0|   {
 1282|      0|      {
 1283|       |         /* Expand background and tRNS chunks */
 1284|      0|         int gray = png_ptr->background.gray;
 1285|      0|         int trans_gray = png_ptr->trans_color.gray;
 1286|       |
 1287|      0|         switch (png_ptr->bit_depth)
 1288|      0|         {
 1289|      0|            case 1:
  ------------------
  |  Branch (1289:13): [True: 0, False: 0]
  ------------------
 1290|      0|               gray *= 0xff;
 1291|      0|               trans_gray *= 0xff;
 1292|      0|               break;
 1293|       |
 1294|      0|            case 2:
  ------------------
  |  Branch (1294:13): [True: 0, False: 0]
  ------------------
 1295|      0|               gray *= 0x55;
 1296|      0|               trans_gray *= 0x55;
 1297|      0|               break;
 1298|       |
 1299|      0|            case 4:
  ------------------
  |  Branch (1299:13): [True: 0, False: 0]
  ------------------
 1300|      0|               gray *= 0x11;
 1301|      0|               trans_gray *= 0x11;
 1302|      0|               break;
 1303|       |
 1304|      0|            default:
  ------------------
  |  Branch (1304:13): [True: 0, False: 0]
  ------------------
 1305|       |
 1306|      0|            case 8:
  ------------------
  |  Branch (1306:13): [True: 0, False: 0]
  ------------------
 1307|       |               /* FALLTHROUGH */ /*  (Already 8 bits) */
 1308|       |
 1309|      0|            case 16:
  ------------------
  |  Branch (1309:13): [True: 0, False: 0]
  ------------------
 1310|       |               /* Already a full 16 bits */
 1311|      0|               break;
 1312|      0|         }
 1313|       |
 1314|      0|         png_ptr->background.red = png_ptr->background.green =
 1315|      0|            png_ptr->background.blue = (png_uint_16)gray;
 1316|       |
 1317|      0|         if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
  ------------------
  |  |  660|      0|#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
  ------------------
  |  Branch (1317:14): [True: 0, False: 0]
  ------------------
 1318|      0|         {
 1319|      0|            png_ptr->trans_color.red = png_ptr->trans_color.green =
 1320|      0|               png_ptr->trans_color.blue = (png_uint_16)trans_gray;
 1321|      0|         }
 1322|      0|      }
 1323|      0|   } /* background expand and (therefore) no alpha association. */
 1324|  1.34k|#endif /* READ_EXPAND && READ_BACKGROUND */
 1325|  1.34k|}
pngrtran.c:png_do_expand_palette:
 4286|  14.0k|{
 4287|  14.0k|   int shift, value;
 4288|  14.0k|   png_bytep sp, dp;
 4289|  14.0k|   png_uint_32 i;
 4290|  14.0k|   png_uint_32 row_width=row_info->width;
 4291|       |
 4292|  14.0k|   png_debug(1, "in png_do_expand_palette");
  ------------------
  |  |  148|  14.0k|#  define png_debug(l, m) ((void)0)
  ------------------
 4293|       |
 4294|  14.0k|   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  14.0k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  14.0k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  14.0k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (4294:8): [True: 14.0k, False: 0]
  ------------------
 4295|  14.0k|   {
 4296|  14.0k|      if (row_info->bit_depth < 8)
  ------------------
  |  Branch (4296:11): [True: 3.19k, False: 10.9k]
  ------------------
 4297|  3.19k|      {
 4298|  3.19k|         switch (row_info->bit_depth)
 4299|  3.19k|         {
 4300|  1.27k|            case 1:
  ------------------
  |  Branch (4300:13): [True: 1.27k, False: 1.91k]
  ------------------
 4301|  1.27k|            {
 4302|  1.27k|               sp = row + (size_t)((row_width - 1) >> 3);
 4303|  1.27k|               dp = row + (size_t)row_width - 1;
 4304|  1.27k|               shift = 7 - (int)((row_width + 7) & 0x07);
 4305|  49.8k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4305:28): [True: 48.5k, False: 1.27k]
  ------------------
 4306|  48.5k|               {
 4307|  48.5k|                  if ((*sp >> shift) & 0x01)
  ------------------
  |  Branch (4307:23): [True: 20.9k, False: 27.5k]
  ------------------
 4308|  20.9k|                     *dp = 1;
 4309|       |
 4310|  27.5k|                  else
 4311|  27.5k|                     *dp = 0;
 4312|       |
 4313|  48.5k|                  if (shift == 7)
  ------------------
  |  Branch (4313:23): [True: 6.14k, False: 42.4k]
  ------------------
 4314|  6.14k|                  {
 4315|  6.14k|                     shift = 0;
 4316|  6.14k|                     sp--;
 4317|  6.14k|                  }
 4318|       |
 4319|  42.4k|                  else
 4320|  42.4k|                     shift++;
 4321|       |
 4322|  48.5k|                  dp--;
 4323|  48.5k|               }
 4324|  1.27k|               break;
 4325|      0|            }
 4326|       |
 4327|    867|            case 2:
  ------------------
  |  Branch (4327:13): [True: 867, False: 2.32k]
  ------------------
 4328|    867|            {
 4329|    867|               sp = row + (size_t)((row_width - 1) >> 2);
 4330|    867|               dp = row + (size_t)row_width - 1;
 4331|    867|               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
 4332|  41.2k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4332:28): [True: 40.3k, False: 867]
  ------------------
 4333|  40.3k|               {
 4334|  40.3k|                  value = (*sp >> shift) & 0x03;
 4335|  40.3k|                  *dp = (png_byte)value;
 4336|  40.3k|                  if (shift == 6)
  ------------------
  |  Branch (4336:23): [True: 10.0k, False: 30.2k]
  ------------------
 4337|  10.0k|                  {
 4338|  10.0k|                     shift = 0;
 4339|  10.0k|                     sp--;
 4340|  10.0k|                  }
 4341|       |
 4342|  30.2k|                  else
 4343|  30.2k|                     shift += 2;
 4344|       |
 4345|  40.3k|                  dp--;
 4346|  40.3k|               }
 4347|    867|               break;
 4348|      0|            }
 4349|       |
 4350|  1.05k|            case 4:
  ------------------
  |  Branch (4350:13): [True: 1.05k, False: 2.14k]
  ------------------
 4351|  1.05k|            {
 4352|  1.05k|               sp = row + (size_t)((row_width - 1) >> 1);
 4353|  1.05k|               dp = row + (size_t)row_width - 1;
 4354|  1.05k|               shift = (int)((row_width & 0x01) << 2);
 4355|  55.2k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4355:28): [True: 54.1k, False: 1.05k]
  ------------------
 4356|  54.1k|               {
 4357|  54.1k|                  value = (*sp >> shift) & 0x0f;
 4358|  54.1k|                  *dp = (png_byte)value;
 4359|  54.1k|                  if (shift == 4)
  ------------------
  |  Branch (4359:23): [True: 27.1k, False: 27.0k]
  ------------------
 4360|  27.1k|                  {
 4361|  27.1k|                     shift = 0;
 4362|  27.1k|                     sp--;
 4363|  27.1k|                  }
 4364|       |
 4365|  27.0k|                  else
 4366|  27.0k|                     shift += 4;
 4367|       |
 4368|  54.1k|                  dp--;
 4369|  54.1k|               }
 4370|  1.05k|               break;
 4371|      0|            }
 4372|       |
 4373|      0|            default:
  ------------------
  |  Branch (4373:13): [True: 0, False: 3.19k]
  ------------------
 4374|      0|               break;
 4375|  3.19k|         }
 4376|  3.19k|         row_info->bit_depth = 8;
 4377|  3.19k|         row_info->pixel_depth = 8;
 4378|  3.19k|         row_info->rowbytes = row_width;
 4379|  3.19k|      }
 4380|       |
 4381|  14.0k|      if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4381:11): [True: 14.0k, False: 0]
  ------------------
 4382|  14.0k|      {
 4383|  14.0k|         {
 4384|  14.0k|            if (num_trans > 0)
  ------------------
  |  Branch (4384:17): [True: 3.21k, False: 10.8k]
  ------------------
 4385|  3.21k|            {
 4386|  3.21k|               sp = row + (size_t)row_width - 1;
 4387|  3.21k|               dp = row + ((size_t)row_width << 2) - 1;
 4388|       |
 4389|  3.21k|               i = 0;
 4390|       |#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
 4391|       |               if (png_ptr->riffled_palette != NULL)
 4392|       |               {
 4393|       |                  /* The RGBA optimization works with png_ptr->bit_depth == 8
 4394|       |                   * but sometimes row_info->bit_depth has been changed to 8.
 4395|       |                   * In these cases, the palette hasn't been riffled.
 4396|       |                   */
 4397|       |                  i = png_do_expand_palette_rgba8_neon(png_ptr, row_info, row,
 4398|       |                      &sp, &dp);
 4399|       |               }
 4400|       |#else
 4401|  3.21k|               PNG_UNUSED(png_ptr)
  ------------------
  |  |  455|  3.21k|#  define PNG_UNUSED(param) (void)param;
  ------------------
 4402|  3.21k|#endif
 4403|       |
 4404|   179k|               for (; i < row_width; i++)
  ------------------
  |  Branch (4404:23): [True: 176k, False: 3.21k]
  ------------------
 4405|   176k|               {
 4406|   176k|                  if ((int)(*sp) >= num_trans)
  ------------------
  |  Branch (4406:23): [True: 14.8k, False: 161k]
  ------------------
 4407|  14.8k|                     *dp-- = 0xff;
 4408|   161k|                  else
 4409|   161k|                     *dp-- = trans_alpha[*sp];
 4410|   176k|                  *dp-- = palette[*sp].blue;
 4411|   176k|                  *dp-- = palette[*sp].green;
 4412|   176k|                  *dp-- = palette[*sp].red;
 4413|   176k|                  sp--;
 4414|   176k|               }
 4415|  3.21k|               row_info->bit_depth = 8;
 4416|  3.21k|               row_info->pixel_depth = 32;
 4417|  3.21k|               row_info->rowbytes = row_width * 4;
 4418|  3.21k|               row_info->color_type = 6;
 4419|  3.21k|               row_info->channels = 4;
 4420|  3.21k|            }
 4421|       |
 4422|  10.8k|            else
 4423|  10.8k|            {
 4424|  10.8k|               sp = row + (size_t)row_width - 1;
 4425|  10.8k|               dp = row + (size_t)(row_width * 3) - 1;
 4426|  10.8k|               i = 0;
 4427|       |#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
 4428|       |               i = png_do_expand_palette_rgb8_neon(png_ptr, row_info, row,
 4429|       |                   &sp, &dp);
 4430|       |#else
 4431|  10.8k|               PNG_UNUSED(png_ptr)
  ------------------
  |  |  455|  10.8k|#  define PNG_UNUSED(param) (void)param;
  ------------------
 4432|  10.8k|#endif
 4433|       |
 4434|   363k|               for (; i < row_width; i++)
  ------------------
  |  Branch (4434:23): [True: 353k, False: 10.8k]
  ------------------
 4435|   353k|               {
 4436|   353k|                  *dp-- = palette[*sp].blue;
 4437|   353k|                  *dp-- = palette[*sp].green;
 4438|   353k|                  *dp-- = palette[*sp].red;
 4439|   353k|                  sp--;
 4440|   353k|               }
 4441|       |
 4442|  10.8k|               row_info->bit_depth = 8;
 4443|  10.8k|               row_info->pixel_depth = 24;
 4444|  10.8k|               row_info->rowbytes = row_width * 3;
 4445|  10.8k|               row_info->color_type = 2;
 4446|  10.8k|               row_info->channels = 3;
 4447|  10.8k|            }
 4448|  14.0k|         }
 4449|  14.0k|      }
 4450|  14.0k|   }
 4451|  14.0k|}
pngrtran.c:png_do_expand:
 4459|   190k|{
 4460|   190k|   int shift, value;
 4461|   190k|   png_bytep sp, dp;
 4462|   190k|   png_uint_32 i;
 4463|   190k|   png_uint_32 row_width=row_info->width;
 4464|       |
 4465|   190k|   png_debug(1, "in png_do_expand");
  ------------------
  |  |  148|   190k|#  define png_debug(l, m) ((void)0)
  ------------------
 4466|       |
 4467|   190k|   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|   190k|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (4467:8): [True: 80.5k, False: 110k]
  ------------------
 4468|  80.5k|   {
 4469|  80.5k|      unsigned int gray = trans_color != NULL ? trans_color->gray : 0;
  ------------------
  |  Branch (4469:27): [True: 2.27k, False: 78.2k]
  ------------------
 4470|       |
 4471|  80.5k|      if (row_info->bit_depth < 8)
  ------------------
  |  Branch (4471:11): [True: 8.77k, False: 71.7k]
  ------------------
 4472|  8.77k|      {
 4473|  8.77k|         switch (row_info->bit_depth)
 4474|  8.77k|         {
 4475|  4.60k|            case 1:
  ------------------
  |  Branch (4475:13): [True: 4.60k, False: 4.16k]
  ------------------
 4476|  4.60k|            {
 4477|  4.60k|               gray = (gray & 0x01) * 0xff;
 4478|  4.60k|               sp = row + (size_t)((row_width - 1) >> 3);
 4479|  4.60k|               dp = row + (size_t)row_width - 1;
 4480|  4.60k|               shift = 7 - (int)((row_width + 7) & 0x07);
 4481|   741k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4481:28): [True: 736k, False: 4.60k]
  ------------------
 4482|   736k|               {
 4483|   736k|                  if ((*sp >> shift) & 0x01)
  ------------------
  |  Branch (4483:23): [True: 271k, False: 465k]
  ------------------
 4484|   271k|                     *dp = 0xff;
 4485|       |
 4486|   465k|                  else
 4487|   465k|                     *dp = 0;
 4488|       |
 4489|   736k|                  if (shift == 7)
  ------------------
  |  Branch (4489:23): [True: 92.7k, False: 644k]
  ------------------
 4490|  92.7k|                  {
 4491|  92.7k|                     shift = 0;
 4492|  92.7k|                     sp--;
 4493|  92.7k|                  }
 4494|       |
 4495|   644k|                  else
 4496|   644k|                     shift++;
 4497|       |
 4498|   736k|                  dp--;
 4499|   736k|               }
 4500|  4.60k|               break;
 4501|      0|            }
 4502|       |
 4503|  1.66k|            case 2:
  ------------------
  |  Branch (4503:13): [True: 1.66k, False: 7.10k]
  ------------------
 4504|  1.66k|            {
 4505|  1.66k|               gray = (gray & 0x03) * 0x55;
 4506|  1.66k|               sp = row + (size_t)((row_width - 1) >> 2);
 4507|  1.66k|               dp = row + (size_t)row_width - 1;
 4508|  1.66k|               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
 4509|   144k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4509:28): [True: 142k, False: 1.66k]
  ------------------
 4510|   142k|               {
 4511|   142k|                  value = (*sp >> shift) & 0x03;
 4512|   142k|                  *dp = (png_byte)(value | (value << 2) | (value << 4) |
 4513|   142k|                     (value << 6));
 4514|   142k|                  if (shift == 6)
  ------------------
  |  Branch (4514:23): [True: 35.8k, False: 106k]
  ------------------
 4515|  35.8k|                  {
 4516|  35.8k|                     shift = 0;
 4517|  35.8k|                     sp--;
 4518|  35.8k|                  }
 4519|       |
 4520|   106k|                  else
 4521|   106k|                     shift += 2;
 4522|       |
 4523|   142k|                  dp--;
 4524|   142k|               }
 4525|  1.66k|               break;
 4526|      0|            }
 4527|       |
 4528|  2.49k|            case 4:
  ------------------
  |  Branch (4528:13): [True: 2.49k, False: 6.27k]
  ------------------
 4529|  2.49k|            {
 4530|  2.49k|               gray = (gray & 0x0f) * 0x11;
 4531|  2.49k|               sp = row + (size_t)((row_width - 1) >> 1);
 4532|  2.49k|               dp = row + (size_t)row_width - 1;
 4533|  2.49k|               shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
 4534|   512k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4534:28): [True: 509k, False: 2.49k]
  ------------------
 4535|   509k|               {
 4536|   509k|                  value = (*sp >> shift) & 0x0f;
 4537|   509k|                  *dp = (png_byte)(value | (value << 4));
 4538|   509k|                  if (shift == 4)
  ------------------
  |  Branch (4538:23): [True: 254k, False: 254k]
  ------------------
 4539|   254k|                  {
 4540|   254k|                     shift = 0;
 4541|   254k|                     sp--;
 4542|   254k|                  }
 4543|       |
 4544|   254k|                  else
 4545|   254k|                     shift = 4;
 4546|       |
 4547|   509k|                  dp--;
 4548|   509k|               }
 4549|  2.49k|               break;
 4550|      0|            }
 4551|       |
 4552|      0|            default:
  ------------------
  |  Branch (4552:13): [True: 0, False: 8.77k]
  ------------------
 4553|      0|               break;
 4554|  8.77k|         }
 4555|       |
 4556|  8.77k|         row_info->bit_depth = 8;
 4557|  8.77k|         row_info->pixel_depth = 8;
 4558|  8.77k|         row_info->rowbytes = row_width;
 4559|  8.77k|      }
 4560|       |
 4561|  80.5k|      if (trans_color != NULL)
  ------------------
  |  Branch (4561:11): [True: 2.27k, False: 78.2k]
  ------------------
 4562|  2.27k|      {
 4563|  2.27k|         if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4563:14): [True: 1.29k, False: 972]
  ------------------
 4564|  1.29k|         {
 4565|  1.29k|            gray = gray & 0xff;
 4566|  1.29k|            sp = row + (size_t)row_width - 1;
 4567|  1.29k|            dp = row + ((size_t)row_width << 1) - 1;
 4568|       |
 4569|  23.6k|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4569:25): [True: 22.3k, False: 1.29k]
  ------------------
 4570|  22.3k|            {
 4571|  22.3k|               if ((*sp & 0xffU) == gray)
  ------------------
  |  Branch (4571:20): [True: 11.6k, False: 10.7k]
  ------------------
 4572|  11.6k|                  *dp-- = 0;
 4573|       |
 4574|  10.7k|               else
 4575|  10.7k|                  *dp-- = 0xff;
 4576|       |
 4577|  22.3k|               *dp-- = *sp--;
 4578|  22.3k|            }
 4579|  1.29k|         }
 4580|       |
 4581|    972|         else if (row_info->bit_depth == 16)
  ------------------
  |  Branch (4581:19): [True: 972, False: 0]
  ------------------
 4582|    972|         {
 4583|    972|            unsigned int gray_high = (gray >> 8) & 0xff;
 4584|    972|            unsigned int gray_low = gray & 0xff;
 4585|    972|            sp = row + row_info->rowbytes - 1;
 4586|    972|            dp = row + (row_info->rowbytes << 1) - 1;
 4587|  18.3k|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4587:25): [True: 17.3k, False: 972]
  ------------------
 4588|  17.3k|            {
 4589|  17.3k|               if ((*(sp - 1) & 0xffU) == gray_high &&
  ------------------
  |  Branch (4589:20): [True: 6.97k, False: 10.4k]
  ------------------
 4590|  17.3k|                   (*(sp) & 0xffU) == gray_low)
  ------------------
  |  Branch (4590:20): [True: 6.63k, False: 343]
  ------------------
 4591|  6.63k|               {
 4592|  6.63k|                  *dp-- = 0;
 4593|  6.63k|                  *dp-- = 0;
 4594|  6.63k|               }
 4595|       |
 4596|  10.7k|               else
 4597|  10.7k|               {
 4598|  10.7k|                  *dp-- = 0xff;
 4599|  10.7k|                  *dp-- = 0xff;
 4600|  10.7k|               }
 4601|       |
 4602|  17.3k|               *dp-- = *sp--;
 4603|  17.3k|               *dp-- = *sp--;
 4604|  17.3k|            }
 4605|    972|         }
 4606|       |
 4607|  2.27k|         row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
  ------------------
  |  |  670|  2.27k|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  2.27k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
 4608|  2.27k|         row_info->channels = 2;
 4609|  2.27k|         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
 4610|  2.27k|         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
  ------------------
  |  |  731|  2.27k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 2.27k, False: 0]
  |  |  ------------------
  |  |  732|  2.27k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  2.27k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 4611|  2.27k|             row_width);
 4612|  2.27k|      }
 4613|  80.5k|   }
 4614|   110k|   else if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
  ------------------
  |  |  668|   220k|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|   110k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (4614:13): [True: 24.3k, False: 85.7k]
  ------------------
 4615|   110k|       trans_color != NULL)
  ------------------
  |  Branch (4615:8): [True: 14.2k, False: 10.1k]
  ------------------
 4616|  14.2k|   {
 4617|  14.2k|      if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4617:11): [True: 12.5k, False: 1.66k]
  ------------------
 4618|  12.5k|      {
 4619|  12.5k|         png_byte red = (png_byte)(trans_color->red & 0xff);
 4620|  12.5k|         png_byte green = (png_byte)(trans_color->green & 0xff);
 4621|  12.5k|         png_byte blue = (png_byte)(trans_color->blue & 0xff);
 4622|  12.5k|         sp = row + (size_t)row_info->rowbytes - 1;
 4623|  12.5k|         dp = row + ((size_t)row_width << 2) - 1;
 4624|  3.21M|         for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4624:22): [True: 3.20M, False: 12.5k]
  ------------------
 4625|  3.20M|         {
 4626|  3.20M|            if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
  ------------------
  |  Branch (4626:17): [True: 30.7k, False: 3.16M]
  |  Branch (4626:37): [True: 6.14k, False: 24.6k]
  |  Branch (4626:59): [True: 5.19k, False: 951]
  ------------------
 4627|  5.19k|               *dp-- = 0;
 4628|       |
 4629|  3.19M|            else
 4630|  3.19M|               *dp-- = 0xff;
 4631|       |
 4632|  3.20M|            *dp-- = *sp--;
 4633|  3.20M|            *dp-- = *sp--;
 4634|  3.20M|            *dp-- = *sp--;
 4635|  3.20M|         }
 4636|  12.5k|      }
 4637|  1.66k|      else if (row_info->bit_depth == 16)
  ------------------
  |  Branch (4637:16): [True: 1.66k, False: 0]
  ------------------
 4638|  1.66k|      {
 4639|  1.66k|         png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
 4640|  1.66k|         png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
 4641|  1.66k|         png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
 4642|  1.66k|         png_byte red_low = (png_byte)(trans_color->red & 0xff);
 4643|  1.66k|         png_byte green_low = (png_byte)(trans_color->green & 0xff);
 4644|  1.66k|         png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
 4645|  1.66k|         sp = row + row_info->rowbytes - 1;
 4646|  1.66k|         dp = row + ((size_t)row_width << 3) - 1;
 4647|  38.2k|         for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4647:22): [True: 36.6k, False: 1.66k]
  ------------------
 4648|  36.6k|         {
 4649|  36.6k|            if (*(sp - 5) == red_high &&
  ------------------
  |  Branch (4649:17): [True: 12.6k, False: 23.9k]
  ------------------
 4650|  36.6k|                *(sp - 4) == red_low &&
  ------------------
  |  Branch (4650:17): [True: 12.3k, False: 331]
  ------------------
 4651|  36.6k|                *(sp - 3) == green_high &&
  ------------------
  |  Branch (4651:17): [True: 11.9k, False: 448]
  ------------------
 4652|  36.6k|                *(sp - 2) == green_low &&
  ------------------
  |  Branch (4652:17): [True: 11.6k, False: 250]
  ------------------
 4653|  36.6k|                *(sp - 1) == blue_high &&
  ------------------
  |  Branch (4653:17): [True: 11.4k, False: 244]
  ------------------
 4654|  36.6k|                *(sp    ) == blue_low)
  ------------------
  |  Branch (4654:17): [True: 11.1k, False: 297]
  ------------------
 4655|  11.1k|            {
 4656|  11.1k|               *dp-- = 0;
 4657|  11.1k|               *dp-- = 0;
 4658|  11.1k|            }
 4659|       |
 4660|  25.4k|            else
 4661|  25.4k|            {
 4662|  25.4k|               *dp-- = 0xff;
 4663|  25.4k|               *dp-- = 0xff;
 4664|  25.4k|            }
 4665|       |
 4666|  36.6k|            *dp-- = *sp--;
 4667|  36.6k|            *dp-- = *sp--;
 4668|  36.6k|            *dp-- = *sp--;
 4669|  36.6k|            *dp-- = *sp--;
 4670|  36.6k|            *dp-- = *sp--;
 4671|  36.6k|            *dp-- = *sp--;
 4672|  36.6k|         }
 4673|  1.66k|      }
 4674|  14.2k|      row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
  ------------------
  |  |  669|  14.2k|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|  14.2k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  14.2k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
 4675|  14.2k|      row_info->channels = 4;
 4676|  14.2k|      row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
 4677|  14.2k|      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
  ------------------
  |  |  731|  14.2k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 14.2k, False: 0]
  |  |  ------------------
  |  |  732|  14.2k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  14.2k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 4678|  14.2k|   }
 4679|   190k|}
pngrtran.c:png_do_gray_to_rgb:
 2935|   178k|{
 2936|   178k|   png_uint_32 i;
 2937|   178k|   png_uint_32 row_width = row_info->width;
 2938|       |
 2939|   178k|   png_debug(1, "in png_do_gray_to_rgb");
  ------------------
  |  |  148|   178k|#  define png_debug(l, m) ((void)0)
  ------------------
 2940|       |
 2941|   178k|   if (row_info->bit_depth >= 8 &&
  ------------------
  |  Branch (2941:8): [True: 178k, False: 0]
  ------------------
 2942|   178k|       (row_info->color_type & PNG_COLOR_MASK_COLOR) == 0)
  ------------------
  |  |  662|   178k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (2942:8): [True: 86.2k, False: 91.7k]
  ------------------
 2943|  86.2k|   {
 2944|  86.2k|      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|  86.2k|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (2944:11): [True: 78.2k, False: 7.99k]
  ------------------
 2945|  78.2k|      {
 2946|  78.2k|         if (row_info->bit_depth == 8)
  ------------------
  |  Branch (2946:14): [True: 8.47k, False: 69.7k]
  ------------------
 2947|  8.47k|         {
 2948|       |            /* This changes G to RGB */
 2949|  8.47k|            png_bytep sp = row + (size_t)row_width - 1;
 2950|  8.47k|            png_bytep dp = sp  + (size_t)row_width * 2;
 2951|  1.40M|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2951:25): [True: 1.39M, False: 8.47k]
  ------------------
 2952|  1.39M|            {
 2953|  1.39M|               *(dp--) = *sp;
 2954|  1.39M|               *(dp--) = *sp;
 2955|  1.39M|               *(dp--) = *(sp--);
 2956|  1.39M|            }
 2957|  8.47k|         }
 2958|       |
 2959|  69.7k|         else
 2960|  69.7k|         {
 2961|       |            /* This changes GG to RRGGBB */
 2962|  69.7k|            png_bytep sp = row + (size_t)row_width * 2 - 1;
 2963|  69.7k|            png_bytep dp = sp  + (size_t)row_width * 4;
 2964|  3.16M|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2964:25): [True: 3.09M, False: 69.7k]
  ------------------
 2965|  3.09M|            {
 2966|  3.09M|               *(dp--) = *sp;
 2967|  3.09M|               *(dp--) = *(sp - 1);
 2968|  3.09M|               *(dp--) = *sp;
 2969|  3.09M|               *(dp--) = *(sp - 1);
 2970|  3.09M|               *(dp--) = *(sp--);
 2971|  3.09M|               *(dp--) = *(sp--);
 2972|  3.09M|            }
 2973|  69.7k|         }
 2974|  78.2k|      }
 2975|       |
 2976|  7.99k|      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
  ------------------
  |  |  670|  7.99k|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  7.99k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (2976:16): [True: 7.99k, False: 0]
  ------------------
 2977|  7.99k|      {
 2978|  7.99k|         if (row_info->bit_depth == 8)
  ------------------
  |  Branch (2978:14): [True: 3.85k, False: 4.14k]
  ------------------
 2979|  3.85k|         {
 2980|       |            /* This changes GA to RGBA */
 2981|  3.85k|            png_bytep sp = row + (size_t)row_width * 2 - 1;
 2982|  3.85k|            png_bytep dp = sp  + (size_t)row_width * 2;
 2983|   594k|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2983:25): [True: 590k, False: 3.85k]
  ------------------
 2984|   590k|            {
 2985|   590k|               *(dp--) = *(sp--);
 2986|   590k|               *(dp--) = *sp;
 2987|   590k|               *(dp--) = *sp;
 2988|   590k|               *(dp--) = *(sp--);
 2989|   590k|            }
 2990|  3.85k|         }
 2991|       |
 2992|  4.14k|         else
 2993|  4.14k|         {
 2994|       |            /* This changes GGAA to RRGGBBAA */
 2995|  4.14k|            png_bytep sp = row + (size_t)row_width * 4 - 1;
 2996|  4.14k|            png_bytep dp = sp  + (size_t)row_width * 4;
 2997|   749k|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2997:25): [True: 745k, False: 4.14k]
  ------------------
 2998|   745k|            {
 2999|   745k|               *(dp--) = *(sp--);
 3000|   745k|               *(dp--) = *(sp--);
 3001|   745k|               *(dp--) = *sp;
 3002|   745k|               *(dp--) = *(sp - 1);
 3003|   745k|               *(dp--) = *sp;
 3004|   745k|               *(dp--) = *(sp - 1);
 3005|   745k|               *(dp--) = *(sp--);
 3006|   745k|               *(dp--) = *(sp--);
 3007|   745k|            }
 3008|  4.14k|         }
 3009|  7.99k|      }
 3010|  86.2k|      row_info->channels = (png_byte)(row_info->channels + 2);
 3011|  86.2k|      row_info->color_type |= PNG_COLOR_MASK_COLOR;
  ------------------
  |  |  662|  86.2k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
 3012|  86.2k|      row_info->pixel_depth = (png_byte)(row_info->channels *
 3013|  86.2k|          row_info->bit_depth);
 3014|  86.2k|      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
  ------------------
  |  |  731|  86.2k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 86.2k, False: 0]
  |  |  ------------------
  |  |  732|  86.2k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  86.2k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 3015|  86.2k|   }
 3016|   178k|}
pngrtran.c:png_do_gamma:
 4019|  9.96k|{
 4020|  9.96k|   png_const_bytep gamma_table = png_ptr->gamma_table;
 4021|  9.96k|   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;
 4022|  9.96k|   int gamma_shift = png_ptr->gamma_shift;
 4023|       |
 4024|  9.96k|   png_bytep sp;
 4025|  9.96k|   png_uint_32 i;
 4026|  9.96k|   png_uint_32 row_width=row_info->width;
 4027|       |
 4028|  9.96k|   png_debug(1, "in png_do_gamma");
  ------------------
  |  |  148|  9.96k|#  define png_debug(l, m) ((void)0)
  ------------------
 4029|       |
 4030|  9.96k|   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||
  ------------------
  |  Branch (4030:10): [True: 2.46k, False: 7.49k]
  |  Branch (4030:38): [True: 2.46k, False: 0]
  ------------------
 4031|  9.96k|       (row_info->bit_depth == 16 && gamma_16_table != NULL)))
  ------------------
  |  Branch (4031:9): [True: 7.49k, False: 0]
  |  Branch (4031:38): [True: 7.49k, False: 0]
  ------------------
 4032|  9.96k|   {
 4033|  9.96k|      switch (row_info->color_type)
 4034|  9.96k|      {
 4035|  6.06k|         case PNG_COLOR_TYPE_RGB:
  ------------------
  |  |  668|  6.06k|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|  6.06k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (4035:10): [True: 6.06k, False: 3.90k]
  ------------------
 4036|  6.06k|         {
 4037|  6.06k|            if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4037:17): [True: 761, False: 5.30k]
  ------------------
 4038|    761|            {
 4039|    761|               sp = row;
 4040|   139k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4040:28): [True: 138k, False: 761]
  ------------------
 4041|   138k|               {
 4042|   138k|                  *sp = gamma_table[*sp];
 4043|   138k|                  sp++;
 4044|   138k|                  *sp = gamma_table[*sp];
 4045|   138k|                  sp++;
 4046|   138k|                  *sp = gamma_table[*sp];
 4047|   138k|                  sp++;
 4048|   138k|               }
 4049|    761|            }
 4050|       |
 4051|  5.30k|            else /* if (row_info->bit_depth == 16) */
 4052|  5.30k|            {
 4053|  5.30k|               sp = row;
 4054|  1.25M|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4054:28): [True: 1.25M, False: 5.30k]
  ------------------
 4055|  1.25M|               {
 4056|  1.25M|                  png_uint_16 v;
 4057|       |
 4058|  1.25M|                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4059|  1.25M|                  *sp = (png_byte)((v >> 8) & 0xff);
 4060|  1.25M|                  *(sp + 1) = (png_byte)(v & 0xff);
 4061|  1.25M|                  sp += 2;
 4062|       |
 4063|  1.25M|                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4064|  1.25M|                  *sp = (png_byte)((v >> 8) & 0xff);
 4065|  1.25M|                  *(sp + 1) = (png_byte)(v & 0xff);
 4066|  1.25M|                  sp += 2;
 4067|       |
 4068|  1.25M|                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4069|  1.25M|                  *sp = (png_byte)((v >> 8) & 0xff);
 4070|  1.25M|                  *(sp + 1) = (png_byte)(v & 0xff);
 4071|  1.25M|                  sp += 2;
 4072|  1.25M|               }
 4073|  5.30k|            }
 4074|  6.06k|            break;
 4075|      0|         }
 4076|       |
 4077|  3.90k|         case PNG_COLOR_TYPE_RGB_ALPHA:
  ------------------
  |  |  669|  3.90k|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|  3.90k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|  3.90k|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4077:10): [True: 3.90k, False: 6.06k]
  ------------------
 4078|  3.90k|         {
 4079|  3.90k|            if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4079:17): [True: 1.70k, False: 2.19k]
  ------------------
 4080|  1.70k|            {
 4081|  1.70k|               sp = row;
 4082|   399k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4082:28): [True: 397k, False: 1.70k]
  ------------------
 4083|   397k|               {
 4084|   397k|                  *sp = gamma_table[*sp];
 4085|   397k|                  sp++;
 4086|       |
 4087|   397k|                  *sp = gamma_table[*sp];
 4088|   397k|                  sp++;
 4089|       |
 4090|   397k|                  *sp = gamma_table[*sp];
 4091|   397k|                  sp++;
 4092|       |
 4093|   397k|                  sp++;
 4094|   397k|               }
 4095|  1.70k|            }
 4096|       |
 4097|  2.19k|            else /* if (row_info->bit_depth == 16) */
 4098|  2.19k|            {
 4099|  2.19k|               sp = row;
 4100|   471k|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4100:28): [True: 468k, False: 2.19k]
  ------------------
 4101|   468k|               {
 4102|   468k|                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4103|   468k|                  *sp = (png_byte)((v >> 8) & 0xff);
 4104|   468k|                  *(sp + 1) = (png_byte)(v & 0xff);
 4105|   468k|                  sp += 2;
 4106|       |
 4107|   468k|                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4108|   468k|                  *sp = (png_byte)((v >> 8) & 0xff);
 4109|   468k|                  *(sp + 1) = (png_byte)(v & 0xff);
 4110|   468k|                  sp += 2;
 4111|       |
 4112|   468k|                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4113|   468k|                  *sp = (png_byte)((v >> 8) & 0xff);
 4114|   468k|                  *(sp + 1) = (png_byte)(v & 0xff);
 4115|   468k|                  sp += 4;
 4116|   468k|               }
 4117|  2.19k|            }
 4118|  3.90k|            break;
 4119|      0|         }
 4120|       |
 4121|      0|         case PNG_COLOR_TYPE_GRAY_ALPHA:
  ------------------
  |  |  670|      0|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|      0|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4121:10): [True: 0, False: 9.96k]
  ------------------
 4122|      0|         {
 4123|      0|            if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4123:17): [True: 0, False: 0]
  ------------------
 4124|      0|            {
 4125|      0|               sp = row;
 4126|      0|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4126:28): [True: 0, False: 0]
  ------------------
 4127|      0|               {
 4128|      0|                  *sp = gamma_table[*sp];
 4129|      0|                  sp += 2;
 4130|      0|               }
 4131|      0|            }
 4132|       |
 4133|      0|            else /* if (row_info->bit_depth == 16) */
 4134|      0|            {
 4135|      0|               sp = row;
 4136|      0|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4136:28): [True: 0, False: 0]
  ------------------
 4137|      0|               {
 4138|      0|                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4139|      0|                  *sp = (png_byte)((v >> 8) & 0xff);
 4140|      0|                  *(sp + 1) = (png_byte)(v & 0xff);
 4141|      0|                  sp += 4;
 4142|      0|               }
 4143|      0|            }
 4144|      0|            break;
 4145|      0|         }
 4146|       |
 4147|      0|         case PNG_COLOR_TYPE_GRAY:
  ------------------
  |  |  666|      0|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (4147:10): [True: 0, False: 9.96k]
  ------------------
 4148|      0|         {
 4149|      0|            if (row_info->bit_depth == 2)
  ------------------
  |  Branch (4149:17): [True: 0, False: 0]
  ------------------
 4150|      0|            {
 4151|      0|               sp = row;
 4152|      0|               for (i = 0; i < row_width; i += 4)
  ------------------
  |  Branch (4152:28): [True: 0, False: 0]
  ------------------
 4153|      0|               {
 4154|      0|                  int a = *sp & 0xc0;
 4155|      0|                  int b = *sp & 0x30;
 4156|      0|                  int c = *sp & 0x0c;
 4157|      0|                  int d = *sp & 0x03;
 4158|       |
 4159|      0|                  *sp = (png_byte)(
 4160|      0|                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
 4161|      0|                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
 4162|      0|                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
 4163|      0|                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
 4164|      0|                  sp++;
 4165|      0|               }
 4166|      0|            }
 4167|       |
 4168|      0|            if (row_info->bit_depth == 4)
  ------------------
  |  Branch (4168:17): [True: 0, False: 0]
  ------------------
 4169|      0|            {
 4170|      0|               sp = row;
 4171|      0|               for (i = 0; i < row_width; i += 2)
  ------------------
  |  Branch (4171:28): [True: 0, False: 0]
  ------------------
 4172|      0|               {
 4173|      0|                  int msb = *sp & 0xf0;
 4174|      0|                  int lsb = *sp & 0x0f;
 4175|       |
 4176|      0|                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
 4177|      0|                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
 4178|      0|                  sp++;
 4179|      0|               }
 4180|      0|            }
 4181|       |
 4182|      0|            else if (row_info->bit_depth == 8)
  ------------------
  |  Branch (4182:22): [True: 0, False: 0]
  ------------------
 4183|      0|            {
 4184|      0|               sp = row;
 4185|      0|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4185:28): [True: 0, False: 0]
  ------------------
 4186|      0|               {
 4187|      0|                  *sp = gamma_table[*sp];
 4188|      0|                  sp++;
 4189|      0|               }
 4190|      0|            }
 4191|       |
 4192|      0|            else if (row_info->bit_depth == 16)
  ------------------
  |  Branch (4192:22): [True: 0, False: 0]
  ------------------
 4193|      0|            {
 4194|      0|               sp = row;
 4195|      0|               for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (4195:28): [True: 0, False: 0]
  ------------------
 4196|      0|               {
 4197|      0|                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
 4198|      0|                  *sp = (png_byte)((v >> 8) & 0xff);
 4199|      0|                  *(sp + 1) = (png_byte)(v & 0xff);
 4200|      0|                  sp += 2;
 4201|      0|               }
 4202|      0|            }
 4203|      0|            break;
 4204|      0|         }
 4205|       |
 4206|      0|         default:
  ------------------
  |  Branch (4206:10): [True: 0, False: 9.96k]
  ------------------
 4207|      0|            break;
 4208|  9.96k|      }
 4209|  9.96k|   }
 4210|  9.96k|}
pngrtran.c:png_do_scale_16_to_8:
 2464|   179k|{
 2465|   179k|   png_debug(1, "in png_do_scale_16_to_8");
  ------------------
  |  |  148|   179k|#  define png_debug(l, m) ((void)0)
  ------------------
 2466|       |
 2467|   179k|   if (row_info->bit_depth == 16)
  ------------------
  |  Branch (2467:8): [True: 82.8k, False: 96.3k]
  ------------------
 2468|  82.8k|   {
 2469|  82.8k|      png_bytep sp = row; /* source */
 2470|  82.8k|      png_bytep dp = row; /* destination */
 2471|  82.8k|      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
 2472|       |
 2473|  17.8M|      while (sp < ep)
  ------------------
  |  Branch (2473:14): [True: 17.7M, False: 82.8k]
  ------------------
 2474|  17.7M|      {
 2475|       |         /* The input is an array of 16-bit components, these must be scaled to
 2476|       |          * 8 bits each.  For a 16-bit value V the required value (from the PNG
 2477|       |          * specification) is:
 2478|       |          *
 2479|       |          *    (V * 255) / 65535
 2480|       |          *
 2481|       |          * This reduces to round(V / 257), or floor((V + 128.5)/257)
 2482|       |          *
 2483|       |          * Represent V as the two byte value vhi.vlo.  Make a guess that the
 2484|       |          * result is the top byte of V, vhi, then the correction to this value
 2485|       |          * is:
 2486|       |          *
 2487|       |          *    error = floor(((V-vhi.vhi) + 128.5) / 257)
 2488|       |          *          = floor(((vlo-vhi) + 128.5) / 257)
 2489|       |          *
 2490|       |          * This can be approximated using integer arithmetic (and a signed
 2491|       |          * shift):
 2492|       |          *
 2493|       |          *    error = (vlo-vhi+128) >> 8;
 2494|       |          *
 2495|       |          * The approximate differs from the exact answer only when (vlo-vhi) is
 2496|       |          * 128; it then gives a correction of +1 when the exact correction is
 2497|       |          * 0.  This gives 128 errors.  The exact answer (correct for all 16-bit
 2498|       |          * input values) is:
 2499|       |          *
 2500|       |          *    error = (vlo-vhi+128)*65535 >> 24;
 2501|       |          *
 2502|       |          * An alternative arithmetic calculation which also gives no errors is:
 2503|       |          *
 2504|       |          *    (V * 255 + 32895) >> 16
 2505|       |          */
 2506|       |
 2507|  17.7M|         png_int_32 tmp = *sp++; /* must be signed! */
 2508|  17.7M|         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;
 2509|  17.7M|         *dp++ = (png_byte)tmp;
 2510|  17.7M|      }
 2511|       |
 2512|  82.8k|      row_info->bit_depth = 8;
 2513|  82.8k|      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
 2514|  82.8k|      row_info->rowbytes = row_info->width * row_info->channels;
 2515|  82.8k|   }
 2516|   179k|}
pngrtran.c:png_do_unpack:
 2227|  10.0k|{
 2228|  10.0k|   png_debug(1, "in png_do_unpack");
  ------------------
  |  |  148|  10.0k|#  define png_debug(l, m) ((void)0)
  ------------------
 2229|       |
 2230|  10.0k|   if (row_info->bit_depth < 8)
  ------------------
  |  Branch (2230:8): [True: 0, False: 10.0k]
  ------------------
 2231|      0|   {
 2232|      0|      png_uint_32 i;
 2233|      0|      png_uint_32 row_width=row_info->width;
 2234|       |
 2235|      0|      switch (row_info->bit_depth)
 2236|      0|      {
 2237|      0|         case 1:
  ------------------
  |  Branch (2237:10): [True: 0, False: 0]
  ------------------
 2238|      0|         {
 2239|      0|            png_bytep sp = row + (size_t)((row_width - 1) >> 3);
 2240|      0|            png_bytep dp = row + (size_t)row_width - 1;
 2241|      0|            png_uint_32 shift = 7U - ((row_width + 7U) & 0x07);
 2242|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2242:25): [True: 0, False: 0]
  ------------------
 2243|      0|            {
 2244|      0|               *dp = (png_byte)((*sp >> shift) & 0x01);
 2245|       |
 2246|      0|               if (shift == 7)
  ------------------
  |  Branch (2246:20): [True: 0, False: 0]
  ------------------
 2247|      0|               {
 2248|      0|                  shift = 0;
 2249|      0|                  sp--;
 2250|      0|               }
 2251|       |
 2252|      0|               else
 2253|      0|                  shift++;
 2254|       |
 2255|      0|               dp--;
 2256|      0|            }
 2257|      0|            break;
 2258|      0|         }
 2259|       |
 2260|      0|         case 2:
  ------------------
  |  Branch (2260:10): [True: 0, False: 0]
  ------------------
 2261|      0|         {
 2262|       |
 2263|      0|            png_bytep sp = row + (size_t)((row_width - 1) >> 2);
 2264|      0|            png_bytep dp = row + (size_t)row_width - 1;
 2265|      0|            png_uint_32 shift = ((3U - ((row_width + 3U) & 0x03)) << 1);
 2266|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2266:25): [True: 0, False: 0]
  ------------------
 2267|      0|            {
 2268|      0|               *dp = (png_byte)((*sp >> shift) & 0x03);
 2269|       |
 2270|      0|               if (shift == 6)
  ------------------
  |  Branch (2270:20): [True: 0, False: 0]
  ------------------
 2271|      0|               {
 2272|      0|                  shift = 0;
 2273|      0|                  sp--;
 2274|      0|               }
 2275|       |
 2276|      0|               else
 2277|      0|                  shift += 2;
 2278|       |
 2279|      0|               dp--;
 2280|      0|            }
 2281|      0|            break;
 2282|      0|         }
 2283|       |
 2284|      0|         case 4:
  ------------------
  |  Branch (2284:10): [True: 0, False: 0]
  ------------------
 2285|      0|         {
 2286|      0|            png_bytep sp = row + (size_t)((row_width - 1) >> 1);
 2287|      0|            png_bytep dp = row + (size_t)row_width - 1;
 2288|      0|            png_uint_32 shift = ((1U - ((row_width + 1U) & 0x01)) << 2);
 2289|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2289:25): [True: 0, False: 0]
  ------------------
 2290|      0|            {
 2291|      0|               *dp = (png_byte)((*sp >> shift) & 0x0f);
 2292|       |
 2293|      0|               if (shift == 4)
  ------------------
  |  Branch (2293:20): [True: 0, False: 0]
  ------------------
 2294|      0|               {
 2295|      0|                  shift = 0;
 2296|      0|                  sp--;
 2297|      0|               }
 2298|       |
 2299|      0|               else
 2300|      0|                  shift = 4;
 2301|       |
 2302|      0|               dp--;
 2303|      0|            }
 2304|      0|            break;
 2305|      0|         }
 2306|       |
 2307|      0|         default:
  ------------------
  |  Branch (2307:10): [True: 0, False: 0]
  ------------------
 2308|      0|            break;
 2309|      0|      }
 2310|      0|      row_info->bit_depth = 8;
 2311|      0|      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
 2312|      0|      row_info->rowbytes = row_width * row_info->channels;
 2313|      0|   }
 2314|  10.0k|}
pngrtran.c:png_do_read_filler:
 2749|  11.5k|{
 2750|  11.5k|   png_uint_32 i;
 2751|  11.5k|   png_uint_32 row_width = row_info->width;
 2752|       |
 2753|  11.5k|#ifdef PNG_READ_16BIT_SUPPORTED
 2754|  11.5k|   png_byte hi_filler = (png_byte)(filler>>8);
 2755|  11.5k|#endif
 2756|  11.5k|   png_byte lo_filler = (png_byte)filler;
 2757|       |
 2758|  11.5k|   png_debug(1, "in png_do_read_filler");
  ------------------
  |  |  148|  11.5k|#  define png_debug(l, m) ((void)0)
  ------------------
 2759|       |
 2760|  11.5k|   if (
 2761|  11.5k|       row_info->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|  11.5k|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (2761:8): [True: 0, False: 11.5k]
  ------------------
 2762|      0|   {
 2763|      0|      if (row_info->bit_depth == 8)
  ------------------
  |  Branch (2763:11): [True: 0, False: 0]
  ------------------
 2764|      0|      {
 2765|      0|         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
  ------------------
  |  |  678|      0|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  |  Branch (2765:14): [True: 0, False: 0]
  ------------------
 2766|      0|         {
 2767|       |            /* This changes the data from G to GX */
 2768|      0|            png_bytep sp = row + (size_t)row_width;
 2769|      0|            png_bytep dp =  sp + (size_t)row_width;
 2770|      0|            for (i = 1; i < row_width; i++)
  ------------------
  |  Branch (2770:25): [True: 0, False: 0]
  ------------------
 2771|      0|            {
 2772|      0|               *(--dp) = lo_filler;
 2773|      0|               *(--dp) = *(--sp);
 2774|      0|            }
 2775|      0|            *(--dp) = lo_filler;
 2776|      0|            row_info->channels = 2;
 2777|      0|            row_info->pixel_depth = 16;
 2778|      0|            row_info->rowbytes = row_width * 2;
 2779|      0|         }
 2780|       |
 2781|      0|         else
 2782|      0|         {
 2783|       |            /* This changes the data from G to XG */
 2784|      0|            png_bytep sp = row + (size_t)row_width;
 2785|      0|            png_bytep dp = sp  + (size_t)row_width;
 2786|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2786:25): [True: 0, False: 0]
  ------------------
 2787|      0|            {
 2788|      0|               *(--dp) = *(--sp);
 2789|      0|               *(--dp) = lo_filler;
 2790|      0|            }
 2791|      0|            row_info->channels = 2;
 2792|      0|            row_info->pixel_depth = 16;
 2793|      0|            row_info->rowbytes = row_width * 2;
 2794|      0|         }
 2795|      0|      }
 2796|       |
 2797|      0|#ifdef PNG_READ_16BIT_SUPPORTED
 2798|      0|      else if (row_info->bit_depth == 16)
  ------------------
  |  Branch (2798:16): [True: 0, False: 0]
  ------------------
 2799|      0|      {
 2800|      0|         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
  ------------------
  |  |  678|      0|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  |  Branch (2800:14): [True: 0, False: 0]
  ------------------
 2801|      0|         {
 2802|       |            /* This changes the data from GG to GGXX */
 2803|      0|            png_bytep sp = row + (size_t)row_width * 2;
 2804|      0|            png_bytep dp = sp  + (size_t)row_width * 2;
 2805|      0|            for (i = 1; i < row_width; i++)
  ------------------
  |  Branch (2805:25): [True: 0, False: 0]
  ------------------
 2806|      0|            {
 2807|      0|               *(--dp) = lo_filler;
 2808|      0|               *(--dp) = hi_filler;
 2809|      0|               *(--dp) = *(--sp);
 2810|      0|               *(--dp) = *(--sp);
 2811|      0|            }
 2812|      0|            *(--dp) = lo_filler;
 2813|      0|            *(--dp) = hi_filler;
 2814|      0|            row_info->channels = 2;
 2815|      0|            row_info->pixel_depth = 32;
 2816|      0|            row_info->rowbytes = row_width * 4;
 2817|      0|         }
 2818|       |
 2819|      0|         else
 2820|      0|         {
 2821|       |            /* This changes the data from GG to XXGG */
 2822|      0|            png_bytep sp = row + (size_t)row_width * 2;
 2823|      0|            png_bytep dp = sp  + (size_t)row_width * 2;
 2824|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2824:25): [True: 0, False: 0]
  ------------------
 2825|      0|            {
 2826|      0|               *(--dp) = *(--sp);
 2827|      0|               *(--dp) = *(--sp);
 2828|      0|               *(--dp) = lo_filler;
 2829|      0|               *(--dp) = hi_filler;
 2830|      0|            }
 2831|      0|            row_info->channels = 2;
 2832|      0|            row_info->pixel_depth = 32;
 2833|      0|            row_info->rowbytes = row_width * 4;
 2834|      0|         }
 2835|      0|      }
 2836|      0|#endif
 2837|      0|   } /* COLOR_TYPE == GRAY */
 2838|  11.5k|   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
  ------------------
  |  |  668|  11.5k|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|  11.5k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (2838:13): [True: 11.5k, False: 0]
  ------------------
 2839|  11.5k|   {
 2840|  11.5k|      if (row_info->bit_depth == 8)
  ------------------
  |  Branch (2840:11): [True: 11.5k, False: 0]
  ------------------
 2841|  11.5k|      {
 2842|  11.5k|         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
  ------------------
  |  |  678|  11.5k|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  |  Branch (2842:14): [True: 11.5k, False: 0]
  ------------------
 2843|  11.5k|         {
 2844|       |            /* This changes the data from RGB to RGBX */
 2845|  11.5k|            png_bytep sp = row + (size_t)row_width * 3;
 2846|  11.5k|            png_bytep dp = sp  + (size_t)row_width;
 2847|  2.27M|            for (i = 1; i < row_width; i++)
  ------------------
  |  Branch (2847:25): [True: 2.26M, False: 11.5k]
  ------------------
 2848|  2.26M|            {
 2849|  2.26M|               *(--dp) = lo_filler;
 2850|  2.26M|               *(--dp) = *(--sp);
 2851|  2.26M|               *(--dp) = *(--sp);
 2852|  2.26M|               *(--dp) = *(--sp);
 2853|  2.26M|            }
 2854|  11.5k|            *(--dp) = lo_filler;
 2855|  11.5k|            row_info->channels = 4;
 2856|  11.5k|            row_info->pixel_depth = 32;
 2857|  11.5k|            row_info->rowbytes = row_width * 4;
 2858|  11.5k|         }
 2859|       |
 2860|      0|         else
 2861|      0|         {
 2862|       |            /* This changes the data from RGB to XRGB */
 2863|      0|            png_bytep sp = row + (size_t)row_width * 3;
 2864|      0|            png_bytep dp = sp + (size_t)row_width;
 2865|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2865:25): [True: 0, False: 0]
  ------------------
 2866|      0|            {
 2867|      0|               *(--dp) = *(--sp);
 2868|      0|               *(--dp) = *(--sp);
 2869|      0|               *(--dp) = *(--sp);
 2870|      0|               *(--dp) = lo_filler;
 2871|      0|            }
 2872|      0|            row_info->channels = 4;
 2873|      0|            row_info->pixel_depth = 32;
 2874|      0|            row_info->rowbytes = row_width * 4;
 2875|      0|         }
 2876|  11.5k|      }
 2877|       |
 2878|      0|#ifdef PNG_READ_16BIT_SUPPORTED
 2879|      0|      else if (row_info->bit_depth == 16)
  ------------------
  |  Branch (2879:16): [True: 0, False: 0]
  ------------------
 2880|      0|      {
 2881|      0|         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
  ------------------
  |  |  678|      0|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  |  Branch (2881:14): [True: 0, False: 0]
  ------------------
 2882|      0|         {
 2883|       |            /* This changes the data from RRGGBB to RRGGBBXX */
 2884|      0|            png_bytep sp = row + (size_t)row_width * 6;
 2885|      0|            png_bytep dp = sp  + (size_t)row_width * 2;
 2886|      0|            for (i = 1; i < row_width; i++)
  ------------------
  |  Branch (2886:25): [True: 0, False: 0]
  ------------------
 2887|      0|            {
 2888|      0|               *(--dp) = lo_filler;
 2889|      0|               *(--dp) = hi_filler;
 2890|      0|               *(--dp) = *(--sp);
 2891|      0|               *(--dp) = *(--sp);
 2892|      0|               *(--dp) = *(--sp);
 2893|      0|               *(--dp) = *(--sp);
 2894|      0|               *(--dp) = *(--sp);
 2895|      0|               *(--dp) = *(--sp);
 2896|      0|            }
 2897|      0|            *(--dp) = lo_filler;
 2898|      0|            *(--dp) = hi_filler;
 2899|      0|            row_info->channels = 4;
 2900|      0|            row_info->pixel_depth = 64;
 2901|      0|            row_info->rowbytes = row_width * 8;
 2902|      0|         }
 2903|       |
 2904|      0|         else
 2905|      0|         {
 2906|       |            /* This changes the data from RRGGBB to XXRRGGBB */
 2907|      0|            png_bytep sp = row + (size_t)row_width * 6;
 2908|      0|            png_bytep dp = sp  + (size_t)row_width * 2;
 2909|      0|            for (i = 0; i < row_width; i++)
  ------------------
  |  Branch (2909:25): [True: 0, False: 0]
  ------------------
 2910|      0|            {
 2911|      0|               *(--dp) = *(--sp);
 2912|      0|               *(--dp) = *(--sp);
 2913|      0|               *(--dp) = *(--sp);
 2914|      0|               *(--dp) = *(--sp);
 2915|      0|               *(--dp) = *(--sp);
 2916|      0|               *(--dp) = *(--sp);
 2917|      0|               *(--dp) = lo_filler;
 2918|      0|               *(--dp) = hi_filler;
 2919|      0|            }
 2920|       |
 2921|      0|            row_info->channels = 4;
 2922|      0|            row_info->pixel_depth = 64;
 2923|      0|            row_info->rowbytes = row_width * 8;
 2924|      0|         }
 2925|      0|      }
 2926|  11.5k|#endif
 2927|  11.5k|   } /* COLOR_TYPE == RGB */
 2928|  11.5k|}

OSS_FUZZ_png_get_uint_31:
   42|  60.2k|{
   43|  60.2k|   png_uint_32 uval = png_get_uint_32(buf);
  ------------------
  |  |  322|  60.2k|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|  60.2k|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|  60.2k|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|  60.2k|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|  60.2k|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|  60.2k|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   44|       |
   45|  60.2k|   if (uval > PNG_UINT_31_MAX)
  ------------------
  |  |  647|  60.2k|#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
  ------------------
  |  Branch (45:8): [True: 41, False: 60.1k]
  ------------------
   46|     41|      png_error(png_ptr, "PNG unsigned integer out of range");
  ------------------
  |  |  252|     41|#define png_error OSS_FUZZ_png_error
  ------------------
   47|       |
   48|  60.1k|   return uval;
   49|  60.2k|}
OSS_FUZZ_png_read_sig:
  117|  2.60k|{
  118|  2.60k|   size_t num_checked, num_to_check;
  119|       |
  120|       |   /* Exit if the user application does not expect a signature. */
  121|  2.60k|   if (png_ptr->sig_bytes >= 8)
  ------------------
  |  Branch (121:8): [True: 2.05k, False: 548]
  ------------------
  122|  2.05k|      return;
  123|       |
  124|    548|   num_checked = png_ptr->sig_bytes;
  125|    548|   num_to_check = 8 - num_checked;
  126|       |
  127|    548|#ifdef PNG_IO_STATE_SUPPORTED
  128|    548|   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;
  ------------------
  |  | 2527|    548|#  define PNG_IO_READING     0x0001   /* currently reading */
  ------------------
                 png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;
  ------------------
  |  | 2529|    548|#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
  ------------------
  129|    548|#endif
  130|       |
  131|       |   /* The signature must be serialized in a single I/O call. */
  132|    548|   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);
  ------------------
  |  |   23|    548|#define png_read_data OSS_FUZZ_png_read_data
  ------------------
  133|    548|   png_ptr->sig_bytes = 8;
  134|       |
  135|    548|   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)
  ------------------
  |  |  448|    548|#define png_sig_cmp OSS_FUZZ_png_sig_cmp
  ------------------
  |  Branch (135:8): [True: 0, False: 548]
  ------------------
  136|      0|   {
  137|      0|      if (num_checked < 4 &&
  ------------------
  |  Branch (137:11): [True: 0, False: 0]
  ------------------
  138|      0|          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4) != 0)
  ------------------
  |  |  448|      0|#define png_sig_cmp OSS_FUZZ_png_sig_cmp
  ------------------
  |  Branch (138:11): [True: 0, False: 0]
  ------------------
  139|      0|         png_error(png_ptr, "Not a PNG file");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  140|      0|      else
  141|      0|         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  142|      0|   }
  143|    548|   if (num_checked < 3)
  ------------------
  |  Branch (143:8): [True: 548, False: 0]
  ------------------
  144|    548|      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
  ------------------
  |  |  628|    548|#define PNG_HAVE_PNG_SIGNATURE    0x1000U
  ------------------
  145|    548|}
OSS_FUZZ_png_read_chunk_header:
  184|  55.6k|{
  185|  55.6k|   png_byte buf[8];
  186|  55.6k|   png_uint_32 chunk_name, length;
  187|       |
  188|  55.6k|#ifdef PNG_IO_STATE_SUPPORTED
  189|  55.6k|   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
  ------------------
  |  | 2527|  55.6k|#  define PNG_IO_READING     0x0001   /* currently reading */
  ------------------
                 png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
  ------------------
  |  | 2530|  55.6k|#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
  ------------------
  190|  55.6k|#endif
  191|       |
  192|       |   /* Read the length and the chunk name.  png_struct::chunk_name is immediately
  193|       |    * updated even if they are detectably wrong.  This aids error message
  194|       |    * handling by allowing png_chunk_error to be used.
  195|       |    */
  196|  55.6k|   png_read_data(png_ptr, buf, 8);
  ------------------
  |  |   23|  55.6k|#define png_read_data OSS_FUZZ_png_read_data
  ------------------
  197|  55.6k|   length = png_get_uint_31(png_ptr, buf);
  ------------------
  |  |  321|  55.6k|#define png_get_uint_31 OSS_FUZZ_png_get_uint_31
  ------------------
  198|  55.6k|   png_ptr->chunk_name = chunk_name = PNG_CHUNK_FROM_STRING(buf+4);
  ------------------
  |  |  900|  55.6k|   PNG_U32(0xff & (s)[0], 0xff & (s)[1], 0xff & (s)[2], 0xff & (s)[3])
  |  |  ------------------
  |  |  |  |  821|  55.6k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  55.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  55.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  55.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  55.6k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  199|       |
  200|       |   /* Reset the crc and run it over the chunk name. */
  201|  55.6k|   png_reset_crc(png_ptr);
  ------------------
  |  |   19|  55.6k|#define png_reset_crc OSS_FUZZ_png_reset_crc
  ------------------
  202|  55.6k|   png_calculate_crc(png_ptr, buf + 4, 4);
  ------------------
  |  |   26|  55.6k|#define png_calculate_crc OSS_FUZZ_png_calculate_crc
  ------------------
  203|       |
  204|  55.6k|   png_debug2(0, "Reading chunk typeid = 0x%lx, length = %lu",
  ------------------
  |  |  154|  55.6k|#  define png_debug2(l, m, p1, p2) ((void)0)
  ------------------
  205|  55.6k|       (unsigned long)png_ptr->chunk_name, (unsigned long)length);
  206|       |
  207|       |   /* Sanity check the length (first by <= 0x80) and the chunk name.  An error
  208|       |    * here indicates a broken stream and libpng has no recovery from this.
  209|       |    */
  210|  55.6k|   if (buf[0] >= 0x80U)
  ------------------
  |  Branch (210:8): [True: 0, False: 55.6k]
  ------------------
  211|      0|      png_chunk_error(png_ptr, "bad header (invalid length)");
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  212|       |
  213|       |   /* Check to see if chunk name is valid. */
  214|  55.6k|   if (!check_chunk_name(chunk_name))
  ------------------
  |  Branch (214:8): [True: 122, False: 55.5k]
  ------------------
  215|    122|      png_chunk_error(png_ptr, "bad header (invalid type)");
  ------------------
  |  |  239|    122|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  216|       |
  217|  55.5k|#ifdef PNG_IO_STATE_SUPPORTED
  218|  55.5k|   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
  ------------------
  |  | 2527|  55.5k|#  define PNG_IO_READING     0x0001   /* currently reading */
  ------------------
                 png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
  ------------------
  |  | 2531|  55.5k|#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
  ------------------
  219|  55.5k|#endif
  220|       |
  221|  55.5k|   return length;
  222|  55.6k|}
OSS_FUZZ_png_crc_read:
  227|  55.1k|{
  228|  55.1k|   if (png_ptr == NULL)
  ------------------
  |  Branch (228:8): [True: 0, False: 55.1k]
  ------------------
  229|      0|      return;
  230|       |
  231|  55.1k|   png_read_data(png_ptr, buf, length);
  ------------------
  |  |   23|  55.1k|#define png_read_data OSS_FUZZ_png_read_data
  ------------------
  232|  55.1k|   png_calculate_crc(png_ptr, buf, length);
  ------------------
  |  |   26|  55.1k|#define png_calculate_crc OSS_FUZZ_png_calculate_crc
  ------------------
  233|  55.1k|}
OSS_FUZZ_png_crc_finish:
  361|  52.7k|{
  362|  52.7k|   return png_crc_finish_critical(png_ptr, skip, 0/*critical handling*/);
  363|  52.7k|}
OSS_FUZZ_png_zlib_inflate:
  526|   244k|{
  527|   244k|   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)
  ------------------
  |  Branch (527:8): [True: 4.31k, False: 240k]
  |  Branch (527:34): [True: 4.31k, False: 0]
  ------------------
  528|  4.31k|   {
  529|  4.31k|      if ((*png_ptr->zstream.next_in >> 4) > 7)
  ------------------
  |  Branch (529:11): [True: 294, False: 4.02k]
  ------------------
  530|    294|      {
  531|    294|         png_ptr->zstream.msg = "invalid window size (libpng)";
  532|    294|         return Z_DATA_ERROR;
  533|    294|      }
  534|       |
  535|  4.02k|      png_ptr->zstream_start = 0;
  536|  4.02k|   }
  537|       |
  538|   244k|   return inflate(&png_ptr->zstream, flush);
  539|   244k|}
OSS_FUZZ_png_handle_unknown:
 2787|  5.51k|{
 2788|  5.51k|   png_handle_result_code handled = handled_discarded; /* the default */
 2789|       |
 2790|  5.51k|   png_debug(1, "in png_handle_unknown");
  ------------------
  |  |  148|  5.51k|#  define png_debug(l, m) ((void)0)
  ------------------
 2791|       |
 2792|  5.51k|#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
 2793|       |   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
 2794|       |    * the bug which meant that setting a non-default behavior for a specific
 2795|       |    * chunk would be ignored (the default was always used unless a user
 2796|       |    * callback was installed).
 2797|       |    *
 2798|       |    * 'keep' is the value from the png_chunk_unknown_handling, the setting for
 2799|       |    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it
 2800|       |    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.
 2801|       |    * This is just an optimization to avoid multiple calls to the lookup
 2802|       |    * function.
 2803|       |    */
 2804|       |#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 2805|       |#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
 2806|       |   keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);
 2807|       |#     endif
 2808|       |#  endif
 2809|       |
 2810|       |   /* One of the following methods will read the chunk or skip it (at least one
 2811|       |    * of these is always defined because this is the only way to switch on
 2812|       |    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
 2813|       |    */
 2814|  5.51k|#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED
 2815|       |   /* The user callback takes precedence over the chunk keep value, but the
 2816|       |    * keep value is still required to validate a save of a critical chunk.
 2817|       |    */
 2818|  5.51k|   if (png_ptr->read_user_chunk_fn != NULL)
  ------------------
  |  Branch (2818:8): [True: 0, False: 5.51k]
  ------------------
 2819|      0|   {
 2820|      0|      if (png_cache_unknown_chunk(png_ptr, length) != 0)
  ------------------
  |  Branch (2820:11): [True: 0, False: 0]
  ------------------
 2821|      0|      {
 2822|       |         /* Callback to user unknown chunk handler */
 2823|      0|         int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,
 2824|      0|             &png_ptr->unknown_chunk);
 2825|       |
 2826|       |         /* ret is:
 2827|       |          * negative: An error occurred; png_chunk_error will be called.
 2828|       |          *     zero: The chunk was not handled, the chunk will be discarded
 2829|       |          *           unless png_set_keep_unknown_chunks has been used to set
 2830|       |          *           a 'keep' behavior for this particular chunk, in which
 2831|       |          *           case that will be used.  A critical chunk will cause an
 2832|       |          *           error at this point unless it is to be saved.
 2833|       |          * positive: The chunk was handled, libpng will ignore/discard it.
 2834|       |          */
 2835|      0|         if (ret < 0) /* handled_error */
  ------------------
  |  Branch (2835:14): [True: 0, False: 0]
  ------------------
 2836|      0|            png_chunk_error(png_ptr, "error in user chunk");
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 2837|       |
 2838|      0|         else if (ret == 0)
  ------------------
  |  Branch (2838:19): [True: 0, False: 0]
  ------------------
 2839|      0|         {
 2840|       |            /* If the keep value is 'default' or 'never' override it, but
 2841|       |             * still error out on critical chunks unless the keep value is
 2842|       |             * 'always'  While this is weird it is the behavior in 1.4.12.
 2843|       |             * A possible improvement would be to obey the value set for the
 2844|       |             * chunk, but this would be an API change that would probably
 2845|       |             * damage some applications.
 2846|       |             *
 2847|       |             * The png_app_warning below catches the case that matters, where
 2848|       |             * the application has not set specific save or ignore for this
 2849|       |             * chunk or global save or ignore.
 2850|       |             */
 2851|      0|            if (keep < PNG_HANDLE_CHUNK_IF_SAFE)
  ------------------
  |  | 2451|      0|#define PNG_HANDLE_CHUNK_IF_SAFE      2
  ------------------
  |  Branch (2851:17): [True: 0, False: 0]
  ------------------
 2852|      0|            {
 2853|      0|#              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
 2854|      0|               if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)
  ------------------
  |  | 2451|      0|#define PNG_HANDLE_CHUNK_IF_SAFE      2
  ------------------
  |  Branch (2854:20): [True: 0, False: 0]
  ------------------
 2855|      0|               {
 2856|      0|                  png_chunk_warning(png_ptr, "Saving unknown chunk:");
  ------------------
  |  |  240|      0|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
 2857|      0|                  png_app_warning(png_ptr,
  ------------------
  |  |   81|      0|#define png_app_warning OSS_FUZZ_png_app_warning
  ------------------
 2858|      0|                      "forcing save of an unhandled chunk;"
 2859|      0|                      " please call png_set_keep_unknown_chunks");
 2860|       |                      /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
 2861|      0|               }
 2862|      0|#              endif
 2863|      0|               keep = PNG_HANDLE_CHUNK_IF_SAFE;
  ------------------
  |  | 2451|      0|#define PNG_HANDLE_CHUNK_IF_SAFE      2
  ------------------
 2864|      0|            }
 2865|      0|         }
 2866|       |
 2867|      0|         else /* chunk was handled */
 2868|      0|         {
 2869|      0|            handled = handled_ok;
 2870|       |            /* Critical chunks can be safely discarded at this point. */
 2871|      0|            keep = PNG_HANDLE_CHUNK_NEVER;
  ------------------
  |  | 2450|      0|#define PNG_HANDLE_CHUNK_NEVER        1
  ------------------
 2872|      0|         }
 2873|      0|      }
 2874|       |
 2875|      0|      else
 2876|      0|         keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */
  ------------------
  |  | 2450|      0|#define PNG_HANDLE_CHUNK_NEVER        1
  ------------------
 2877|      0|   }
 2878|       |
 2879|  5.51k|   else
 2880|       |   /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
 2881|  5.51k|#  endif /* READ_USER_CHUNKS */
 2882|       |
 2883|  5.51k|#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
 2884|  5.51k|   {
 2885|       |      /* keep is currently just the per-chunk setting, if there was no
 2886|       |       * setting change it to the global default now (not that this may
 2887|       |       * still be AS_DEFAULT) then obtain the cache of the chunk if required,
 2888|       |       * if not simply skip the chunk.
 2889|       |       */
 2890|  5.51k|      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
  ------------------
  |  | 2449|  5.51k|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
  |  Branch (2890:11): [True: 5.51k, False: 0]
  ------------------
 2891|  5.51k|         keep = png_ptr->unknown_default;
 2892|       |
 2893|  5.51k|      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
  ------------------
  |  | 2452|  11.0k|#define PNG_HANDLE_CHUNK_ALWAYS       3
  ------------------
  |  Branch (2893:11): [True: 0, False: 5.51k]
  ------------------
 2894|  5.51k|         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
  ------------------
  |  | 2451|  11.0k|#define PNG_HANDLE_CHUNK_IF_SAFE      2
  ------------------
  |  Branch (2894:11): [True: 0, False: 5.51k]
  ------------------
 2895|  5.51k|          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
  ------------------
  |  |  917|      0|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  |  |  ------------------
  |  |  |  Branch (917:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2896|      0|      {
 2897|      0|         if (png_cache_unknown_chunk(png_ptr, length) == 0)
  ------------------
  |  Branch (2897:14): [True: 0, False: 0]
  ------------------
 2898|      0|            keep = PNG_HANDLE_CHUNK_NEVER;
  ------------------
  |  | 2450|      0|#define PNG_HANDLE_CHUNK_NEVER        1
  ------------------
 2899|      0|      }
 2900|       |
 2901|  5.51k|      else
 2902|  5.51k|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|  5.51k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2903|  5.51k|   }
 2904|       |#  else
 2905|       |#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED
 2906|       |#        error no method to support READ_UNKNOWN_CHUNKS
 2907|       |#     endif
 2908|       |
 2909|       |   {
 2910|       |      /* If here there is no read callback pointer set and no support is
 2911|       |       * compiled in to just save the unknown chunks, so simply skip this
 2912|       |       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then
 2913|       |       * the app has erroneously asked for unknown chunk saving when there
 2914|       |       * is no support.
 2915|       |       */
 2916|       |      if (keep > PNG_HANDLE_CHUNK_NEVER)
 2917|       |         png_app_error(png_ptr, "no unknown chunk support available");
 2918|       |
 2919|       |      png_crc_finish(png_ptr, length);
 2920|       |   }
 2921|       |#  endif
 2922|       |
 2923|  5.51k|#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
 2924|       |   /* Now store the chunk in the chunk list if appropriate, and if the limits
 2925|       |    * permit it.
 2926|       |    */
 2927|  5.51k|   if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
  ------------------
  |  | 2452|  11.0k|#define PNG_HANDLE_CHUNK_ALWAYS       3
  ------------------
  |  Branch (2927:8): [True: 30, False: 5.48k]
  ------------------
 2928|  5.51k|      (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
  ------------------
  |  | 2451|  10.9k|#define PNG_HANDLE_CHUNK_IF_SAFE      2
  ------------------
  |  Branch (2928:8): [True: 0, False: 5.48k]
  ------------------
 2929|  5.48k|       PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
  ------------------
  |  |  917|      0|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  |  |  ------------------
  |  |  |  Branch (917:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 2930|      0|   {
 2931|      0|#     ifdef PNG_USER_LIMITS_SUPPORTED
 2932|      0|      switch (png_ptr->user_chunk_cache_max)
 2933|      0|      {
 2934|      0|         case 2:
  ------------------
  |  Branch (2934:10): [True: 0, False: 0]
  ------------------
 2935|      0|            png_ptr->user_chunk_cache_max = 1;
 2936|      0|            png_chunk_benign_error(png_ptr, "no space in chunk cache");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2937|       |            /* FALLTHROUGH */
 2938|      0|         case 1:
  ------------------
  |  Branch (2938:10): [True: 0, False: 0]
  ------------------
 2939|       |            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical
 2940|       |             * chunk being skipped, now there will be a hard error below.
 2941|       |             */
 2942|      0|            break;
 2943|       |
 2944|      0|         default: /* not at limit */
  ------------------
  |  Branch (2944:10): [True: 0, False: 0]
  ------------------
 2945|      0|            --(png_ptr->user_chunk_cache_max);
 2946|       |            /* FALLTHROUGH */
 2947|      0|         case 0: /* no limit */
  ------------------
  |  Branch (2947:10): [True: 0, False: 0]
  ------------------
 2948|      0|#  endif /* USER_LIMITS */
 2949|       |            /* Here when the limit isn't reached or when limits are compiled
 2950|       |             * out; store the chunk.
 2951|       |             */
 2952|      0|            png_set_unknown_chunks(png_ptr, info_ptr,
  ------------------
  |  |  443|      0|#define png_set_unknown_chunks OSS_FUZZ_png_set_unknown_chunks
  ------------------
 2953|      0|                &png_ptr->unknown_chunk, 1);
 2954|      0|            handled = handled_saved;
 2955|      0|#  ifdef PNG_USER_LIMITS_SUPPORTED
 2956|      0|            break;
 2957|      0|      }
 2958|      0|#  endif
 2959|      0|   }
 2960|       |#  else /* no store support: the chunk must be handled by the user callback */
 2961|       |   PNG_UNUSED(info_ptr)
 2962|       |#  endif
 2963|       |
 2964|       |   /* Regardless of the error handling below the cached data (if any) can be
 2965|       |    * freed now.  Notice that the data is not freed if there is a png_error, but
 2966|       |    * it will be freed by destroy_read_struct.
 2967|       |    */
 2968|  5.51k|   if (png_ptr->unknown_chunk.data != NULL)
  ------------------
  |  Branch (2968:8): [True: 0, False: 5.51k]
  ------------------
 2969|      0|      png_free(png_ptr, png_ptr->unknown_chunk.data);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 2970|  5.51k|   png_ptr->unknown_chunk.data = NULL;
 2971|       |
 2972|       |#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
 2973|       |   /* There is no support to read an unknown chunk, so just skip it. */
 2974|       |   png_crc_finish(png_ptr, length);
 2975|       |   PNG_UNUSED(info_ptr)
 2976|       |   PNG_UNUSED(keep)
 2977|       |#endif /* !READ_UNKNOWN_CHUNKS */
 2978|       |
 2979|       |   /* Check for unhandled critical chunks */
 2980|  5.51k|   if (handled < handled_saved && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
  ------------------
  |  |  918|  5.48k|#define PNG_CHUNK_CRITICAL(c)     (!PNG_CHUNK_ANCILLARY(c))
  |  |  ------------------
  |  |  |  |  917|  5.48k|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  |  |  ------------------
  |  |  |  Branch (918:35): [True: 1, False: 5.48k]
  |  |  ------------------
  ------------------
  |  Branch (2980:8): [True: 5.48k, False: 30]
  ------------------
 2981|      1|      png_chunk_error(png_ptr, "unhandled critical chunk");
  ------------------
  |  |  239|      1|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 2982|       |
 2983|  5.51k|   return handled;
 2984|  5.51k|}
OSS_FUZZ_png_handle_chunk:
 3132|  52.8k|{
 3133|       |   /* CSE: these things don't change, these autos are just to save typing and
 3134|       |    * make the code more clear.
 3135|       |    */
 3136|  52.8k|   const png_uint_32 chunk_name = png_ptr->chunk_name;
 3137|  52.8k|   const png_index chunk_index = png_chunk_index_from_name(chunk_name);
 3138|       |
 3139|  52.8k|   png_handle_result_code handled = handled_error;
 3140|  52.8k|   png_const_charp errmsg = NULL;
 3141|       |
 3142|       |   /* Is this a known chunk?  If not there are no checks performed here;
 3143|       |    * png_handle_unknown does the correct checks.  This means that the values
 3144|       |    * for known but unsupported chunks in the above table are not used here
 3145|       |    * however the chunks_seen fields in png_struct are still set.
 3146|       |    */
 3147|  52.8k|   if (chunk_index == PNG_INDEX_unknown ||
  ------------------
  |  Branch (3147:8): [True: 5.30k, False: 47.5k]
  ------------------
 3148|  52.8k|       read_chunks[chunk_index].handler == NULL)
  ------------------
  |  Branch (3148:8): [True: 210, False: 47.3k]
  ------------------
 3149|  5.51k|   {
 3150|  5.51k|      handled = png_handle_unknown(
  ------------------
  |  |   49|  5.51k|#define png_handle_unknown OSS_FUZZ_png_handle_unknown
  ------------------
 3151|  5.51k|            png_ptr, info_ptr, length, PNG_HANDLE_CHUNK_AS_DEFAULT);
  ------------------
  |  | 2449|  5.51k|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
 3152|  5.51k|   }
 3153|       |
 3154|       |   /* First check the position.   The first check is historical; the stream must
 3155|       |    * start with IHDR and anything else causes libpng to give up immediately.
 3156|       |    */
 3157|  47.3k|   else if (chunk_index != PNG_INDEX_IHDR &&
  ------------------
  |  Branch (3157:13): [True: 44.7k, False: 2.57k]
  ------------------
 3158|  47.3k|            (png_ptr->mode & PNG_HAVE_IHDR) == 0)
  ------------------
  |  |  642|  44.7k|#define PNG_HAVE_IHDR  0x01
  ------------------
  |  Branch (3158:13): [True: 1, False: 44.7k]
  ------------------
 3159|      1|      png_chunk_error(png_ptr, "missing IHDR"); /* NORETURN */
  ------------------
  |  |  239|      1|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 3160|       |
 3161|       |   /* Before all the pos_before chunks, after all the pos_after chunks. */
 3162|  47.3k|   else if (((png_ptr->mode & read_chunks[chunk_index].pos_before) != 0) ||
  ------------------
  |  Branch (3162:13): [True: 1.27k, False: 46.0k]
  ------------------
 3163|  47.3k|            ((png_ptr->mode & read_chunks[chunk_index].pos_after) !=
  ------------------
  |  Branch (3163:13): [True: 1, False: 46.0k]
  ------------------
 3164|  46.0k|             read_chunks[chunk_index].pos_after))
 3165|  1.27k|   {
 3166|  1.27k|      errmsg = "out of place";
 3167|  1.27k|   }
 3168|       |
 3169|       |   /* Now check for duplicates: duplicated critical chunks also produce a
 3170|       |    * full error.
 3171|       |    */
 3172|  46.0k|   else if (read_chunks[chunk_index].multiple == 0 &&
  ------------------
  |  Branch (3172:13): [True: 36.4k, False: 9.62k]
  ------------------
 3173|  46.0k|            png_file_has_chunk(png_ptr, chunk_index))
  ------------------
  |  |  115|  36.4k|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  ------------------
  |  |  |  |  108|  36.4k|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  ------------------
  |  |  |  Branch (115:4): [True: 17.2k, False: 19.2k]
  |  |  ------------------
  ------------------
 3174|  17.2k|   {
 3175|  17.2k|      errmsg = "duplicate";
 3176|  17.2k|   }
 3177|       |
 3178|  28.8k|   else if (length < read_chunks[chunk_index].min_length)
  ------------------
  |  Branch (3178:13): [True: 171, False: 28.7k]
  ------------------
 3179|    171|      errmsg = "too short";
 3180|  28.7k|   else
 3181|  28.7k|   {
 3182|       |      /* NOTE: apart from IHDR the critical chunks (PLTE, IDAT and IEND) are set
 3183|       |       * up above not to do any length checks.
 3184|       |       *
 3185|       |       * The png_chunk_max check ensures that the variable length chunks are
 3186|       |       * always checked at this point for being within the system allocation
 3187|       |       * limits.
 3188|       |       */
 3189|  28.7k|      unsigned max_length = read_chunks[chunk_index].max_length;
 3190|       |
 3191|  28.7k|      switch (max_length)
 3192|  28.7k|      {
 3193|  5.43k|         case Limit:
  ------------------
  |  | 3047|  5.43k|#  define Limit   0x802U      /* Limit to png_chunk_max bytes */
  ------------------
  |  Branch (3193:10): [True: 5.43k, False: 23.2k]
  ------------------
 3194|       |            /* png_read_chunk_header has already png_error'ed chunks with a
 3195|       |             * length exceeding the 31-bit PNG limit, so just check the memory
 3196|       |             * limit:
 3197|       |             */
 3198|  5.43k|            if (length <= png_chunk_max(png_ptr))
  ------------------
  |  | 1097|  5.43k|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
  |  Branch (3198:17): [True: 5.43k, False: 1]
  ------------------
 3199|  5.43k|               goto MeetsLimit;
 3200|       |
 3201|      1|            errmsg = "length exceeds libpng limit";
 3202|      1|            break;
 3203|       |
 3204|  12.6k|         default:
  ------------------
  |  Branch (3204:10): [True: 12.6k, False: 16.0k]
  ------------------
 3205|  12.6k|            if (length <= max_length)
  ------------------
  |  Branch (3205:17): [True: 12.6k, False: 33]
  ------------------
 3206|  12.6k|               goto MeetsLimit;
 3207|       |
 3208|     33|            errmsg = "too long";
 3209|     33|            break;
 3210|       |
 3211|  10.6k|         case NoCheck:
  ------------------
  |  | 3046|  10.6k|#  define NoCheck 0x801U      /* Do not check the maximum length */
  ------------------
  |  Branch (3211:10): [True: 10.6k, False: 18.1k]
  ------------------
 3212|  28.6k|         MeetsLimit:
 3213|  28.6k|            handled = read_chunks[chunk_index].handler(
 3214|  28.6k|                  png_ptr, info_ptr, length);
 3215|  28.6k|            break;
 3216|  28.7k|      }
 3217|  28.7k|   }
 3218|       |
 3219|       |   /* If there was an error or the chunk was simply skipped it is not counted as
 3220|       |    * 'seen'.
 3221|       |    */
 3222|  52.6k|   if (errmsg != NULL)
  ------------------
  |  Branch (3222:8): [True: 18.6k, False: 33.9k]
  ------------------
 3223|  18.6k|   {
 3224|  18.6k|      if (PNG_CHUNK_CRITICAL(chunk_name)) /* stop immediately */
  ------------------
  |  |  918|  18.6k|#define PNG_CHUNK_CRITICAL(c)     (!PNG_CHUNK_ANCILLARY(c))
  |  |  ------------------
  |  |  |  |  917|  18.6k|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  |  |  ------------------
  |  |  |  Branch (918:35): [True: 7, False: 18.6k]
  |  |  ------------------
  ------------------
 3225|      7|         png_chunk_error(png_ptr, errmsg);
  ------------------
  |  |  239|      7|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 3226|  18.6k|      else /* ancillary chunk */
 3227|  18.6k|      {
 3228|       |         /* The chunk data is skipped: */
 3229|  18.6k|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|  18.6k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 3230|  18.6k|         png_chunk_benign_error(png_ptr, errmsg);
  ------------------
  |  |  238|  18.6k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 3231|  18.6k|      }
 3232|  18.6k|   }
 3233|       |
 3234|  33.9k|   else if (handled >= handled_saved)
  ------------------
  |  Branch (3234:13): [True: 11.6k, False: 22.3k]
  ------------------
 3235|  11.6k|   {
 3236|  11.6k|      if (chunk_index != PNG_INDEX_unknown)
  ------------------
  |  Branch (3236:11): [True: 11.6k, False: 0]
  ------------------
 3237|  11.6k|         png_file_add_chunk(png_ptr, chunk_index);
  ------------------
  |  |  119|  11.6k|   ((void)((png_ptr)->chunks |= png_chunk_flag_from_index(i)))
  |  |  ------------------
  |  |  |  |  108|  11.6k|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  ------------------
  ------------------
 3238|  11.6k|   }
 3239|       |
 3240|  52.6k|   return handled;
 3241|  52.6k|}
OSS_FUZZ_png_combine_row:
 3252|   204k|{
 3253|   204k|   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
 3254|   204k|   png_const_bytep sp = png_ptr->row_buf + 1;
 3255|   204k|   png_alloc_size_t row_width = png_ptr->width;
 3256|   204k|   unsigned int pass = png_ptr->pass;
 3257|   204k|   png_bytep end_ptr = 0;
 3258|   204k|   png_byte end_byte = 0;
 3259|   204k|   unsigned int end_mask;
 3260|       |
 3261|   204k|   png_debug(1, "in png_combine_row");
  ------------------
  |  |  148|   204k|#  define png_debug(l, m) ((void)0)
  ------------------
 3262|       |
 3263|       |   /* Added in 1.5.6: it should not be possible to enter this routine until at
 3264|       |    * least one row has been read from the PNG data and transformed.
 3265|       |    */
 3266|   204k|   if (pixel_depth == 0)
  ------------------
  |  Branch (3266:8): [True: 0, False: 204k]
  ------------------
 3267|      0|      png_error(png_ptr, "internal row logic error");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3268|       |
 3269|       |   /* Added in 1.5.4: the pixel depth should match the information returned by
 3270|       |    * any call to png_read_update_info at this point.  Do not continue if we got
 3271|       |    * this wrong.
 3272|       |    */
 3273|   204k|   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=
  ------------------
  |  Branch (3273:8): [True: 204k, False: 0]
  |  Branch (3273:39): [True: 0, False: 204k]
  ------------------
 3274|   204k|          PNG_ROWBYTES(pixel_depth, row_width))
  ------------------
  |  |  731|   204k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 204k, False: 0]
  |  |  ------------------
  |  |  732|   204k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|   204k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 3275|      0|      png_error(png_ptr, "internal row size calculation error");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3276|       |
 3277|       |   /* Don't expect this to ever happen: */
 3278|   204k|   if (row_width == 0)
  ------------------
  |  Branch (3278:8): [True: 0, False: 204k]
  ------------------
 3279|      0|      png_error(png_ptr, "internal row width error");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3280|       |
 3281|       |   /* Preserve the last byte in cases where only part of it will be overwritten,
 3282|       |    * the multiply below may overflow, we don't care because ANSI-C guarantees
 3283|       |    * we get the low bits.
 3284|       |    */
 3285|   204k|   end_mask = (pixel_depth * row_width) & 7;
 3286|   204k|   if (end_mask != 0)
  ------------------
  |  Branch (3286:8): [True: 0, False: 204k]
  ------------------
 3287|      0|   {
 3288|       |      /* end_ptr == NULL is a flag to say do nothing */
 3289|      0|      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
  ------------------
  |  |  731|      0|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 0, False: 0]
  |  |  ------------------
  |  |  732|      0|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|      0|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 3290|      0|      end_byte = *end_ptr;
 3291|      0|#     ifdef PNG_READ_PACKSWAP_SUPPORTED
 3292|      0|      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|      0|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (3292:11): [True: 0, False: 0]
  ------------------
 3293|       |         /* little-endian byte */
 3294|      0|         end_mask = (unsigned int)(0xff << end_mask);
 3295|       |
 3296|      0|      else /* big-endian byte */
 3297|      0|#     endif
 3298|      0|      end_mask = 0xff >> end_mask;
 3299|       |      /* end_mask is now the bits to *keep* from the destination row */
 3300|      0|   }
 3301|       |
 3302|       |   /* For non-interlaced images this reduces to a memcpy(). A memcpy()
 3303|       |    * will also happen if interlacing isn't supported or if the application
 3304|       |    * does not call png_set_interlace_handling().  In the latter cases the
 3305|       |    * caller just gets a sequence of the unexpanded rows from each interlace
 3306|       |    * pass.
 3307|       |    */
 3308|   204k|#ifdef PNG_READ_INTERLACING_SUPPORTED
 3309|   204k|   if (png_ptr->interlaced != 0 &&
  ------------------
  |  Branch (3309:8): [True: 82.0k, False: 122k]
  ------------------
 3310|   204k|       (png_ptr->transformations & PNG_INTERLACE) != 0 &&
  ------------------
  |  |  635|  82.0k|#define PNG_INTERLACE           0x0002U
  ------------------
  |  Branch (3310:8): [True: 82.0k, False: 0]
  ------------------
 3311|   204k|       pass < 6 && (display == 0 ||
  ------------------
  |  Branch (3311:8): [True: 56.6k, False: 25.4k]
  |  Branch (3311:21): [True: 56.6k, False: 0]
  ------------------
 3312|       |       /* The following copies everything for 'display' on passes 0, 2 and 4. */
 3313|  56.6k|       (display == 1 && (pass & 1) != 0)))
  ------------------
  |  Branch (3313:9): [True: 0, False: 0]
  |  Branch (3313:25): [True: 0, False: 0]
  ------------------
 3314|  56.6k|   {
 3315|       |      /* Narrow images may have no bits in a pass; the caller should handle
 3316|       |       * this, but this test is cheap:
 3317|       |       */
 3318|  56.6k|      if (row_width <= PNG_PASS_START_COL(pass))
  ------------------
  |  | 2548|  56.6k|#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)
  ------------------
  |  Branch (3318:11): [True: 0, False: 56.6k]
  ------------------
 3319|      0|         return;
 3320|       |
 3321|  56.6k|      if (pixel_depth < 8)
  ------------------
  |  Branch (3321:11): [True: 0, False: 56.6k]
  ------------------
 3322|      0|      {
 3323|       |         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
 3324|       |          * into 32 bits, then a single loop over the bytes using the four byte
 3325|       |          * values in the 32-bit mask can be used.  For the 'display' option the
 3326|       |          * expanded mask may also not require any masking within a byte.  To
 3327|       |          * make this work the PACKSWAP option must be taken into account - it
 3328|       |          * simply requires the pixels to be reversed in each byte.
 3329|       |          *
 3330|       |          * The 'regular' case requires a mask for each of the first 6 passes,
 3331|       |          * the 'display' case does a copy for the even passes in the range
 3332|       |          * 0..6.  This has already been handled in the test above.
 3333|       |          *
 3334|       |          * The masks are arranged as four bytes with the first byte to use in
 3335|       |          * the lowest bits (little-endian) regardless of the order (PACKSWAP or
 3336|       |          * not) of the pixels in each byte.
 3337|       |          *
 3338|       |          * NOTE: the whole of this logic depends on the caller of this function
 3339|       |          * only calling it on rows appropriate to the pass.  This function only
 3340|       |          * understands the 'x' logic; the 'y' logic is handled by the caller.
 3341|       |          *
 3342|       |          * The following defines allow generation of compile time constant bit
 3343|       |          * masks for each pixel depth and each possibility of swapped or not
 3344|       |          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,
 3345|       |          * is in the range 0..7; and the result is 1 if the pixel is to be
 3346|       |          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'
 3347|       |          * for the block method.
 3348|       |          *
 3349|       |          * With some compilers a compile time expression of the general form:
 3350|       |          *
 3351|       |          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)
 3352|       |          *
 3353|       |          * Produces warnings with values of 'shift' in the range 33 to 63
 3354|       |          * because the right hand side of the ?: expression is evaluated by
 3355|       |          * the compiler even though it isn't used.  Microsoft Visual C (various
 3356|       |          * versions) and the Intel C compiler are known to do this.  To avoid
 3357|       |          * this the following macros are used in 1.5.6.  This is a temporary
 3358|       |          * solution to avoid destabilizing the code during the release process.
 3359|       |          */
 3360|      0|#        if PNG_USE_COMPILE_TIME_MASKS
 3361|      0|#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))
 3362|      0|#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))
 3363|       |#        else
 3364|       |#           define PNG_LSR(x,s) ((x)>>(s))
 3365|       |#           define PNG_LSL(x,s) ((x)<<(s))
 3366|       |#        endif
 3367|      0|#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\
 3368|      0|           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)
 3369|      0|#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\
 3370|      0|           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)
 3371|       |
 3372|       |         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
 3373|       |          * little endian - the first pixel is at bit 0 - however the extra
 3374|       |          * parameter 's' can be set to cause the mask position to be swapped
 3375|       |          * within each byte, to match the PNG format.  This is done by XOR of
 3376|       |          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.
 3377|       |          */
 3378|      0|#        define PIXEL_MASK(p,x,d,s) \
 3379|      0|            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
 3380|       |
 3381|       |         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
 3382|       |          */
 3383|      0|#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
 3384|      0|#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
 3385|       |
 3386|       |         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
 3387|       |          * cases the result needs replicating, for the 4-bpp case the above
 3388|       |          * generates a full 32 bits.
 3389|       |          */
 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
 3391|       |
 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
 3395|       |
 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
 3399|       |
 3400|      0|#if PNG_USE_COMPILE_TIME_MASKS
 3401|       |         /* Utility macros to construct all the masks for a depth/swap
 3402|       |          * combination.  The 's' parameter says whether the format is PNG
 3403|       |          * (big endian bytes) or not.  Only the three odd-numbered passes are
 3404|       |          * required for the display/block algorithm.
 3405|       |          */
 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
 3408|       |
 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
 3410|       |
 3411|      0|#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
 3412|       |
 3413|       |         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
 3414|       |          * then pass:
 3415|       |          */
 3416|      0|         static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
 3417|      0|         {
 3418|       |            /* Little-endian byte masks for PACKSWAP */
 3419|      0|            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
 3420|       |            /* Normal (big-endian byte) masks - PNG format */
 3421|      0|            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
  ------------------
  |  | 3406|      0|#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  | 3407|      0|            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |                           S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3392|      0|#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3393|      0|            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
  |  |  |  | 3394|      0|            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
 3422|      0|         };
 3423|       |
 3424|       |         /* display_mask has only three entries for the odd passes, so index by
 3425|       |          * pass>>1.
 3426|       |          */
 3427|      0|         static const png_uint_32 display_mask[2][3][3] =
 3428|      0|         {
 3429|       |            /* Little-endian byte masks for PACKSWAP */
 3430|      0|            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
 3431|       |            /* Normal (big-endian byte) masks - PNG format */
 3432|      0|            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
                          { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
  ------------------
  |  | 3409|      0|#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  |  |               #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
  |  |  ------------------
  |  |  |  | 3396|      0|#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
  |  |  |  |  ------------------
  |  |  |  |  |  | 3390|      0|#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:36): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:40): [Folded - Ignored]
  |  |  |  |  |  |  |  Branch (3390:59): [Folded - Ignored]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 3397|      0|            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
  |  |  |  | 3398|      0|            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
  |  |  ------------------
  ------------------
 3433|      0|         };
 3434|       |
 3435|      0|#        define MASK(pass,depth,display,png)\
 3436|      0|            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
 3437|      0|               row_mask[png][DEPTH_INDEX(depth)][pass])
 3438|       |
 3439|       |#else /* !PNG_USE_COMPILE_TIME_MASKS */
 3440|       |         /* This is the runtime alternative: it seems unlikely that this will
 3441|       |          * ever be either smaller or faster than the compile time approach.
 3442|       |          */
 3443|       |#        define MASK(pass,depth,display,png)\
 3444|       |            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
 3445|       |#endif /* !USE_COMPILE_TIME_MASKS */
 3446|       |
 3447|       |         /* Use the appropriate mask to copy the required bits.  In some cases
 3448|       |          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
 3449|       |          * the number of pixels, but the code copies bytes, so it is necessary
 3450|       |          * to special case the end.
 3451|       |          */
 3452|      0|         png_uint_32 pixels_per_byte = 8 / pixel_depth;
 3453|      0|         png_uint_32 mask;
 3454|       |
 3455|      0|#        ifdef PNG_READ_PACKSWAP_SUPPORTED
 3456|      0|         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|      0|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (3456:14): [True: 0, False: 0]
  ------------------
 3457|      0|            mask = MASK(pass, pixel_depth, display, 0);
  ------------------
  |  | 3436|      0|            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
  |  |  ------------------
  |  |  |  | 3411|      0|#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3411:33): [True: 0, False: 0]
  |  |  |  |  |  Branch (3411:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (3436:14): [True: 0, False: 0]
  |  |  ------------------
  |  | 3437|      0|               row_mask[png][DEPTH_INDEX(depth)][pass])
  |  |  ------------------
  |  |  |  | 3411|      0|#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3411:33): [True: 0, False: 0]
  |  |  |  |  |  Branch (3411:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3458|       |
 3459|      0|         else
 3460|      0|#        endif
 3461|      0|         mask = MASK(pass, pixel_depth, display, 1);
  ------------------
  |  | 3436|      0|            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
  |  |  ------------------
  |  |  |  | 3411|      0|#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3411:33): [True: 0, False: 0]
  |  |  |  |  |  Branch (3411:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (3436:14): [True: 0, False: 0]
  |  |  ------------------
  |  | 3437|      0|               row_mask[png][DEPTH_INDEX(depth)][pass])
  |  |  ------------------
  |  |  |  | 3411|      0|#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3411:33): [True: 0, False: 0]
  |  |  |  |  |  Branch (3411:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3462|       |
 3463|      0|         for (;;)
 3464|      0|         {
 3465|      0|            png_uint_32 m;
 3466|       |
 3467|       |            /* It doesn't matter in the following if png_uint_32 has more than
 3468|       |             * 32 bits because the high bits always match those in m<<24; it is,
 3469|       |             * however, essential to use OR here, not +, because of this.
 3470|       |             */
 3471|      0|            m = mask;
 3472|      0|            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */
 3473|      0|            m &= 0xff;
 3474|       |
 3475|      0|            if (m != 0) /* something to copy */
  ------------------
  |  Branch (3475:17): [True: 0, False: 0]
  ------------------
 3476|      0|            {
 3477|      0|               if (m != 0xff)
  ------------------
  |  Branch (3477:20): [True: 0, False: 0]
  ------------------
 3478|      0|                  *dp = (png_byte)((*dp & ~m) | (*sp & m));
 3479|      0|               else
 3480|      0|                  *dp = *sp;
 3481|      0|            }
 3482|       |
 3483|       |            /* NOTE: this may overwrite the last byte with garbage if the image
 3484|       |             * is not an exact number of bytes wide; libpng has always done
 3485|       |             * this.
 3486|       |             */
 3487|      0|            if (row_width <= pixels_per_byte)
  ------------------
  |  Branch (3487:17): [True: 0, False: 0]
  ------------------
 3488|      0|               break; /* May need to restore part of the last byte */
 3489|       |
 3490|      0|            row_width -= pixels_per_byte;
 3491|      0|            ++dp;
 3492|      0|            ++sp;
 3493|      0|         }
 3494|      0|      }
 3495|       |
 3496|  56.6k|      else /* pixel_depth >= 8 */
 3497|  56.6k|      {
 3498|  56.6k|         unsigned int bytes_to_copy, bytes_to_jump;
 3499|       |
 3500|       |         /* Validate the depth - it must be a multiple of 8 */
 3501|  56.6k|         if (pixel_depth & 7)
  ------------------
  |  Branch (3501:14): [True: 0, False: 56.6k]
  ------------------
 3502|      0|            png_error(png_ptr, "invalid user transform pixel depth");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 3503|       |
 3504|  56.6k|         pixel_depth >>= 3; /* now in bytes */
 3505|  56.6k|         row_width *= pixel_depth;
 3506|       |
 3507|       |         /* Regardless of pass number the Adam 7 interlace always results in a
 3508|       |          * fixed number of pixels to copy then to skip.  There may be a
 3509|       |          * different number of pixels to skip at the start though.
 3510|       |          */
 3511|  56.6k|         {
 3512|  56.6k|            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;
  ------------------
  |  | 2548|  56.6k|#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)
  ------------------
 3513|       |
 3514|  56.6k|            row_width -= offset;
 3515|  56.6k|            dp += offset;
 3516|  56.6k|            sp += offset;
 3517|  56.6k|         }
 3518|       |
 3519|       |         /* Work out the bytes to copy. */
 3520|  56.6k|         if (display != 0)
  ------------------
  |  Branch (3520:14): [True: 0, False: 56.6k]
  ------------------
 3521|      0|         {
 3522|       |            /* When doing the 'block' algorithm the pixel in the pass gets
 3523|       |             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
 3524|       |             * passes are skipped above - the entire expanded row is copied.
 3525|       |             */
 3526|      0|            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;
 3527|       |
 3528|       |            /* But don't allow this number to exceed the actual row width. */
 3529|      0|            if (bytes_to_copy > row_width)
  ------------------
  |  Branch (3529:17): [True: 0, False: 0]
  ------------------
 3530|      0|               bytes_to_copy = (unsigned int)/*SAFE*/row_width;
 3531|      0|         }
 3532|       |
 3533|  56.6k|         else /* normal row; Adam7 only ever gives us one pixel to copy. */
 3534|  56.6k|            bytes_to_copy = pixel_depth;
 3535|       |
 3536|       |         /* In Adam7 there is a constant offset between where the pixels go. */
 3537|  56.6k|         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;
  ------------------
  |  | 2556|  56.6k|#define PNG_PASS_COL_OFFSET(pass) (1<<((7-(pass))>>1))
  ------------------
 3538|       |
 3539|       |         /* And simply copy these bytes.  Some optimization is possible here,
 3540|       |          * depending on the value of 'bytes_to_copy'.  Special case the low
 3541|       |          * byte counts, which we know to be frequent.
 3542|       |          *
 3543|       |          * Notice that these cases all 'return' rather than 'break' - this
 3544|       |          * avoids an unnecessary test on whether to restore the last byte
 3545|       |          * below.
 3546|       |          */
 3547|  56.6k|         switch (bytes_to_copy)
 3548|  56.6k|         {
 3549|      0|            case 1:
  ------------------
  |  Branch (3549:13): [True: 0, False: 56.6k]
  ------------------
 3550|      0|               for (;;)
 3551|      0|               {
 3552|      0|                  *dp = *sp;
 3553|       |
 3554|      0|                  if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3554:23): [True: 0, False: 0]
  ------------------
 3555|      0|                     return;
 3556|       |
 3557|      0|                  dp += bytes_to_jump;
 3558|      0|                  sp += bytes_to_jump;
 3559|      0|                  row_width -= bytes_to_jump;
 3560|      0|               }
 3561|       |
 3562|      0|            case 2:
  ------------------
  |  Branch (3562:13): [True: 0, False: 56.6k]
  ------------------
 3563|       |               /* There is a possibility of a partial copy at the end here; this
 3564|       |                * slows the code down somewhat.
 3565|       |                */
 3566|      0|               do
 3567|      0|               {
 3568|      0|                  dp[0] = sp[0]; dp[1] = sp[1];
 3569|       |
 3570|      0|                  if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3570:23): [True: 0, False: 0]
  ------------------
 3571|      0|                     return;
 3572|       |
 3573|      0|                  sp += bytes_to_jump;
 3574|      0|                  dp += bytes_to_jump;
 3575|      0|                  row_width -= bytes_to_jump;
 3576|      0|               }
 3577|      0|               while (row_width > 1);
  ------------------
  |  Branch (3577:23): [True: 0, False: 0]
  ------------------
 3578|       |
 3579|       |               /* And there can only be one byte left at this point: */
 3580|      0|               *dp = *sp;
 3581|      0|               return;
 3582|       |
 3583|  2.91k|            case 3:
  ------------------
  |  Branch (3583:13): [True: 2.91k, False: 53.7k]
  ------------------
 3584|       |               /* This can only be the RGB case, so each copy is exactly one
 3585|       |                * pixel and it is not necessary to check for a partial copy.
 3586|       |                */
 3587|  2.91k|               for (;;)
 3588|  33.7k|               {
 3589|  33.7k|                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];
 3590|       |
 3591|  33.7k|                  if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3591:23): [True: 2.91k, False: 30.8k]
  ------------------
 3592|  2.91k|                     return;
 3593|       |
 3594|  30.8k|                  sp += bytes_to_jump;
 3595|  30.8k|                  dp += bytes_to_jump;
 3596|  30.8k|                  row_width -= bytes_to_jump;
 3597|  30.8k|               }
 3598|       |
 3599|  53.7k|            default:
  ------------------
  |  Branch (3599:13): [True: 53.7k, False: 2.91k]
  ------------------
 3600|  53.7k|#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE
 3601|       |               /* Check for double byte alignment and, if possible, use a
 3602|       |                * 16-bit copy.  Don't attempt this for narrow images - ones that
 3603|       |                * are less than an interlace panel wide.  Don't attempt it for
 3604|       |                * wide bytes_to_copy either - use the memcpy there.
 3605|       |                */
 3606|  53.7k|               if (bytes_to_copy < 16 /*else use memcpy*/ &&
  ------------------
  |  Branch (3606:20): [True: 53.7k, False: 0]
  ------------------
 3607|  53.7k|                   png_isaligned(dp, png_uint_16) &&
  ------------------
  |  |  599|   107k|   (((type)(size_t)((const void*)(ptr)) & (type)(png_alignof(type)-1)) == 0)
  |  |  ------------------
  |  |  |  |  584|  53.7k|#  define png_alignof(type) (sizeof(type))
  |  |  ------------------
  |  |  |  Branch (599:4): [True: 53.7k, False: 0]
  |  |  ------------------
  ------------------
 3608|  53.7k|                   png_isaligned(sp, png_uint_16) &&
  ------------------
  |  |  599|   107k|   (((type)(size_t)((const void*)(ptr)) & (type)(png_alignof(type)-1)) == 0)
  |  |  ------------------
  |  |  |  |  584|  53.7k|#  define png_alignof(type) (sizeof(type))
  |  |  ------------------
  |  |  |  Branch (599:4): [True: 53.7k, False: 0]
  |  |  ------------------
  ------------------
 3609|  53.7k|                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&
  ------------------
  |  Branch (3609:20): [True: 53.7k, False: 0]
  ------------------
 3610|  53.7k|                   bytes_to_jump % (sizeof (png_uint_16)) == 0)
  ------------------
  |  Branch (3610:20): [True: 53.7k, False: 0]
  ------------------
 3611|  53.7k|               {
 3612|       |                  /* Everything is aligned for png_uint_16 copies, but try for
 3613|       |                   * png_uint_32 first.
 3614|       |                   */
 3615|  53.7k|                  if (png_isaligned(dp, png_uint_32) &&
  ------------------
  |  |  599|   107k|   (((type)(size_t)((const void*)(ptr)) & (type)(png_alignof(type)-1)) == 0)
  |  |  ------------------
  |  |  |  |  584|  53.7k|#  define png_alignof(type) (sizeof(type))
  |  |  ------------------
  |  |  |  Branch (599:4): [True: 53.7k, False: 0]
  |  |  ------------------
  ------------------
 3616|  53.7k|                      png_isaligned(sp, png_uint_32) &&
  ------------------
  |  |  599|   107k|   (((type)(size_t)((const void*)(ptr)) & (type)(png_alignof(type)-1)) == 0)
  |  |  ------------------
  |  |  |  |  584|  53.7k|#  define png_alignof(type) (sizeof(type))
  |  |  ------------------
  |  |  |  Branch (599:4): [True: 53.7k, False: 0]
  |  |  ------------------
  ------------------
 3617|  53.7k|                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&
  ------------------
  |  Branch (3617:23): [True: 53.7k, False: 0]
  ------------------
 3618|  53.7k|                      bytes_to_jump % (sizeof (png_uint_32)) == 0)
  ------------------
  |  Branch (3618:23): [True: 53.7k, False: 0]
  ------------------
 3619|  53.7k|                  {
 3620|  53.7k|                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);
  ------------------
  |  |  513|  53.7k|#  define png_aligncast(type, value) ((void*)(value))
  ------------------
 3621|  53.7k|                     png_const_uint_32p sp32 = png_aligncastconst(
  ------------------
  |  |  514|  53.7k|#  define png_aligncastconst(type, value) ((const void*)(value))
  ------------------
 3622|  53.7k|                         png_const_uint_32p, sp);
 3623|  53.7k|                     size_t skip = (bytes_to_jump-bytes_to_copy) /
 3624|  53.7k|                         (sizeof (png_uint_32));
 3625|       |
 3626|  53.7k|                     do
 3627|   892k|                     {
 3628|   892k|                        size_t c = bytes_to_copy;
 3629|   892k|                        do
 3630|   892k|                        {
 3631|   892k|                           *dp32++ = *sp32++;
 3632|   892k|                           c -= (sizeof (png_uint_32));
 3633|   892k|                        }
 3634|   892k|                        while (c > 0);
  ------------------
  |  Branch (3634:32): [True: 0, False: 892k]
  ------------------
 3635|       |
 3636|   892k|                        if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3636:29): [True: 53.7k, False: 839k]
  ------------------
 3637|  53.7k|                           return;
 3638|       |
 3639|   839k|                        dp32 += skip;
 3640|   839k|                        sp32 += skip;
 3641|   839k|                        row_width -= bytes_to_jump;
 3642|   839k|                     }
 3643|   839k|                     while (bytes_to_copy <= row_width);
  ------------------
  |  Branch (3643:29): [True: 839k, False: 0]
  ------------------
 3644|       |
 3645|       |                     /* Get to here when the row_width truncates the final copy.
 3646|       |                      * There will be 1-3 bytes left to copy, so don't try the
 3647|       |                      * 16-bit loop below.
 3648|       |                      */
 3649|      0|                     dp = (png_bytep)dp32;
 3650|      0|                     sp = (png_const_bytep)sp32;
 3651|      0|                     do
 3652|      0|                        *dp++ = *sp++;
 3653|      0|                     while (--row_width > 0);
  ------------------
  |  Branch (3653:29): [True: 0, False: 0]
  ------------------
 3654|      0|                     return;
 3655|  53.7k|                  }
 3656|       |
 3657|       |                  /* Else do it in 16-bit quantities, but only if the size is
 3658|       |                   * not too large.
 3659|       |                   */
 3660|      0|                  else
 3661|      0|                  {
 3662|      0|                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);
  ------------------
  |  |  513|      0|#  define png_aligncast(type, value) ((void*)(value))
  ------------------
 3663|      0|                     png_const_uint_16p sp16 = png_aligncastconst(
  ------------------
  |  |  514|      0|#  define png_aligncastconst(type, value) ((const void*)(value))
  ------------------
 3664|      0|                        png_const_uint_16p, sp);
 3665|      0|                     size_t skip = (bytes_to_jump-bytes_to_copy) /
 3666|      0|                        (sizeof (png_uint_16));
 3667|       |
 3668|      0|                     do
 3669|      0|                     {
 3670|      0|                        size_t c = bytes_to_copy;
 3671|      0|                        do
 3672|      0|                        {
 3673|      0|                           *dp16++ = *sp16++;
 3674|      0|                           c -= (sizeof (png_uint_16));
 3675|      0|                        }
 3676|      0|                        while (c > 0);
  ------------------
  |  Branch (3676:32): [True: 0, False: 0]
  ------------------
 3677|       |
 3678|      0|                        if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3678:29): [True: 0, False: 0]
  ------------------
 3679|      0|                           return;
 3680|       |
 3681|      0|                        dp16 += skip;
 3682|      0|                        sp16 += skip;
 3683|      0|                        row_width -= bytes_to_jump;
 3684|      0|                     }
 3685|      0|                     while (bytes_to_copy <= row_width);
  ------------------
  |  Branch (3685:29): [True: 0, False: 0]
  ------------------
 3686|       |
 3687|       |                     /* End of row - 1 byte left, bytes_to_copy > row_width: */
 3688|      0|                     dp = (png_bytep)dp16;
 3689|      0|                     sp = (png_const_bytep)sp16;
 3690|      0|                     do
 3691|      0|                        *dp++ = *sp++;
 3692|      0|                     while (--row_width > 0);
  ------------------
  |  Branch (3692:29): [True: 0, False: 0]
  ------------------
 3693|      0|                     return;
 3694|      0|                  }
 3695|  53.7k|               }
 3696|      0|#endif /* ALIGN_TYPE code */
 3697|       |
 3698|       |               /* The true default - use a memcpy: */
 3699|      0|               for (;;)
 3700|      0|               {
 3701|      0|                  memcpy(dp, sp, bytes_to_copy);
 3702|       |
 3703|      0|                  if (row_width <= bytes_to_jump)
  ------------------
  |  Branch (3703:23): [True: 0, False: 0]
  ------------------
 3704|      0|                     return;
 3705|       |
 3706|      0|                  sp += bytes_to_jump;
 3707|      0|                  dp += bytes_to_jump;
 3708|      0|                  row_width -= bytes_to_jump;
 3709|      0|                  if (bytes_to_copy > row_width)
  ------------------
  |  Branch (3709:23): [True: 0, False: 0]
  ------------------
 3710|      0|                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;
 3711|      0|               }
 3712|  56.6k|         }
 3713|       |
 3714|       |         /* NOT REACHED*/
 3715|  56.6k|      } /* pixel_depth >= 8 */
 3716|       |
 3717|       |      /* Here if pixel_depth < 8 to check 'end_ptr' below. */
 3718|  56.6k|   }
 3719|   148k|   else
 3720|   148k|#endif /* READ_INTERLACING */
 3721|       |
 3722|       |   /* If here then the switch above wasn't used so just memcpy the whole row
 3723|       |    * from the temporary row buffer (notice that this overwrites the end of the
 3724|       |    * destination row if it is a partial byte.)
 3725|       |    */
 3726|   148k|   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
  ------------------
  |  |  731|   148k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 148k, False: 0]
  |  |  ------------------
  |  |  732|   148k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|   148k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 3727|       |
 3728|       |   /* Restore the overwritten bits from the last byte if necessary. */
 3729|   148k|   if (end_ptr != NULL)
  ------------------
  |  Branch (3729:8): [True: 0, False: 148k]
  ------------------
 3730|      0|      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));
 3731|   148k|}
OSS_FUZZ_png_do_read_interlace:
 3737|  56.6k|{
 3738|  56.6k|   png_debug(1, "in png_do_read_interlace");
  ------------------
  |  |  148|  56.6k|#  define png_debug(l, m) ((void)0)
  ------------------
 3739|  56.6k|   if (row != NULL && row_info != NULL)
  ------------------
  |  Branch (3739:8): [True: 56.6k, False: 0]
  |  Branch (3739:23): [True: 56.6k, False: 0]
  ------------------
 3740|  56.6k|   {
 3741|  56.6k|      png_uint_32 final_width;
 3742|       |
 3743|  56.6k|      final_width = row_info->width * png_pass_inc[pass];
 3744|       |
 3745|  56.6k|      switch (row_info->pixel_depth)
 3746|  56.6k|      {
 3747|      0|         case 1:
  ------------------
  |  Branch (3747:10): [True: 0, False: 56.6k]
  ------------------
 3748|      0|         {
 3749|      0|            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);
 3750|      0|            png_bytep dp = row + (size_t)((final_width - 1) >> 3);
 3751|      0|            unsigned int sshift, dshift;
 3752|      0|            unsigned int s_start, s_end;
 3753|      0|            int s_inc;
 3754|      0|            int jstop = (int)png_pass_inc[pass];
 3755|      0|            png_byte v;
 3756|      0|            png_uint_32 i;
 3757|      0|            int j;
 3758|       |
 3759|      0|#ifdef PNG_READ_PACKSWAP_SUPPORTED
 3760|      0|            if ((transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|      0|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (3760:17): [True: 0, False: 0]
  ------------------
 3761|      0|            {
 3762|      0|                sshift = ((row_info->width + 7) & 0x07);
 3763|      0|                dshift = ((final_width + 7) & 0x07);
 3764|      0|                s_start = 7;
 3765|      0|                s_end = 0;
 3766|      0|                s_inc = -1;
 3767|      0|            }
 3768|       |
 3769|      0|            else
 3770|      0|#endif
 3771|      0|            {
 3772|      0|                sshift = 7 - ((row_info->width + 7) & 0x07);
 3773|      0|                dshift = 7 - ((final_width + 7) & 0x07);
 3774|      0|                s_start = 0;
 3775|      0|                s_end = 7;
 3776|      0|                s_inc = 1;
 3777|      0|            }
 3778|       |
 3779|      0|            for (i = 0; i < row_info->width; i++)
  ------------------
  |  Branch (3779:25): [True: 0, False: 0]
  ------------------
 3780|      0|            {
 3781|      0|               v = (png_byte)((*sp >> sshift) & 0x01);
 3782|      0|               for (j = 0; j < jstop; j++)
  ------------------
  |  Branch (3782:28): [True: 0, False: 0]
  ------------------
 3783|      0|               {
 3784|      0|                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));
 3785|      0|                  tmp |= (unsigned int)(v << dshift);
 3786|      0|                  *dp = (png_byte)(tmp & 0xff);
 3787|       |
 3788|      0|                  if (dshift == s_end)
  ------------------
  |  Branch (3788:23): [True: 0, False: 0]
  ------------------
 3789|      0|                  {
 3790|      0|                     dshift = s_start;
 3791|      0|                     dp--;
 3792|      0|                  }
 3793|       |
 3794|      0|                  else
 3795|      0|                     dshift = (unsigned int)((int)dshift + s_inc);
 3796|      0|               }
 3797|       |
 3798|      0|               if (sshift == s_end)
  ------------------
  |  Branch (3798:20): [True: 0, False: 0]
  ------------------
 3799|      0|               {
 3800|      0|                  sshift = s_start;
 3801|      0|                  sp--;
 3802|      0|               }
 3803|       |
 3804|      0|               else
 3805|      0|                  sshift = (unsigned int)((int)sshift + s_inc);
 3806|      0|            }
 3807|      0|            break;
 3808|      0|         }
 3809|       |
 3810|      0|         case 2:
  ------------------
  |  Branch (3810:10): [True: 0, False: 56.6k]
  ------------------
 3811|      0|         {
 3812|      0|            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
 3813|      0|            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
 3814|      0|            unsigned int sshift, dshift;
 3815|      0|            unsigned int s_start, s_end;
 3816|      0|            int s_inc;
 3817|      0|            int jstop = (int)png_pass_inc[pass];
 3818|      0|            png_uint_32 i;
 3819|       |
 3820|      0|#ifdef PNG_READ_PACKSWAP_SUPPORTED
 3821|      0|            if ((transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|      0|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (3821:17): [True: 0, False: 0]
  ------------------
 3822|      0|            {
 3823|      0|               sshift = (((row_info->width + 3) & 0x03) << 1);
 3824|      0|               dshift = (((final_width + 3) & 0x03) << 1);
 3825|      0|               s_start = 6;
 3826|      0|               s_end = 0;
 3827|      0|               s_inc = -2;
 3828|      0|            }
 3829|       |
 3830|      0|            else
 3831|      0|#endif
 3832|      0|            {
 3833|      0|               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);
 3834|      0|               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);
 3835|      0|               s_start = 0;
 3836|      0|               s_end = 6;
 3837|      0|               s_inc = 2;
 3838|      0|            }
 3839|       |
 3840|      0|            for (i = 0; i < row_info->width; i++)
  ------------------
  |  Branch (3840:25): [True: 0, False: 0]
  ------------------
 3841|      0|            {
 3842|      0|               png_byte v;
 3843|      0|               int j;
 3844|       |
 3845|      0|               v = (png_byte)((*sp >> sshift) & 0x03);
 3846|      0|               for (j = 0; j < jstop; j++)
  ------------------
  |  Branch (3846:28): [True: 0, False: 0]
  ------------------
 3847|      0|               {
 3848|      0|                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));
 3849|      0|                  tmp |= (unsigned int)(v << dshift);
 3850|      0|                  *dp = (png_byte)(tmp & 0xff);
 3851|       |
 3852|      0|                  if (dshift == s_end)
  ------------------
  |  Branch (3852:23): [True: 0, False: 0]
  ------------------
 3853|      0|                  {
 3854|      0|                     dshift = s_start;
 3855|      0|                     dp--;
 3856|      0|                  }
 3857|       |
 3858|      0|                  else
 3859|      0|                     dshift = (unsigned int)((int)dshift + s_inc);
 3860|      0|               }
 3861|       |
 3862|      0|               if (sshift == s_end)
  ------------------
  |  Branch (3862:20): [True: 0, False: 0]
  ------------------
 3863|      0|               {
 3864|      0|                  sshift = s_start;
 3865|      0|                  sp--;
 3866|      0|               }
 3867|       |
 3868|      0|               else
 3869|      0|                  sshift = (unsigned int)((int)sshift + s_inc);
 3870|      0|            }
 3871|      0|            break;
 3872|      0|         }
 3873|       |
 3874|      0|         case 4:
  ------------------
  |  Branch (3874:10): [True: 0, False: 56.6k]
  ------------------
 3875|      0|         {
 3876|      0|            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);
 3877|      0|            png_bytep dp = row + (size_t)((final_width - 1) >> 1);
 3878|      0|            unsigned int sshift, dshift;
 3879|      0|            unsigned int s_start, s_end;
 3880|      0|            int s_inc;
 3881|      0|            png_uint_32 i;
 3882|      0|            int jstop = (int)png_pass_inc[pass];
 3883|       |
 3884|      0|#ifdef PNG_READ_PACKSWAP_SUPPORTED
 3885|      0|            if ((transformations & PNG_PACKSWAP) != 0)
  ------------------
  |  |  650|      0|#define PNG_PACKSWAP           0x10000U
  ------------------
  |  Branch (3885:17): [True: 0, False: 0]
  ------------------
 3886|      0|            {
 3887|      0|               sshift = (((row_info->width + 1) & 0x01) << 2);
 3888|      0|               dshift = (((final_width + 1) & 0x01) << 2);
 3889|      0|               s_start = 4;
 3890|      0|               s_end = 0;
 3891|      0|               s_inc = -4;
 3892|      0|            }
 3893|       |
 3894|      0|            else
 3895|      0|#endif
 3896|      0|            {
 3897|      0|               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);
 3898|      0|               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);
 3899|      0|               s_start = 0;
 3900|      0|               s_end = 4;
 3901|      0|               s_inc = 4;
 3902|      0|            }
 3903|       |
 3904|      0|            for (i = 0; i < row_info->width; i++)
  ------------------
  |  Branch (3904:25): [True: 0, False: 0]
  ------------------
 3905|      0|            {
 3906|      0|               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);
 3907|      0|               int j;
 3908|       |
 3909|      0|               for (j = 0; j < jstop; j++)
  ------------------
  |  Branch (3909:28): [True: 0, False: 0]
  ------------------
 3910|      0|               {
 3911|      0|                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));
 3912|      0|                  tmp |= (unsigned int)(v << dshift);
 3913|      0|                  *dp = (png_byte)(tmp & 0xff);
 3914|       |
 3915|      0|                  if (dshift == s_end)
  ------------------
  |  Branch (3915:23): [True: 0, False: 0]
  ------------------
 3916|      0|                  {
 3917|      0|                     dshift = s_start;
 3918|      0|                     dp--;
 3919|      0|                  }
 3920|       |
 3921|      0|                  else
 3922|      0|                     dshift = (unsigned int)((int)dshift + s_inc);
 3923|      0|               }
 3924|       |
 3925|      0|               if (sshift == s_end)
  ------------------
  |  Branch (3925:20): [True: 0, False: 0]
  ------------------
 3926|      0|               {
 3927|      0|                  sshift = s_start;
 3928|      0|                  sp--;
 3929|      0|               }
 3930|       |
 3931|      0|               else
 3932|      0|                  sshift = (unsigned int)((int)sshift + s_inc);
 3933|      0|            }
 3934|      0|            break;
 3935|      0|         }
 3936|       |
 3937|  56.6k|         default:
  ------------------
  |  Branch (3937:10): [True: 56.6k, False: 0]
  ------------------
 3938|  56.6k|         {
 3939|  56.6k|            size_t pixel_bytes = (row_info->pixel_depth >> 3);
 3940|       |
 3941|  56.6k|            png_bytep sp = row + (size_t)(row_info->width - 1)
 3942|  56.6k|                * pixel_bytes;
 3943|       |
 3944|  56.6k|            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;
 3945|       |
 3946|  56.6k|            int jstop = (int)png_pass_inc[pass];
 3947|  56.6k|            png_uint_32 i;
 3948|       |
 3949|   983k|            for (i = 0; i < row_info->width; i++)
  ------------------
  |  Branch (3949:25): [True: 926k, False: 56.6k]
  ------------------
 3950|   926k|            {
 3951|   926k|               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */
 3952|   926k|               int j;
 3953|       |
 3954|   926k|               memcpy(v, sp, pixel_bytes);
 3955|       |
 3956|  3.72M|               for (j = 0; j < jstop; j++)
  ------------------
  |  Branch (3956:28): [True: 2.79M, False: 926k]
  ------------------
 3957|  2.79M|               {
 3958|  2.79M|                  memcpy(dp, v, pixel_bytes);
 3959|  2.79M|                  dp -= pixel_bytes;
 3960|  2.79M|               }
 3961|       |
 3962|   926k|               sp -= pixel_bytes;
 3963|   926k|            }
 3964|  56.6k|            break;
 3965|      0|         }
 3966|  56.6k|      }
 3967|       |
 3968|  56.6k|      row_info->width = final_width;
 3969|  56.6k|      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
  ------------------
  |  |  731|  56.6k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 56.6k, False: 0]
  |  |  ------------------
  |  |  732|  56.6k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  56.6k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 3970|  56.6k|   }
 3971|       |#ifndef PNG_READ_PACKSWAP_SUPPORTED
 3972|       |   PNG_UNUSED(transformations)  /* Silence compiler warning */
 3973|       |#endif
 3974|  56.6k|}
OSS_FUZZ_png_read_filter_row:
 4180|   128k|{
 4181|       |   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
 4182|       |    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic
 4183|       |    * implementations.  See png_init_filter_functions above.
 4184|       |    */
 4185|   128k|   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)
  ------------------
  |  | 1489|   257k|#define PNG_FILTER_VALUE_NONE  0
  ------------------
                 if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)
  ------------------
  |  | 1494|   128k|#define PNG_FILTER_VALUE_LAST  5
  ------------------
  |  Branch (4185:8): [True: 128k, False: 0]
  |  Branch (4185:42): [True: 128k, False: 0]
  ------------------
 4186|   128k|   {
 4187|   128k|      if (pp->read_filter[0] == NULL)
  ------------------
  |  Branch (4187:11): [True: 829, False: 127k]
  ------------------
 4188|    829|         png_init_filter_functions(pp);
 4189|       |
 4190|   128k|      pp->read_filter[filter-1](row_info, row, prev_row);
 4191|   128k|   }
 4192|   128k|}
OSS_FUZZ_png_read_IDAT_data:
 4198|   205k|{
 4199|       |   /* Loop reading IDATs and decompressing the result into output[avail_out] */
 4200|   205k|   png_ptr->zstream.next_out = output;
 4201|   205k|   png_ptr->zstream.avail_out = 0; /* safety: set below */
 4202|       |
 4203|   205k|   if (output == NULL)
  ------------------
  |  Branch (4203:8): [True: 350, False: 205k]
  ------------------
 4204|    350|      avail_out = 0;
 4205|       |
 4206|   205k|   do
 4207|   241k|   {
 4208|   241k|      int ret;
 4209|   241k|      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
 4210|       |
 4211|   241k|      if (png_ptr->zstream.avail_in == 0)
  ------------------
  |  Branch (4211:11): [True: 1.71k, False: 239k]
  ------------------
 4212|  1.71k|      {
 4213|  1.71k|         uInt avail_in;
 4214|  1.71k|         png_bytep buffer;
 4215|       |
 4216|  1.78k|         while (png_ptr->idat_size == 0)
  ------------------
  |  Branch (4216:17): [True: 70, False: 1.71k]
  ------------------
 4217|     70|         {
 4218|     70|            png_crc_finish(png_ptr, 0);
  ------------------
  |  |   25|     70|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 4219|       |
 4220|     70|            png_ptr->idat_size = png_read_chunk_header(png_ptr);
  ------------------
  |  |   22|     70|#define png_read_chunk_header OSS_FUZZ_png_read_chunk_header
  ------------------
 4221|       |            /* This is an error even in the 'check' case because the code just
 4222|       |             * consumed a non-IDAT header.
 4223|       |             */
 4224|     70|            if (png_ptr->chunk_name != png_IDAT)
  ------------------
  |  |  862|     70|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|     70|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|     70|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|     70|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|     70|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|     70|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4224:17): [True: 2, False: 68]
  ------------------
 4225|      2|               png_error(png_ptr, "Not enough image data");
  ------------------
  |  |  252|      2|#define png_error OSS_FUZZ_png_error
  ------------------
 4226|     70|         }
 4227|       |
 4228|  1.71k|         avail_in = png_ptr->IDAT_read_size;
 4229|       |
 4230|  1.71k|         if (avail_in > png_chunk_max(png_ptr))
  ------------------
  |  | 1097|  1.71k|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
  |  Branch (4230:14): [True: 0, False: 1.71k]
  ------------------
 4231|      0|            avail_in = (uInt)/*SAFE*/png_chunk_max(png_ptr);
  ------------------
  |  | 1097|      0|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
 4232|       |
 4233|  1.71k|         if (avail_in > png_ptr->idat_size)
  ------------------
  |  Branch (4233:14): [True: 1.65k, False: 63]
  ------------------
 4234|  1.65k|            avail_in = (uInt)png_ptr->idat_size;
 4235|       |
 4236|       |         /* A PNG with a gradually increasing IDAT size will defeat this attempt
 4237|       |          * to minimize memory usage by causing lots of re-allocs, but
 4238|       |          * realistically doing IDAT_read_size re-allocs is not likely to be a
 4239|       |          * big problem.
 4240|       |          *
 4241|       |          * An error here corresponds to the system being out of memory.
 4242|       |          */
 4243|  1.71k|         buffer = png_read_buffer(png_ptr, avail_in);
 4244|       |
 4245|  1.71k|         if (buffer == NULL)
  ------------------
  |  Branch (4245:14): [True: 0, False: 1.71k]
  ------------------
 4246|      0|            png_chunk_error(png_ptr, "out of memory");
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 4247|       |
 4248|  1.71k|         png_crc_read(png_ptr, buffer, avail_in);
  ------------------
  |  |   24|  1.71k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 4249|  1.71k|         png_ptr->idat_size -= avail_in;
 4250|       |
 4251|  1.71k|         png_ptr->zstream.next_in = buffer;
 4252|  1.71k|         png_ptr->zstream.avail_in = avail_in;
 4253|  1.71k|      }
 4254|       |
 4255|       |      /* And set up the output side. */
 4256|   241k|      if (output != NULL) /* standard read */
  ------------------
  |  Branch (4256:11): [True: 205k, False: 35.9k]
  ------------------
 4257|   205k|      {
 4258|   205k|         uInt out = ZLIB_IO_MAX;
  ------------------
  |  |   53|   205k|#  define ZLIB_IO_MAX ((uInt)-1)
  ------------------
 4259|       |
 4260|   205k|         if (out > avail_out)
  ------------------
  |  Branch (4260:14): [True: 205k, False: 0]
  ------------------
 4261|   205k|            out = (uInt)avail_out;
 4262|       |
 4263|   205k|         avail_out -= out;
 4264|   205k|         png_ptr->zstream.avail_out = out;
 4265|   205k|      }
 4266|       |
 4267|  35.9k|      else /* after last row, checking for end */
 4268|  35.9k|      {
 4269|  35.9k|         png_ptr->zstream.next_out = tmpbuf;
 4270|  35.9k|         png_ptr->zstream.avail_out = (sizeof tmpbuf);
 4271|  35.9k|      }
 4272|       |
 4273|       |      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
 4274|       |       * process.  If the LZ stream is truncated the sequential reader will
 4275|       |       * terminally damage the stream, above, by reading the chunk header of the
 4276|       |       * following chunk (it then exits with png_error).
 4277|       |       *
 4278|       |       * TODO: deal more elegantly with truncated IDAT lists.
 4279|       |       */
 4280|   241k|      ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);
  ------------------
  |  | 1554|   241k|#  define PNG_INFLATE(pp, flush) png_zlib_inflate(pp, flush)
  |  |  ------------------
  |  |  |  |   42|   241k|#define png_zlib_inflate OSS_FUZZ_png_zlib_inflate
  |  |  ------------------
  ------------------
 4281|       |
 4282|       |      /* Take the unconsumed output back. */
 4283|   241k|      if (output != NULL)
  ------------------
  |  Branch (4283:11): [True: 205k, False: 35.9k]
  ------------------
 4284|   205k|         avail_out += png_ptr->zstream.avail_out;
 4285|       |
 4286|  35.9k|      else /* avail_out counts the extra bytes */
 4287|  35.9k|         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;
 4288|       |
 4289|   241k|      png_ptr->zstream.avail_out = 0;
 4290|       |
 4291|   241k|      if (ret == Z_STREAM_END)
  ------------------
  |  Branch (4291:11): [True: 872, False: 240k]
  ------------------
 4292|    872|      {
 4293|       |         /* Do this for safety; we won't read any more into this row. */
 4294|    872|         png_ptr->zstream.next_out = NULL;
 4295|       |
 4296|    872|         png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|    872|#define PNG_AFTER_IDAT 0x08
  ------------------
 4297|    872|         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
  ------------------
  |  |  674|    872|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
 4298|       |
 4299|    872|         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)
  ------------------
  |  Branch (4299:14): [True: 4, False: 868]
  |  Branch (4299:47): [True: 0, False: 868]
  ------------------
 4300|      4|            png_chunk_benign_error(png_ptr, "Extra compressed data");
  ------------------
  |  |  238|      4|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 4301|    872|         break;
 4302|    872|      }
 4303|       |
 4304|   240k|      if (ret != Z_OK)
  ------------------
  |  Branch (4304:11): [True: 484, False: 239k]
  ------------------
 4305|    484|      {
 4306|    484|         png_zstream_error(png_ptr, ret);
  ------------------
  |  |    4|    484|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
 4307|       |
 4308|    484|         if (output != NULL)
  ------------------
  |  Branch (4308:14): [True: 167, False: 317]
  ------------------
 4309|    167|            png_chunk_error(png_ptr, png_ptr->zstream.msg);
  ------------------
  |  |  239|    167|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 4310|       |
 4311|    317|         else /* checking */
 4312|    317|         {
 4313|    317|            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);
  ------------------
  |  |  238|    317|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 4314|    317|            return;
 4315|    317|         }
 4316|    484|      }
 4317|   240k|   } while (avail_out > 0);
  ------------------
  |  Branch (4317:13): [True: 35.5k, False: 204k]
  ------------------
 4318|       |
 4319|   205k|   if (avail_out > 0)
  ------------------
  |  Branch (4319:8): [True: 11, False: 205k]
  ------------------
 4320|     11|   {
 4321|       |      /* The stream ended before the image; this is the same as too few IDATs so
 4322|       |       * should be handled the same way.
 4323|       |       */
 4324|     11|      if (output != NULL)
  ------------------
  |  Branch (4324:11): [True: 2, False: 9]
  ------------------
 4325|      2|         png_error(png_ptr, "Not enough image data");
  ------------------
  |  |  252|      2|#define png_error OSS_FUZZ_png_error
  ------------------
 4326|       |
 4327|      9|      else /* the deflate stream contained extra data */
 4328|      9|         png_chunk_benign_error(png_ptr, "Too much image data");
  ------------------
  |  |  238|      9|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 4329|     11|   }
 4330|   205k|}
OSS_FUZZ_png_read_finish_IDAT:
 4334|  1.83k|{
 4335|       |   /* We don't need any more data and the stream should have ended, however the
 4336|       |    * LZ end code may actually not have been processed.  In this case we must
 4337|       |    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk
 4338|       |    * may still remain to be consumed.
 4339|       |    */
 4340|  1.83k|   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
  ------------------
  |  |  674|  1.83k|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
  |  Branch (4340:8): [True: 350, False: 1.48k]
  ------------------
 4341|    350|   {
 4342|       |      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
 4343|       |       * the compressed stream, but the stream may be damaged too, so even after
 4344|       |       * this call we may need to terminate the zstream ownership.
 4345|       |       */
 4346|    350|      png_read_IDAT_data(png_ptr, NULL, 0);
  ------------------
  |  |   38|    350|#define png_read_IDAT_data OSS_FUZZ_png_read_IDAT_data
  ------------------
 4347|    350|      png_ptr->zstream.next_out = NULL; /* safety */
 4348|       |
 4349|       |      /* Now clear everything out for safety; the following may not have been
 4350|       |       * done.
 4351|       |       */
 4352|    350|      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
  ------------------
  |  |  674|    350|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
  |  Branch (4352:11): [True: 317, False: 33]
  ------------------
 4353|    317|      {
 4354|    317|         png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|    317|#define PNG_AFTER_IDAT 0x08
  ------------------
 4355|    317|         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
  ------------------
  |  |  674|    317|#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
  ------------------
 4356|    317|      }
 4357|    350|   }
 4358|       |
 4359|       |   /* If the zstream has not been released do it now *and* terminate the reading
 4360|       |    * of the final IDAT chunk.
 4361|       |    */
 4362|  1.83k|   if (png_ptr->zowner == png_IDAT)
  ------------------
  |  |  862|  1.83k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  1.83k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.83k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.83k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.83k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.83k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4362:8): [True: 1.18k, False: 647]
  ------------------
 4363|  1.18k|   {
 4364|       |      /* Always do this; the pointers otherwise point into the read buffer. */
 4365|  1.18k|      png_ptr->zstream.next_in = NULL;
 4366|  1.18k|      png_ptr->zstream.avail_in = 0;
 4367|       |
 4368|       |      /* Now we no longer own the zstream. */
 4369|  1.18k|      png_ptr->zowner = 0;
 4370|       |
 4371|       |      /* The slightly weird semantics of the sequential IDAT reading is that we
 4372|       |       * are always in or at the end of an IDAT chunk, so we always need to do a
 4373|       |       * crc_finish here.  If idat_size is non-zero we also need to read the
 4374|       |       * spurious bytes at the end of the chunk now.
 4375|       |       */
 4376|  1.18k|      (void)png_crc_finish(png_ptr, png_ptr->idat_size);
  ------------------
  |  |   25|  1.18k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 4377|  1.18k|   }
 4378|  1.83k|}
OSS_FUZZ_png_read_finish_row:
 4382|   610k|{
 4383|   610k|   png_debug(1, "in png_read_finish_row");
  ------------------
  |  |  148|   610k|#  define png_debug(l, m) ((void)0)
  ------------------
 4384|   610k|   png_ptr->row_number++;
 4385|   610k|   if (png_ptr->row_number < png_ptr->num_rows)
  ------------------
  |  Branch (4385:8): [True: 606k, False: 3.47k]
  ------------------
 4386|   606k|      return;
 4387|       |
 4388|  3.47k|   if (png_ptr->interlaced != 0)
  ------------------
  |  Branch (4388:8): [True: 2.55k, False: 923]
  ------------------
 4389|  2.55k|   {
 4390|  2.55k|      png_ptr->row_number = 0;
 4391|       |
 4392|       |      /* TO DO: don't do this if prev_row isn't needed (requires
 4393|       |       * read-ahead of the next row's filter byte.
 4394|       |       */
 4395|  2.55k|      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
 4396|       |
 4397|  2.55k|      do
 4398|  2.55k|      {
 4399|  2.55k|         png_ptr->pass++;
 4400|       |
 4401|  2.55k|         if (png_ptr->pass >= 7)
  ------------------
  |  Branch (4401:14): [True: 286, False: 2.26k]
  ------------------
 4402|    286|            break;
 4403|       |
 4404|  2.26k|         png_ptr->iwidth = (png_ptr->width +
 4405|  2.26k|            png_pass_inc[png_ptr->pass] - 1 -
 4406|  2.26k|            png_pass_start[png_ptr->pass]) /
 4407|  2.26k|            png_pass_inc[png_ptr->pass];
 4408|       |
 4409|  2.26k|         if ((png_ptr->transformations & PNG_INTERLACE) == 0)
  ------------------
  |  |  635|  2.26k|#define PNG_INTERLACE           0x0002U
  ------------------
  |  Branch (4409:14): [True: 0, False: 2.26k]
  ------------------
 4410|      0|         {
 4411|      0|            png_ptr->num_rows = (png_ptr->height +
 4412|      0|                png_pass_yinc[png_ptr->pass] - 1 -
 4413|      0|                png_pass_ystart[png_ptr->pass]) /
 4414|      0|                png_pass_yinc[png_ptr->pass];
 4415|      0|         }
 4416|       |
 4417|  2.26k|         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
 4418|  2.26k|            break; /* libpng deinterlacing sees every row */
 4419|       |
 4420|  2.26k|      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);
  ------------------
  |  Branch (4420:16): [True: 0, False: 0]
  |  Branch (4420:42): [True: 0, False: 0]
  ------------------
 4421|       |
 4422|  2.55k|      if (png_ptr->pass < 7)
  ------------------
  |  Branch (4422:11): [True: 2.26k, False: 286]
  ------------------
 4423|  2.26k|         return;
 4424|  2.55k|   }
 4425|       |
 4426|       |   /* Here after at the end of the last row of the last pass. */
 4427|  1.20k|   png_read_finish_IDAT(png_ptr);
  ------------------
  |  |   39|  1.20k|#define png_read_finish_IDAT OSS_FUZZ_png_read_finish_IDAT
  ------------------
 4428|  1.20k|}
OSS_FUZZ_png_read_start_row:
 4433|  1.64k|{
 4434|  1.64k|   unsigned int max_pixel_depth;
 4435|  1.64k|   size_t row_bytes;
 4436|       |
 4437|  1.64k|   png_debug(1, "in png_read_start_row");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
 4438|       |
 4439|  1.64k|#ifdef PNG_READ_TRANSFORMS_SUPPORTED
 4440|  1.64k|   png_init_read_transformations(png_ptr);
  ------------------
  |  |   53|  1.64k|#define png_init_read_transformations OSS_FUZZ_png_init_read_transformations
  ------------------
 4441|  1.64k|#endif
 4442|  1.64k|   if (png_ptr->interlaced != 0)
  ------------------
  |  Branch (4442:8): [True: 474, False: 1.17k]
  ------------------
 4443|    474|   {
 4444|    474|      if ((png_ptr->transformations & PNG_INTERLACE) == 0)
  ------------------
  |  |  635|    474|#define PNG_INTERLACE           0x0002U
  ------------------
  |  Branch (4444:11): [True: 0, False: 474]
  ------------------
 4445|      0|         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
 4446|      0|             png_pass_ystart[0]) / png_pass_yinc[0];
 4447|       |
 4448|    474|      else
 4449|    474|         png_ptr->num_rows = png_ptr->height;
 4450|       |
 4451|    474|      png_ptr->iwidth = (png_ptr->width +
 4452|    474|          png_pass_inc[png_ptr->pass] - 1 -
 4453|    474|          png_pass_start[png_ptr->pass]) /
 4454|    474|          png_pass_inc[png_ptr->pass];
 4455|    474|   }
 4456|       |
 4457|  1.17k|   else
 4458|  1.17k|   {
 4459|  1.17k|      png_ptr->num_rows = png_ptr->height;
 4460|  1.17k|      png_ptr->iwidth = png_ptr->width;
 4461|  1.17k|   }
 4462|       |
 4463|  1.64k|   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;
 4464|       |
 4465|       |   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
 4466|       |    * calculations to calculate the final pixel depth, then
 4467|       |    * png_do_read_transforms actually does the transforms.  This means that the
 4468|       |    * code which effectively calculates this value is actually repeated in three
 4469|       |    * separate places.  They must all match.  Innocent changes to the order of
 4470|       |    * transformations can and will break libpng in a way that causes memory
 4471|       |    * overwrites.
 4472|       |    *
 4473|       |    * TODO: fix this.
 4474|       |    */
 4475|  1.64k|#ifdef PNG_READ_PACK_SUPPORTED
 4476|  1.64k|   if ((png_ptr->transformations & PNG_PACK) != 0 && png_ptr->bit_depth < 8)
  ------------------
  |  |  636|  1.64k|#define PNG_PACK                0x0004U
  ------------------
  |  Branch (4476:8): [True: 544, False: 1.10k]
  |  Branch (4476:54): [True: 544, False: 0]
  ------------------
 4477|    544|      max_pixel_depth = 8;
 4478|  1.64k|#endif
 4479|       |
 4480|  1.64k|#ifdef PNG_READ_EXPAND_SUPPORTED
 4481|  1.64k|   if ((png_ptr->transformations & PNG_EXPAND) != 0)
  ------------------
  |  |  646|  1.64k|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (4481:8): [True: 1.64k, False: 0]
  ------------------
 4482|  1.64k|   {
 4483|  1.64k|      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  1.64k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.64k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (4483:11): [True: 307, False: 1.34k]
  ------------------
 4484|    307|      {
 4485|    307|         if (png_ptr->num_trans != 0)
  ------------------
  |  Branch (4485:14): [True: 102, False: 205]
  ------------------
 4486|    102|            max_pixel_depth = 32;
 4487|       |
 4488|    205|         else
 4489|    205|            max_pixel_depth = 24;
 4490|    307|      }
 4491|       |
 4492|  1.34k|      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|  1.34k|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (4492:16): [True: 793, False: 549]
  ------------------
 4493|    793|      {
 4494|    793|         if (max_pixel_depth < 8)
  ------------------
  |  Branch (4494:14): [True: 228, False: 565]
  ------------------
 4495|    228|            max_pixel_depth = 8;
 4496|       |
 4497|    793|         if (png_ptr->num_trans != 0)
  ------------------
  |  Branch (4497:14): [True: 276, False: 517]
  ------------------
 4498|    276|            max_pixel_depth *= 2;
 4499|    793|      }
 4500|       |
 4501|    549|      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
  ------------------
  |  |  668|    549|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    549|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (4501:16): [True: 222, False: 327]
  ------------------
 4502|    222|      {
 4503|    222|         if (png_ptr->num_trans != 0)
  ------------------
  |  Branch (4503:14): [True: 140, False: 82]
  ------------------
 4504|    140|         {
 4505|    140|            max_pixel_depth *= 4;
 4506|    140|            max_pixel_depth /= 3;
 4507|    140|         }
 4508|    222|      }
 4509|  1.64k|   }
 4510|  1.64k|#endif
 4511|       |
 4512|  1.64k|#ifdef PNG_READ_EXPAND_16_SUPPORTED
 4513|  1.64k|   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)
  ------------------
  |  |  643|  1.64k|#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
  ------------------
  |  Branch (4513:8): [True: 0, False: 1.64k]
  ------------------
 4514|      0|   {
 4515|      0|#  ifdef PNG_READ_EXPAND_SUPPORTED
 4516|       |      /* In fact it is an error if it isn't supported, but checking is
 4517|       |       * the safe way.
 4518|       |       */
 4519|      0|      if ((png_ptr->transformations & PNG_EXPAND) != 0)
  ------------------
  |  |  646|      0|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (4519:11): [True: 0, False: 0]
  ------------------
 4520|      0|      {
 4521|      0|         if (png_ptr->bit_depth < 16)
  ------------------
  |  Branch (4521:14): [True: 0, False: 0]
  ------------------
 4522|      0|            max_pixel_depth *= 2;
 4523|      0|      }
 4524|      0|      else
 4525|      0|#  endif
 4526|      0|      png_ptr->transformations &= ~PNG_EXPAND_16;
  ------------------
  |  |  643|      0|#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
  ------------------
 4527|      0|   }
 4528|  1.64k|#endif
 4529|       |
 4530|  1.64k|#ifdef PNG_READ_FILLER_SUPPORTED
 4531|  1.64k|   if ((png_ptr->transformations & (PNG_FILLER)) != 0)
  ------------------
  |  |  649|  1.64k|#define PNG_FILLER              0x8000U
  ------------------
  |  Branch (4531:8): [True: 268, False: 1.38k]
  ------------------
 4532|    268|   {
 4533|    268|      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|    268|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (4533:11): [True: 178, False: 90]
  ------------------
 4534|    178|      {
 4535|    178|         if (max_pixel_depth <= 8)
  ------------------
  |  Branch (4535:14): [True: 160, False: 18]
  ------------------
 4536|    160|            max_pixel_depth = 16;
 4537|       |
 4538|     18|         else
 4539|     18|            max_pixel_depth = 32;
 4540|    178|      }
 4541|       |
 4542|     90|      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||
  ------------------
  |  |  668|    180|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|     90|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (4542:16): [True: 29, False: 61]
  ------------------
 4543|     90|         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|     61|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|     61|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|     61|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (4543:10): [True: 61, False: 0]
  ------------------
 4544|     90|      {
 4545|     90|         if (max_pixel_depth <= 32)
  ------------------
  |  Branch (4545:14): [True: 75, False: 15]
  ------------------
 4546|     75|            max_pixel_depth = 32;
 4547|       |
 4548|     15|         else
 4549|     15|            max_pixel_depth = 64;
 4550|     90|      }
 4551|    268|   }
 4552|  1.64k|#endif
 4553|       |
 4554|  1.64k|#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
 4555|  1.64k|   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
  ------------------
  |  |  648|  1.64k|#define PNG_GRAY_TO_RGB         0x4000U
  ------------------
  |  Branch (4555:8): [True: 1.39k, False: 259]
  ------------------
 4556|  1.39k|   {
 4557|  1.39k|      if (
 4558|  1.39k|#ifdef PNG_READ_EXPAND_SUPPORTED
 4559|  1.39k|          (png_ptr->num_trans != 0 &&
  ------------------
  |  Branch (4559:12): [True: 463, False: 927]
  ------------------
 4560|  1.39k|          (png_ptr->transformations & PNG_EXPAND) != 0) ||
  ------------------
  |  |  646|    463|#define PNG_EXPAND              0x1000U
  ------------------
  |  Branch (4560:11): [True: 463, False: 0]
  ------------------
 4561|  1.39k|#endif
 4562|  1.39k|#ifdef PNG_READ_FILLER_SUPPORTED
 4563|  1.39k|          (png_ptr->transformations & (PNG_FILLER)) != 0 ||
  ------------------
  |  |  649|    927|#define PNG_FILLER              0x8000U
  ------------------
  |  Branch (4563:11): [True: 178, False: 749]
  ------------------
 4564|  1.39k|#endif
 4565|  1.39k|          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
  ------------------
  |  |  670|    749|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|    749|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4565:11): [True: 45, False: 704]
  ------------------
 4566|    686|      {
 4567|    686|         if (max_pixel_depth <= 16)
  ------------------
  |  Branch (4567:14): [True: 414, False: 272]
  ------------------
 4568|    414|            max_pixel_depth = 32;
 4569|       |
 4570|    272|         else
 4571|    272|            max_pixel_depth = 64;
 4572|    686|      }
 4573|       |
 4574|    704|      else
 4575|    704|      {
 4576|    704|         if (max_pixel_depth <= 8)
  ------------------
  |  Branch (4576:14): [True: 292, False: 412]
  ------------------
 4577|    292|         {
 4578|    292|            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
  ------------------
  |  |  669|    292|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|    292|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|    292|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4578:17): [True: 0, False: 292]
  ------------------
 4579|      0|               max_pixel_depth = 32;
 4580|       |
 4581|    292|            else
 4582|    292|               max_pixel_depth = 24;
 4583|    292|         }
 4584|       |
 4585|    412|         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
  ------------------
  |  |  669|    412|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|    412|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|    412|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (4585:19): [True: 168, False: 244]
  ------------------
 4586|    168|            max_pixel_depth = 64;
 4587|       |
 4588|    244|         else
 4589|    244|            max_pixel_depth = 48;
 4590|    704|      }
 4591|  1.39k|   }
 4592|  1.64k|#endif
 4593|       |
 4594|  1.64k|#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
 4595|  1.64k|defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
 4596|  1.64k|   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
  ------------------
  |  |  654|  1.64k|#define PNG_USER_TRANSFORM    0x100000U
  ------------------
  |  Branch (4596:8): [True: 0, False: 1.64k]
  ------------------
 4597|      0|   {
 4598|      0|      unsigned int user_pixel_depth = png_ptr->user_transform_depth *
 4599|      0|         png_ptr->user_transform_channels;
 4600|       |
 4601|      0|      if (user_pixel_depth > max_pixel_depth)
  ------------------
  |  Branch (4601:11): [True: 0, False: 0]
  ------------------
 4602|      0|         max_pixel_depth = user_pixel_depth;
 4603|      0|   }
 4604|  1.64k|#endif
 4605|       |
 4606|       |   /* This value is stored in png_struct and double checked in the row read
 4607|       |    * code.
 4608|       |    */
 4609|  1.64k|   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;
 4610|  1.64k|   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */
 4611|       |
 4612|       |   /* Align the width on the next larger 8 pixels.  Mainly used
 4613|       |    * for interlacing
 4614|       |    */
 4615|  1.64k|   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
 4616|       |   /* Calculate the maximum bytes needed, adding a byte and a pixel
 4617|       |    * for safety's sake
 4618|       |    */
 4619|  1.64k|   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
  ------------------
  |  |  731|  1.64k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 1.64k, False: 0]
  |  |  ------------------
  |  |  732|  1.64k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  1.64k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
 4620|  1.64k|       1 + ((max_pixel_depth + 7) >> 3U);
 4621|       |
 4622|       |#ifdef PNG_MAX_MALLOC_64K
 4623|       |   if (row_bytes > (png_uint_32)65536L)
 4624|       |      png_error(png_ptr, "This image requires a row greater than 64KB");
 4625|       |#endif
 4626|       |
 4627|  1.64k|   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)
  ------------------
  |  Branch (4627:8): [True: 1.64k, False: 0]
  ------------------
 4628|  1.64k|   {
 4629|  1.64k|      png_free(png_ptr, png_ptr->big_row_buf);
  ------------------
  |  |  253|  1.64k|#define png_free OSS_FUZZ_png_free
  ------------------
 4630|  1.64k|      png_free(png_ptr, png_ptr->big_prev_row);
  ------------------
  |  |  253|  1.64k|#define png_free OSS_FUZZ_png_free
  ------------------
 4631|       |
 4632|  1.64k|      if (png_ptr->interlaced != 0)
  ------------------
  |  Branch (4632:11): [True: 474, False: 1.17k]
  ------------------
 4633|    474|         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
  ------------------
  |  |  237|    474|#define png_calloc OSS_FUZZ_png_calloc
  ------------------
 4634|    474|             row_bytes + 48);
 4635|       |
 4636|  1.17k|      else
 4637|  1.17k|         png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
  ------------------
  |  |  347|  1.17k|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
 4638|       |
 4639|  1.64k|      png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
  ------------------
  |  |  347|  1.64k|#define png_malloc OSS_FUZZ_png_malloc
  ------------------
 4640|       |
 4641|  1.64k|#ifdef PNG_ALIGNED_MEMORY_SUPPORTED
 4642|       |      /* Use 16-byte aligned memory for row_buf with at least 16 bytes
 4643|       |       * of padding before and after row_buf; treat prev_row similarly.
 4644|       |       * NOTE: the alignment is to the start of the pixels, one beyond the start
 4645|       |       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
 4646|       |       * was incorrect; the filter byte was aligned, which had the exact
 4647|       |       * opposite effect of that intended.
 4648|       |       */
 4649|  1.64k|      {
 4650|  1.64k|         png_bytep temp = png_ptr->big_row_buf + 32;
 4651|  1.64k|         size_t extra = (size_t)temp & 0x0f;
 4652|  1.64k|         png_ptr->row_buf = temp - extra - 1/*filter byte*/;
 4653|       |
 4654|  1.64k|         temp = png_ptr->big_prev_row + 32;
 4655|  1.64k|         extra = (size_t)temp & 0x0f;
 4656|  1.64k|         png_ptr->prev_row = temp - extra - 1/*filter byte*/;
 4657|  1.64k|      }
 4658|       |#else
 4659|       |      /* Use 31 bytes of padding before and 17 bytes after row_buf. */
 4660|       |      png_ptr->row_buf = png_ptr->big_row_buf + 31;
 4661|       |      png_ptr->prev_row = png_ptr->big_prev_row + 31;
 4662|       |#endif
 4663|  1.64k|      png_ptr->old_big_row_buf_size = row_bytes + 48;
 4664|  1.64k|   }
 4665|       |
 4666|       |#ifdef PNG_MAX_MALLOC_64K
 4667|       |   if (png_ptr->rowbytes > 65535)
 4668|       |      png_error(png_ptr, "This image requires a row greater than 64KB");
 4669|       |
 4670|       |#endif
 4671|  1.64k|   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))
  ------------------
  |  |  649|  1.64k|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
  |  Branch (4671:8): [True: 0, False: 1.64k]
  ------------------
 4672|      0|      png_error(png_ptr, "Row has too many bytes to allocate in memory");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 4673|       |
 4674|  1.64k|   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
 4675|       |
 4676|  1.64k|   png_debug1(3, "width = %u,", png_ptr->width);
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4677|  1.64k|   png_debug1(3, "height = %u,", png_ptr->height);
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4678|  1.64k|   png_debug1(3, "iwidth = %u,", png_ptr->iwidth);
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4679|  1.64k|   png_debug1(3, "num_rows = %u,", png_ptr->num_rows);
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4680|  1.64k|   png_debug1(3, "rowbytes = %lu,", (unsigned long)png_ptr->rowbytes);
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4681|  1.64k|   png_debug1(3, "irowbytes = %lu",
  ------------------
  |  |  151|  1.64k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 4682|  1.64k|       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
 4683|       |
 4684|       |   /* The sequential reader needs a buffer for IDAT, but the progressive reader
 4685|       |    * does not, so free the read buffer now regardless; the sequential reader
 4686|       |    * reallocates it on demand.
 4687|       |    */
 4688|  1.64k|   if (png_ptr->read_buffer != NULL)
  ------------------
  |  Branch (4688:8): [True: 797, False: 852]
  ------------------
 4689|    797|   {
 4690|    797|      png_bytep buffer = png_ptr->read_buffer;
 4691|       |
 4692|    797|      png_ptr->read_buffer_size = 0;
 4693|    797|      png_ptr->read_buffer = NULL;
 4694|    797|      png_free(png_ptr, buffer);
  ------------------
  |  |  253|    797|#define png_free OSS_FUZZ_png_free
  ------------------
 4695|    797|   }
 4696|       |
 4697|       |   /* Finally claim the zstream for the inflate of the IDAT data, use the bits
 4698|       |    * value from the stream (note that this will result in a fatal error if the
 4699|       |    * IDAT stream has a bogus deflate header window_bits value, but this should
 4700|       |    * not be happening any longer!)
 4701|       |    */
 4702|  1.64k|   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)
  ------------------
  |  |  862|  1.64k|#define png_IDAT PNG_U32( 73,  68,  65,  84)
  |  |  ------------------
  |  |  |  |  821|  1.64k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.64k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.64k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.64k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|  1.64k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4702:8): [True: 0, False: 1.64k]
  ------------------
 4703|      0|      png_error(png_ptr, png_ptr->zstream.msg);
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
 4704|       |
 4705|  1.64k|   png_ptr->flags |= PNG_FLAG_ROW_INIT;
  ------------------
  |  |  677|  1.64k|#define PNG_FLAG_ROW_INIT                 0x0040U
  ------------------
 4706|  1.64k|}
pngrutil.c:check_chunk_name:
  154|  55.0k|{
  155|  55.0k|   png_uint_32 t;
  156|       |
  157|       |   /* Remove bit 5 from all but the reserved byte; this means
  158|       |    * every 8-bit unit must be in the range 65-90 to be valid.
  159|       |    * So bit 5 must be zero, bit 6 must be set and bit 7 zero.
  160|       |    */
  161|  55.0k|   name &= ~PNG_U32(32,32,0,32);
  ------------------
  |  |  821|  55.0k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  ------------------
  162|  55.0k|   t = (name & ~0x1f1f1f1fU) ^ 0x40404040U;
  163|       |
  164|       |   /* Subtract 65 for each 8-bit quantity, this must not
  165|       |    * overflow and each byte must then be in the range 0-25.
  166|       |    */
  167|  55.0k|   name -= PNG_U32(65,65,65,65);
  ------------------
  |  |  821|  55.0k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  ------------------
  168|  55.0k|   t |= name;
  169|       |
  170|       |   /* Subtract 26, handling the overflow which should set the
  171|       |    * top three bits of each byte.
  172|       |    */
  173|  55.0k|   name -= PNG_U32(25,25,25,26);
  ------------------
  |  |  821|  55.0k|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  ------------------
  |  |  |  |  819|  55.0k|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  ------------------
  ------------------
  174|  55.0k|   t |= ~name;
  175|       |
  176|  55.0k|   return (t & 0xe0e0e0e0U) == 0U;
  177|  55.0k|}
pngrutil.c:png_crc_finish_critical:
  314|  54.4k|{
  315|       |   /* The size of the local buffer for inflate is a good guess as to a
  316|       |    * reasonable size to use for buffering reads from the application.
  317|       |    */
  318|  81.0k|   while (skip > 0)
  ------------------
  |  Branch (318:11): [True: 26.6k, False: 54.4k]
  ------------------
  319|  26.6k|   {
  320|  26.6k|      png_uint_32 len;
  321|  26.6k|      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
  322|       |
  323|  26.6k|      len = (sizeof tmpbuf);
  324|  26.6k|      if (len > skip)
  ------------------
  |  Branch (324:11): [True: 26.5k, False: 69]
  ------------------
  325|  26.5k|         len = skip;
  326|  26.6k|      skip -= len;
  327|       |
  328|  26.6k|      png_crc_read(png_ptr, tmpbuf, len);
  ------------------
  |  |   24|  26.6k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
  329|  26.6k|   }
  330|       |
  331|       |   /* If 'handle_as_ancillary' has been requested and this is a critical chunk
  332|       |    * but PNG_FLAG_CRC_CRITICAL_IGNORE was set then png_read_crc did not, in
  333|       |    * fact, calculate the CRC so the ANCILLARY settings should not be used
  334|       |    * instead.
  335|       |    */
  336|  54.4k|   if (handle_as_ancillary &&
  ------------------
  |  Branch (336:8): [True: 1.34k, False: 53.1k]
  ------------------
  337|  54.4k|       (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
  ------------------
  |  |  682|  1.34k|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  ------------------
  |  Branch (337:8): [True: 1.10k, False: 235]
  ------------------
  338|  1.10k|      handle_as_ancillary = 0;
  339|       |
  340|       |   /* TODO: this might be more comprehensible if png_crc_error was inlined here.
  341|       |    */
  342|  54.4k|   if (png_crc_error(png_ptr, handle_as_ancillary) != 0)
  ------------------
  |  Branch (342:8): [True: 7.20k, False: 47.2k]
  ------------------
  343|  7.20k|   {
  344|       |      /* See above for the explanation of how the flags work. */
  345|  7.20k|      if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?
  ------------------
  |  |  917|  6.98k|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  ------------------
  |  Branch (345:11): [True: 223, False: 6.98k]
  |  Branch (345:11): [True: 7.05k, False: 150]
  |  Branch (345:34): [True: 6.83k, False: 150]
  ------------------
  346|  7.05k|          (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :
  ------------------
  |  |  680|  7.05k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  ------------------
  347|  7.20k|          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)
  ------------------
  |  |  681|    150|#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
  ------------------
  348|  7.05k|         png_chunk_warning(png_ptr, "CRC error");
  ------------------
  |  |  240|  7.05k|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
  349|       |
  350|    150|      else
  351|    150|         png_chunk_error(png_ptr, "CRC error");
  ------------------
  |  |  239|    150|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  352|       |
  353|  7.05k|      return 1;
  354|  7.20k|   }
  355|       |
  356|  47.2k|   return 0;
  357|  54.4k|}
pngrutil.c:png_crc_error:
  240|  54.2k|{
  241|  54.2k|   png_byte crc_bytes[4];
  242|  54.2k|   png_uint_32 crc;
  243|  54.2k|   int need_crc = 1;
  244|       |
  245|       |   /* There are four flags two for ancillary and two for critical chunks.  The
  246|       |    * default setting of these flags is all zero.
  247|       |    *
  248|       |    * PNG_FLAG_CRC_ANCILLARY_USE
  249|       |    * PNG_FLAG_CRC_ANCILLARY_NOWARN
  250|       |    *  USE+NOWARN: no CRC calculation (implemented here), else;
  251|       |    *  NOWARN:     png_chunk_error on error (implemented in png_crc_finish)
  252|       |    *  else:       png_chunk_warning on error (implemented in png_crc_finish)
  253|       |    *              This is the default.
  254|       |    *
  255|       |    *    I.e. NOWARN without USE produces png_chunk_error.  The default setting
  256|       |    *    where neither are set does the same thing.
  257|       |    *
  258|       |    * PNG_FLAG_CRC_CRITICAL_USE
  259|       |    * PNG_FLAG_CRC_CRITICAL_IGNORE
  260|       |    *  IGNORE: no CRC calculation (implemented here), else;
  261|       |    *  USE:    png_chunk_warning on error (implemented in png_crc_finish)
  262|       |    *  else:   png_chunk_error on error (implemented in png_crc_finish)
  263|       |    *          This is the default.
  264|       |    *
  265|       |    * This arose because of original mis-implementation and has persisted for
  266|       |    * compatibility reasons.
  267|       |    *
  268|       |    * TODO: the flag names are internal so maybe this can be changed to
  269|       |    * something comprehensible.
  270|       |    */
  271|  54.2k|   if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
  ------------------
  |  |  917|  54.0k|#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
  ------------------
  |  Branch (271:8): [True: 235, False: 54.0k]
  |  Branch (271:31): [True: 48.3k, False: 5.66k]
  ------------------
  272|  48.6k|   {
  273|  48.6k|      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
  ------------------
  |  |  703|  48.6k|#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
  |  |  ------------------
  |  |  |  |  679|  48.6k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  |  |  ------------------
  |  |  704|  48.6k|                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)
  |  |  ------------------
  |  |  |  |  680|  48.6k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  |  |  ------------------
  ------------------
  |  Branch (273:11): [True: 37.4k, False: 11.2k]
  ------------------
  274|  48.6k|          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
  ------------------
  |  |  679|  48.6k|#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
  ------------------
                        (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
  ------------------
  |  |  680|  48.6k|#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
  ------------------
  275|  37.4k|         need_crc = 0;
  276|  48.6k|   }
  277|       |
  278|  5.66k|   else /* critical */
  279|  5.66k|   {
  280|  5.66k|      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
  ------------------
  |  |  682|  5.66k|#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
  ------------------
  |  Branch (280:11): [True: 4.47k, False: 1.19k]
  ------------------
  281|  4.47k|         need_crc = 0;
  282|  5.66k|   }
  283|       |
  284|  54.2k|#ifdef PNG_IO_STATE_SUPPORTED
  285|  54.2k|   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
  ------------------
  |  | 2527|  54.2k|#  define PNG_IO_READING     0x0001   /* currently reading */
  ------------------
                 png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
  ------------------
  |  | 2532|  54.2k|#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
  ------------------
  286|  54.2k|#endif
  287|       |
  288|       |   /* The chunk CRC must be serialized in a single I/O call. */
  289|  54.2k|   png_read_data(png_ptr, crc_bytes, 4);
  ------------------
  |  |   23|  54.2k|#define png_read_data OSS_FUZZ_png_read_data
  ------------------
  290|       |
  291|  54.2k|   if (need_crc != 0)
  ------------------
  |  Branch (291:8): [True: 12.4k, False: 41.8k]
  ------------------
  292|  12.4k|   {
  293|  12.4k|      crc = png_get_uint_32(crc_bytes);
  ------------------
  |  |  322|  12.4k|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|  12.4k|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|  12.4k|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|  12.4k|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|  12.4k|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|  12.4k|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  294|  12.4k|      return crc != png_ptr->crc;
  295|  12.4k|   }
  296|       |
  297|  41.8k|   else
  298|  41.8k|      return 0;
  299|  54.2k|}
pngrutil.c:png_chunk_index_from_name:
 3112|  52.8k|{
 3113|       |   /* For chunk png_cHNK return PNG_INDEX_cHNK.  Return PNG_INDEX_unknown if
 3114|       |    * chunk_name is not known.  Notice that in a particular build "known" does
 3115|       |    * not necessarily mean "supported", although the inverse applies.
 3116|       |    */
 3117|  52.8k|   switch (chunk_name)
 3118|  52.8k|   {
 3119|      0|#     define PNG_CHUNK(cHNK, index)\
 3120|      0|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
 3121|       |
 3122|      0|      PNG_KNOWN_CHUNKS
  ------------------
  |  |  944|  2.57k|   PNG_CHUNK(IHDR,  0)\
  |  |  ------------------
  |  |  |  | 3120|  2.57k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.57k, False: 50.3k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  945|  2.57k|   PNG_CHUNK(PLTE,  1)\
  |  |  ------------------
  |  |  |  | 3120|  1.17k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.17k, False: 51.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  946|  1.17k|   PNG_CHUNK(IDAT,  2)\
  |  |  ------------------
  |  |  |  | 3120|      0|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 0, False: 52.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  947|    550|   PNG_CHUNK(IEND,  3)\
  |  |  ------------------
  |  |  |  | 3120|    550|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 550, False: 52.3k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  948|    550|   PNG_CHUNK(acTL,  4)\
  |  |  ------------------
  |  |  |  | 3120|    123|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 123, False: 52.7k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  949|  2.05k|   PNG_CHUNK(bKGD,  5)\
  |  |  ------------------
  |  |  |  | 3120|  2.05k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.05k, False: 50.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  950|  5.36k|   PNG_CHUNK(cHRM,  6)\
  |  |  ------------------
  |  |  |  | 3120|  5.36k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 5.36k, False: 47.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  951|  5.36k|   PNG_CHUNK(cICP,  7)\
  |  |  ------------------
  |  |  |  | 3120|  1.89k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.89k, False: 50.9k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  952|  1.89k|   PNG_CHUNK(cLLI,  8)\
  |  |  ------------------
  |  |  |  | 3120|  1.84k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.84k, False: 51.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  953|  1.84k|   PNG_CHUNK(eXIf,  9)\
  |  |  ------------------
  |  |  |  | 3120|    425|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 425, False: 52.4k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  954|    425|   PNG_CHUNK(fcTL, 10)\
  |  |  ------------------
  |  |  |  | 3120|     34|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 34, False: 52.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  955|     53|   PNG_CHUNK(fdAT, 11)\
  |  |  ------------------
  |  |  |  | 3120|     53|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 53, False: 52.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  956|  4.85k|   PNG_CHUNK(gAMA, 12)\
  |  |  ------------------
  |  |  |  | 3120|  4.85k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 4.85k, False: 48.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  957|  4.85k|   PNG_CHUNK(hIST, 13)\
  |  |  ------------------
  |  |  |  | 3120|     59|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 59, False: 52.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  958|    764|   PNG_CHUNK(iCCP, 14)\
  |  |  ------------------
  |  |  |  | 3120|    764|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 764, False: 52.1k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  959|  2.51k|   PNG_CHUNK(iTXt, 15)\
  |  |  ------------------
  |  |  |  | 3120|  2.51k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.51k, False: 50.3k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  960|  2.51k|   PNG_CHUNK(mDCV, 16)\
  |  |  ------------------
  |  |  |  | 3120|  1.81k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.81k, False: 51.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  961|  1.99k|   PNG_CHUNK(oFFs, 17)\
  |  |  ------------------
  |  |  |  | 3120|  1.99k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.99k, False: 50.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  962|  2.62k|   PNG_CHUNK(pCAL, 18)\
  |  |  ------------------
  |  |  |  | 3120|  2.62k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.62k, False: 50.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  963|  2.62k|   PNG_CHUNK(pHYs, 19)\
  |  |  ------------------
  |  |  |  | 3120|    725|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 725, False: 52.1k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  964|  1.19k|   PNG_CHUNK(sBIT, 20)\
  |  |  ------------------
  |  |  |  | 3120|  1.19k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.19k, False: 51.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  965|  3.68k|   PNG_CHUNK(sCAL, 21)\
  |  |  ------------------
  |  |  |  | 3120|  3.68k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 3.68k, False: 49.1k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  966|  3.68k|   PNG_CHUNK(sPLT, 22)\
  |  |  ------------------
  |  |  |  | 3120|  1.19k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.19k, False: 51.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  967|  2.39k|   PNG_CHUNK(sRGB, 23)\
  |  |  ------------------
  |  |  |  | 3120|  2.39k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.39k, False: 50.4k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  968|  2.92k|   PNG_CHUNK(tEXt, 24)\
  |  |  ------------------
  |  |  |  | 3120|  2.92k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.92k, False: 49.9k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  969|  2.92k|   PNG_CHUNK(tIME, 25)\
  |  |  ------------------
  |  |  |  | 3120|    592|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 592, False: 52.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  970|  2.32k|   PNG_CHUNK(tRNS, 26)\
  |  |  ------------------
  |  |  |  | 3120|  2.32k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 2.32k, False: 50.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  971|  2.32k|   PNG_CHUNK(zTXt, 27)
  |  |  ------------------
  |  |  |  | 3120|  1.81k|         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (3120:10): [True: 1.81k, False: 51.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3123|       |
 3124|      0|#     undef PNG_CHUNK
 3125|       |
 3126|  5.30k|      default: return PNG_INDEX_unknown;
  ------------------
  |  Branch (3126:7): [True: 5.30k, False: 47.5k]
  ------------------
 3127|  52.8k|   }
 3128|  52.8k|}
pngrutil.c:png_handle_IHDR:
  902|  2.56k|{
  903|  2.56k|   png_byte buf[13];
  904|  2.56k|   png_uint_32 width, height;
  905|  2.56k|   int bit_depth, color_type, compression_type, filter_type;
  906|  2.56k|   int interlace_type;
  907|       |
  908|  2.56k|   png_debug(1, "in png_handle_IHDR");
  ------------------
  |  |  148|  2.56k|#  define png_debug(l, m) ((void)0)
  ------------------
  909|       |
  910|       |   /* Length and position are checked by the caller. */
  911|       |
  912|  2.56k|   png_ptr->mode |= PNG_HAVE_IHDR;
  ------------------
  |  |  642|  2.56k|#define PNG_HAVE_IHDR  0x01
  ------------------
  913|       |
  914|  2.56k|   png_crc_read(png_ptr, buf, 13);
  ------------------
  |  |   24|  2.56k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
  915|  2.56k|   png_crc_finish(png_ptr, 0);
  ------------------
  |  |   25|  2.56k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  916|       |
  917|  2.56k|   width = png_get_uint_31(png_ptr, buf);
  ------------------
  |  |  321|  2.56k|#define png_get_uint_31 OSS_FUZZ_png_get_uint_31
  ------------------
  918|  2.56k|   height = png_get_uint_31(png_ptr, buf + 4);
  ------------------
  |  |  321|  2.56k|#define png_get_uint_31 OSS_FUZZ_png_get_uint_31
  ------------------
  919|  2.56k|   bit_depth = buf[8];
  920|  2.56k|   color_type = buf[9];
  921|  2.56k|   compression_type = buf[10];
  922|  2.56k|   filter_type = buf[11];
  923|  2.56k|   interlace_type = buf[12];
  924|       |
  925|       |   /* Set internal variables */
  926|  2.56k|   png_ptr->width = width;
  927|  2.56k|   png_ptr->height = height;
  928|  2.56k|   png_ptr->bit_depth = (png_byte)bit_depth;
  929|  2.56k|   png_ptr->interlaced = (png_byte)interlace_type;
  930|  2.56k|   png_ptr->color_type = (png_byte)color_type;
  931|  2.56k|#ifdef PNG_MNG_FEATURES_SUPPORTED
  932|  2.56k|   png_ptr->filter_type = (png_byte)filter_type;
  933|  2.56k|#endif
  934|  2.56k|   png_ptr->compression_type = (png_byte)compression_type;
  935|       |
  936|       |   /* Find number of channels */
  937|  2.56k|   switch (png_ptr->color_type)
  938|  2.56k|   {
  939|      5|      default: /* invalid, png_set_IHDR calls png_error */
  ------------------
  |  Branch (939:7): [True: 5, False: 2.56k]
  ------------------
  940|  1.17k|      case PNG_COLOR_TYPE_GRAY:
  ------------------
  |  |  666|  1.17k|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (940:7): [True: 1.16k, False: 1.40k]
  ------------------
  941|  1.64k|      case PNG_COLOR_TYPE_PALETTE:
  ------------------
  |  |  667|  1.64k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  1.64k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  1.64k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (941:7): [True: 475, False: 2.09k]
  ------------------
  942|  1.64k|         png_ptr->channels = 1;
  943|  1.64k|         break;
  944|       |
  945|    307|      case PNG_COLOR_TYPE_RGB:
  ------------------
  |  |  668|    307|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    307|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (945:7): [True: 307, False: 2.26k]
  ------------------
  946|    307|         png_ptr->channels = 3;
  947|    307|         break;
  948|       |
  949|     51|      case PNG_COLOR_TYPE_GRAY_ALPHA:
  ------------------
  |  |  670|     51|#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|     51|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (949:7): [True: 51, False: 2.51k]
  ------------------
  950|     51|         png_ptr->channels = 2;
  951|     51|         break;
  952|       |
  953|    560|      case PNG_COLOR_TYPE_RGB_ALPHA:
  ------------------
  |  |  669|    560|#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  662|    560|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
  |  |  ------------------
  |  |  |  |  663|    560|#define PNG_COLOR_MASK_ALPHA      4
  |  |  ------------------
  ------------------
  |  Branch (953:7): [True: 560, False: 2.00k]
  ------------------
  954|    560|         png_ptr->channels = 4;
  955|    560|         break;
  956|  2.56k|   }
  957|       |
  958|       |   /* Set up other useful info */
  959|  2.56k|   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);
  960|  2.56k|   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
  ------------------
  |  |  731|  2.56k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 1.24k, False: 1.32k]
  |  |  ------------------
  |  |  732|  2.56k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  2.56k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
  961|  2.56k|   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
  ------------------
  |  |  151|  2.56k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  962|  2.56k|   png_debug1(3, "channels = %d", png_ptr->channels);
  ------------------
  |  |  151|  2.56k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  963|  2.56k|   png_debug1(3, "rowbytes = %lu", (unsigned long)png_ptr->rowbytes);
  ------------------
  |  |  151|  2.56k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  964|       |
  965|       |   /* Rely on png_set_IHDR to completely validate the data and call png_error if
  966|       |    * it's wrong.
  967|       |    */
  968|  2.56k|   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
  ------------------
  |  |  363|  2.56k|#define png_set_IHDR OSS_FUZZ_png_set_IHDR
  ------------------
  969|  2.56k|       color_type, interlace_type, compression_type, filter_type);
  970|       |
  971|  2.56k|   return handled_ok;
  972|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
  973|      0|}
pngrutil.c:png_handle_PLTE:
  982|  1.17k|{
  983|  1.17k|   png_const_charp errmsg = NULL;
  984|       |
  985|  1.17k|   png_debug(1, "in png_handle_PLTE");
  ------------------
  |  |  148|  1.17k|#  define png_debug(l, m) ((void)0)
  ------------------
  986|       |
  987|       |   /* 1.6.47: consistency.  This used to be especially treated as a critical
  988|       |    * error even in an image which is not colour mapped, there isn't a good
  989|       |    * justification for treating some errors here one way and others another so
  990|       |    * everything uses the same logic.
  991|       |    */
  992|  1.17k|   if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)
  ------------------
  |  |  643|  1.17k|#define PNG_HAVE_PLTE  0x02
  ------------------
  |  Branch (992:8): [True: 66, False: 1.11k]
  ------------------
  993|     66|      errmsg = "duplicate";
  994|       |
  995|  1.11k|   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|  1.11k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (995:13): [True: 114, False: 998]
  ------------------
  996|    114|      errmsg = "out of place";
  997|       |
  998|    998|   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
  ------------------
  |  |  662|    998|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (998:13): [True: 490, False: 508]
  ------------------
  999|    490|      errmsg = "ignored in grayscale PNG";
 1000|       |
 1001|    508|   else if (length > 3*PNG_MAX_PALETTE_LENGTH || (length % 3) != 0)
  ------------------
  |  |  723|  1.01k|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  |  Branch (1001:13): [True: 1, False: 507]
  |  Branch (1001:50): [True: 70, False: 437]
  ------------------
 1002|     71|      errmsg = "invalid";
 1003|       |
 1004|       |   /* This drops PLTE in favour of tRNS or bKGD because both of those chunks
 1005|       |    * can have an effect on the rendering of the image whereas PLTE only matters
 1006|       |    * in the case of an 8-bit display with a decoder which controls the palette.
 1007|       |    *
 1008|       |    * The alternative here is to ignore the error and store the palette anyway;
 1009|       |    * destroying the tRNS will definately cause problems.
 1010|       |    *
 1011|       |    * NOTE: the case of PNG_COLOR_TYPE_PALETTE need not be considered because
 1012|       |    * the png_handle_ routines for the three 'after PLTE' chunks tRNS, bKGD and
 1013|       |    * hIST all check for a preceding PLTE in these cases.
 1014|       |    */
 1015|    437|   else if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE &&
  ------------------
  |  |  667|    874|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    437|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    437|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1015:13): [True: 80, False: 357]
  ------------------
 1016|    437|            (png_has_chunk(png_ptr, tRNS) || png_has_chunk(png_ptr, bKGD)))
  ------------------
  |  |  194|     80|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    160|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     80|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 34, False: 46]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                          (png_has_chunk(png_ptr, tRNS) || png_has_chunk(png_ptr, bKGD)))
  ------------------
  |  |  194|     46|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|     46|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     46|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (115:4): [True: 34, False: 12]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1017|     68|      errmsg = "out of place";
 1018|       |
 1019|    369|   else
 1020|    369|   {
 1021|       |      /* If the palette has 256 or fewer entries but is too large for the bit
 1022|       |       * depth we don't issue an error to preserve the behavior of previous
 1023|       |       * libpng versions. We silently truncate the unused extra palette entries
 1024|       |       * here.
 1025|       |       */
 1026|    369|      const unsigned max_palette_length =
 1027|    369|         (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
  ------------------
  |  |  667|    369|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    369|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    369|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1027:10): [True: 357, False: 12]
  ------------------
 1028|    357|            1U << png_ptr->bit_depth : PNG_MAX_PALETTE_LENGTH;
  ------------------
  |  |  723|     12|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
 1029|       |
 1030|       |      /* The cast is safe because 'length' is less than
 1031|       |       * 3*PNG_MAX_PALETTE_LENGTH
 1032|       |       */
 1033|    369|      const unsigned num = (length > 3U*max_palette_length) ?
  ------------------
  |  Branch (1033:28): [True: 3, False: 366]
  ------------------
 1034|    366|         max_palette_length : (unsigned)length / 3U;
 1035|       |
 1036|    369|      unsigned i, j;
 1037|    369|      png_byte buf[3*PNG_MAX_PALETTE_LENGTH];
 1038|    369|      png_color palette[PNG_MAX_PALETTE_LENGTH];
 1039|       |
 1040|       |      /* Read the chunk into the buffer then read to the end of the chunk. */
 1041|    369|      png_crc_read(png_ptr, buf, num*3U);
  ------------------
  |  |   24|    369|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1042|    369|      png_crc_finish_critical(png_ptr, length - 3U*num,
 1043|       |            /* Handle as ancillary if PLTE is optional: */
 1044|    369|            png_ptr->color_type != PNG_COLOR_TYPE_PALETTE);
  ------------------
  |  |  667|    369|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    369|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    369|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
 1045|       |
 1046|  24.7k|      for (i = 0U, j = 0U; i < num; i++)
  ------------------
  |  Branch (1046:28): [True: 24.4k, False: 369]
  ------------------
 1047|  24.4k|      {
 1048|  24.4k|         palette[i].red = buf[j++];
 1049|  24.4k|         palette[i].green = buf[j++];
 1050|  24.4k|         palette[i].blue = buf[j++];
 1051|  24.4k|      }
 1052|       |
 1053|       |      /* A valid PLTE chunk has been read */
 1054|    369|      png_ptr->mode |= PNG_HAVE_PLTE;
  ------------------
  |  |  643|    369|#define PNG_HAVE_PLTE  0x02
  ------------------
 1055|       |
 1056|       |      /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to
 1057|       |       * its own copy of the palette.  This has the side effect that when
 1058|       |       * png_start_row is called (this happens after any call to
 1059|       |       * png_read_update_info) the info_ptr palette gets changed.  This is
 1060|       |       * extremely unexpected and confusing.
 1061|       |       *
 1062|       |       * REVIEW: there have been consistent bugs in the past about gamma and
 1063|       |       * similar transforms to colour mapped images being useless because the
 1064|       |       * modified palette cannot be accessed because of the above.
 1065|       |       *
 1066|       |       * CONSIDER: Fix this by not sharing the palette in this way.  But does
 1067|       |       * this completely fix the problem?
 1068|       |       */
 1069|    369|      png_set_PLTE(png_ptr, info_ptr, palette, num);
  ------------------
  |  |  364|    369|#define png_set_PLTE OSS_FUZZ_png_set_PLTE
  ------------------
 1070|    369|      return handled_ok;
 1071|    369|   }
 1072|       |
 1073|       |   /* Here on error: errmsg is non NULL. */
 1074|    809|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|    809|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    809|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    809|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1074:8): [True: 3, False: 806]
  ------------------
 1075|      3|   {
 1076|      3|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      3|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1077|      3|      png_chunk_error(png_ptr, errmsg);
  ------------------
  |  |  239|      6|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
 1078|      3|   }
 1079|       |
 1080|    806|   else /* not critical to this image */
 1081|    806|   {
 1082|    806|      png_crc_finish_critical(png_ptr, length, 1/*handle as ancillary*/);
 1083|    806|      png_chunk_benign_error(png_ptr, errmsg);
  ------------------
  |  |  238|    806|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1084|    806|   }
 1085|       |
 1086|       |   /* Because PNG_UNUSED(errmsg) does not work if all the uses are compiled out
 1087|       |    * (this does happen).
 1088|       |    */
 1089|    806|   return errmsg != NULL ? handled_error : handled_error;
  ------------------
  |  Branch (1089:11): [True: 778, False: 28]
  ------------------
 1090|    809|}
pngrutil.c:png_handle_IEND:
 1099|    549|{
 1100|    549|   png_debug(1, "in png_handle_IEND");
  ------------------
  |  |  148|    549|#  define png_debug(l, m) ((void)0)
  ------------------
 1101|       |
 1102|    549|   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
  ------------------
  |  |  644|    549|#define PNG_AFTER_IDAT 0x08
  ------------------
                 png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
  ------------------
  |  |  620|    549|#define PNG_HAVE_IEND               0x10U
  ------------------
 1103|       |
 1104|    549|   if (length != 0)
  ------------------
  |  Branch (1104:8): [True: 1, False: 548]
  ------------------
 1105|      1|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1106|       |
 1107|    549|   png_crc_finish_critical(png_ptr, length, 1/*handle as ancillary*/);
 1108|       |
 1109|    549|   return handled_ok;
 1110|      0|   PNG_UNUSED(info_ptr)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1111|      0|}
pngrutil.c:png_handle_bKGD:
 1789|    954|{
 1790|    954|   unsigned int truelen;
 1791|    954|   png_byte buf[6];
 1792|    954|   png_color_16 background;
 1793|       |
 1794|    954|   png_debug(1, "in png_handle_bKGD");
  ------------------
  |  |  148|    954|#  define png_debug(l, m) ((void)0)
  ------------------
 1795|       |
 1796|    954|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|    954|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    954|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    954|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1796:8): [True: 151, False: 803]
  ------------------
 1797|    151|   {
 1798|    151|      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)
  ------------------
  |  |  643|    151|#define PNG_HAVE_PLTE  0x02
  ------------------
  |  Branch (1798:11): [True: 66, False: 85]
  ------------------
 1799|     66|      {
 1800|     66|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     66|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1801|     66|         png_chunk_benign_error(png_ptr, "out of place");
  ------------------
  |  |  238|     66|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1802|     66|         return handled_error;
 1803|     66|      }
 1804|       |
 1805|     85|      truelen = 1;
 1806|     85|   }
 1807|       |
 1808|    803|   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|    803|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1808:13): [True: 449, False: 354]
  ------------------
 1809|    449|      truelen = 6;
 1810|       |
 1811|    354|   else
 1812|    354|      truelen = 2;
 1813|       |
 1814|    888|   if (length != truelen)
  ------------------
  |  Branch (1814:8): [True: 384, False: 504]
  ------------------
 1815|    384|   {
 1816|    384|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|    384|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1817|    384|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|    384|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1818|    384|      return handled_error;
 1819|    384|   }
 1820|       |
 1821|    504|   png_crc_read(png_ptr, buf, truelen);
  ------------------
  |  |   24|    504|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1822|       |
 1823|    504|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    504|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1823:8): [True: 20, False: 484]
  ------------------
 1824|     20|      return handled_error;
 1825|       |
 1826|       |   /* We convert the index value into RGB components so that we can allow
 1827|       |    * arbitrary RGB values for background when we have transparency, and
 1828|       |    * so it is easy to determine the RGB values of the background color
 1829|       |    * from the info_ptr struct.
 1830|       |    */
 1831|    484|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|    484|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    484|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    484|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1831:8): [True: 16, False: 468]
  ------------------
 1832|     16|   {
 1833|     16|      background.index = buf[0];
 1834|       |
 1835|     16|      if (info_ptr != NULL && info_ptr->num_palette != 0)
  ------------------
  |  Branch (1835:11): [True: 16, False: 0]
  |  Branch (1835:31): [True: 16, False: 0]
  ------------------
 1836|     16|      {
 1837|     16|         if (buf[0] >= info_ptr->num_palette)
  ------------------
  |  Branch (1837:14): [True: 1, False: 15]
  ------------------
 1838|      1|         {
 1839|      1|            png_chunk_benign_error(png_ptr, "invalid index");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1840|      1|            return handled_error;
 1841|      1|         }
 1842|       |
 1843|     15|         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;
 1844|     15|         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;
 1845|     15|         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;
 1846|     15|      }
 1847|       |
 1848|      0|      else
 1849|      0|         background.red = background.green = background.blue = 0;
 1850|       |
 1851|     15|      background.gray = 0;
 1852|     15|   }
 1853|       |
 1854|    468|   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */
  ------------------
  |  |  662|    468|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1854:13): [True: 43, False: 425]
  ------------------
 1855|     43|   {
 1856|     43|      if (png_ptr->bit_depth <= 8)
  ------------------
  |  Branch (1856:11): [True: 28, False: 15]
  ------------------
 1857|     28|      {
 1858|     28|         if (buf[0] != 0 || buf[1] >= (unsigned int)(1 << png_ptr->bit_depth))
  ------------------
  |  Branch (1858:14): [True: 10, False: 18]
  |  Branch (1858:29): [True: 10, False: 8]
  ------------------
 1859|     20|         {
 1860|     20|            png_chunk_benign_error(png_ptr, "invalid gray level");
  ------------------
  |  |  238|     20|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1861|     20|            return handled_error;
 1862|     20|         }
 1863|     28|      }
 1864|       |
 1865|     23|      background.index = 0;
 1866|     23|      background.red =
 1867|     23|      background.green =
 1868|     23|      background.blue =
 1869|     23|      background.gray = png_get_uint_16(buf);
  ------------------
  |  |  320|     23|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|     23|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|     23|   ((png_uint_16) \
  |  |  |  |  |  | 2690|     23|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|     23|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1870|     23|   }
 1871|       |
 1872|    425|   else
 1873|    425|   {
 1874|    425|      if (png_ptr->bit_depth <= 8)
  ------------------
  |  Branch (1874:11): [True: 381, False: 44]
  ------------------
 1875|    381|      {
 1876|    381|         if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)
  ------------------
  |  Branch (1876:14): [True: 121, False: 260]
  |  Branch (1876:29): [True: 50, False: 210]
  |  Branch (1876:44): [True: 13, False: 197]
  ------------------
 1877|    184|         {
 1878|    184|            png_chunk_benign_error(png_ptr, "invalid color");
  ------------------
  |  |  238|    184|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1879|    184|            return handled_error;
 1880|    184|         }
 1881|    381|      }
 1882|       |
 1883|    241|      background.index = 0;
 1884|    241|      background.red = png_get_uint_16(buf);
  ------------------
  |  |  320|    241|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    241|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    241|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    241|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    241|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1885|    241|      background.green = png_get_uint_16(buf + 2);
  ------------------
  |  |  320|    241|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    241|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    241|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    241|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    241|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1886|    241|      background.blue = png_get_uint_16(buf + 4);
  ------------------
  |  |  320|    241|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    241|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    241|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    241|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    241|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1887|    241|      background.gray = 0;
 1888|    241|   }
 1889|       |
 1890|    279|   png_set_bKGD(png_ptr, info_ptr, &background);
  ------------------
  |  |  368|    279|#define png_set_bKGD OSS_FUZZ_png_set_bKGD
  ------------------
 1891|    279|   return handled_ok;
 1892|    484|}
pngrutil.c:png_handle_cHRM:
 1241|  2.68k|{
 1242|  2.68k|   int error = 0;
 1243|  2.68k|   png_xy xy;
 1244|  2.68k|   png_byte buf[32];
 1245|       |
 1246|  2.68k|   png_debug(1, "in png_handle_cHRM");
  ------------------
  |  |  148|  2.68k|#  define png_debug(l, m) ((void)0)
  ------------------
 1247|       |
 1248|  2.68k|   png_crc_read(png_ptr, buf, 32);
  ------------------
  |  |   24|  2.68k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1249|       |
 1250|  2.68k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  2.68k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1250:8): [True: 601, False: 2.08k]
  ------------------
 1251|    601|      return handled_error;
 1252|       |
 1253|  2.08k|   xy.whitex = png_get_int_32_checked(buf +  0, &error);
 1254|  2.08k|   xy.whitey = png_get_int_32_checked(buf +  4, &error);
 1255|  2.08k|   xy.redx   = png_get_int_32_checked(buf +  8, &error);
 1256|  2.08k|   xy.redy   = png_get_int_32_checked(buf + 12, &error);
 1257|  2.08k|   xy.greenx = png_get_int_32_checked(buf + 16, &error);
 1258|  2.08k|   xy.greeny = png_get_int_32_checked(buf + 20, &error);
 1259|  2.08k|   xy.bluex  = png_get_int_32_checked(buf + 24, &error);
 1260|  2.08k|   xy.bluey  = png_get_int_32_checked(buf + 28, &error);
 1261|       |
 1262|  2.08k|   if (error)
  ------------------
  |  Branch (1262:8): [True: 1.58k, False: 503]
  ------------------
 1263|  1.58k|   {
 1264|  1.58k|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|  1.58k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1265|  1.58k|      return handled_error;
 1266|  1.58k|   }
 1267|       |
 1268|       |   /* png_set_cHRM may complain about some of the values but this doesn't matter
 1269|       |    * because it was a cHRM and it did have vaguely (if, perhaps, ridiculous)
 1270|       |    * values.  Ridiculousity will be checked if the values are used later.
 1271|       |    */
 1272|    503|   png_set_cHRM_fixed(png_ptr, info_ptr, xy.whitex, xy.whitey, xy.redx, xy.redy,
  ------------------
  |  |  376|    503|#define png_set_cHRM_fixed OSS_FUZZ_png_set_cHRM_fixed
  ------------------
 1273|    503|         xy.greenx, xy.greeny, xy.bluex, xy.bluey);
 1274|       |
 1275|       |   /* We only use 'chromaticities' for RGB to gray */
 1276|    503|#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 1277|       |      /* There is no need to check sRGB here, cICP is NYI and iCCP is not
 1278|       |       * supported so just check mDCV.
 1279|       |       */
 1280|    503|      if (!png_has_chunk(png_ptr, mDCV))
  ------------------
  |  |  194|    503|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    503|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    503|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1280:11): [True: 377, False: 126]
  ------------------
 1281|    377|      {
 1282|    377|         png_ptr->chromaticities = xy;
 1283|    377|      }
 1284|    503|#  endif /* READ_RGB_TO_GRAY */
 1285|       |
 1286|    503|   return handled_ok;
 1287|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1288|      0|}
pngrutil.c:png_get_int_32_checked:
 1223|  16.6k|{
 1224|  16.6k|   png_uint_32 uval = png_get_uint_32(buf);
  ------------------
  |  |  322|  16.6k|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|  16.6k|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|  16.6k|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|  16.6k|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|  16.6k|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|  16.6k|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1225|  16.6k|   if ((uval & 0x80000000) == 0) /* non-negative */
  ------------------
  |  Branch (1225:8): [True: 10.3k, False: 6.29k]
  ------------------
 1226|  10.3k|      return (png_int_32)uval;
 1227|       |
 1228|  6.29k|   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
 1229|  6.29k|   if ((uval & 0x80000000) == 0) /* no overflow */
  ------------------
  |  Branch (1229:8): [True: 4.28k, False: 2.01k]
  ------------------
 1230|  4.28k|      return -(png_int_32)uval;
 1231|       |
 1232|       |   /* This version of png_get_int_32 has a way of returning the error to the
 1233|       |    * caller, so:
 1234|       |    */
 1235|  2.01k|   *error = 1;
 1236|  2.01k|   return 0; /* Safe */
 1237|  6.29k|}
pngrutil.c:png_handle_cICP:
 1900|    534|{
 1901|    534|   png_byte buf[4];
 1902|       |
 1903|    534|   png_debug(1, "in png_handle_cICP");
  ------------------
  |  |  148|    534|#  define png_debug(l, m) ((void)0)
  ------------------
 1904|       |
 1905|    534|   png_crc_read(png_ptr, buf, 4);
  ------------------
  |  |   24|    534|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1906|       |
 1907|    534|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    534|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1907:8): [True: 300, False: 234]
  ------------------
 1908|    300|      return handled_error;
 1909|       |
 1910|    234|   png_set_cICP(png_ptr, info_ptr, buf[0], buf[1],  buf[2], buf[3]);
  ------------------
  |  |  377|    234|#define png_set_cICP OSS_FUZZ_png_set_cICP
  ------------------
 1911|       |
 1912|       |   /* We only use 'chromaticities' for RGB to gray */
 1913|    234|#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 1914|    234|      if (!png_has_chunk(png_ptr, mDCV))
  ------------------
  |  |  194|    234|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    234|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    234|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1914:11): [True: 65, False: 169]
  ------------------
 1915|     65|      {
 1916|       |         /* TODO: png_ptr->chromaticities = chromaticities; */
 1917|     65|      }
 1918|    234|#  endif /* READ_RGB_TO_GRAY */
 1919|       |
 1920|    234|#ifdef PNG_READ_GAMMA_SUPPORTED
 1921|       |      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  cICP is
 1922|       |       * at the head so simply set the gamma if it can be determined.  If not
 1923|       |       * chunk_gamma remains unchanged; sRGB and gAMA handling check it for
 1924|       |       * being zero.
 1925|       |       */
 1926|       |      /* TODO: set png_struct::chunk_gamma when possible */
 1927|    234|#endif /*READ_GAMMA*/
 1928|       |
 1929|    234|   return handled_ok;
 1930|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1931|      0|}
pngrutil.c:png_handle_cLLI:
 1939|    724|{
 1940|    724|   png_byte buf[8];
 1941|       |
 1942|    724|   png_debug(1, "in png_handle_cLLI");
  ------------------
  |  |  148|    724|#  define png_debug(l, m) ((void)0)
  ------------------
 1943|       |
 1944|    724|   png_crc_read(png_ptr, buf, 8);
  ------------------
  |  |   24|    724|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1945|       |
 1946|    724|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    724|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1946:8): [True: 507, False: 217]
  ------------------
 1947|    507|      return handled_error;
 1948|       |
 1949|       |   /* The error checking happens here, this puts it in just one place: */
 1950|    217|   png_set_cLLI_fixed(png_ptr, info_ptr, png_get_uint_32(buf),
  ------------------
  |  |  379|    217|#define png_set_cLLI_fixed OSS_FUZZ_png_set_cLLI_fixed
  ------------------
                 png_set_cLLI_fixed(png_ptr, info_ptr, png_get_uint_32(buf),
  ------------------
  |  |  322|    217|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    217|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    217|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    217|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    217|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    217|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1951|    217|         png_get_uint_32(buf+4));
  ------------------
  |  |  322|    217|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    217|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    217|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    217|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    217|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    217|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1952|    217|   return handled_ok;
 1953|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1954|      0|}
pngrutil.c:png_handle_eXIf:
 2016|    331|{
 2017|    331|   png_bytep buffer = NULL;
 2018|       |
 2019|    331|   png_debug(1, "in png_handle_eXIf");
  ------------------
  |  |  148|    331|#  define png_debug(l, m) ((void)0)
  ------------------
 2020|       |
 2021|    331|   buffer = png_read_buffer(png_ptr, length);
 2022|       |
 2023|    331|   if (buffer == NULL)
  ------------------
  |  Branch (2023:8): [True: 0, False: 331]
  ------------------
 2024|      0|   {
 2025|      0|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2026|      0|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2027|      0|      return handled_error;
 2028|      0|   }
 2029|       |
 2030|    331|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|    331|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2031|       |
 2032|    331|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    331|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2032:8): [True: 113, False: 218]
  ------------------
 2033|    113|      return handled_error;
 2034|       |
 2035|       |   /* PNGv3: the code used to check the byte order mark at the start for MM or
 2036|       |    * II, however PNGv3 states that the the first 4 bytes should be checked.
 2037|       |    * The caller ensures that there are four bytes available.
 2038|       |    */
 2039|    218|   {
 2040|    218|      png_uint_32 header = png_get_uint_32(buffer);
  ------------------
  |  |  322|    218|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    218|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    218|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    218|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    218|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    218|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2041|       |
 2042|       |      /* These numbers are copied from the PNGv3 spec: */
 2043|    218|      if (header != 0x49492A00 && header != 0x4D4D002A)
  ------------------
  |  Branch (2043:11): [True: 214, False: 4]
  |  Branch (2043:35): [True: 199, False: 15]
  ------------------
 2044|    199|      {
 2045|    199|         png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|    199|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2046|    199|         return handled_error;
 2047|    199|      }
 2048|    218|   }
 2049|       |
 2050|     19|   png_set_eXIf_1(png_ptr, info_ptr, length, buffer);
  ------------------
  |  |  386|     19|#define png_set_eXIf_1 OSS_FUZZ_png_set_eXIf_1
  ------------------
 2051|     19|   return handled_ok;
 2052|    218|}
pngrutil.c:png_handle_gAMA:
 1116|  1.15k|{
 1117|  1.15k|   png_uint_32 ugamma;
 1118|  1.15k|   png_byte buf[4];
 1119|       |
 1120|  1.15k|   png_debug(1, "in png_handle_gAMA");
  ------------------
  |  |  148|  1.15k|#  define png_debug(l, m) ((void)0)
  ------------------
 1121|       |
 1122|  1.15k|   png_crc_read(png_ptr, buf, 4);
  ------------------
  |  |   24|  1.15k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1123|       |
 1124|  1.15k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  1.15k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1124:8): [True: 334, False: 822]
  ------------------
 1125|    334|      return handled_error;
 1126|       |
 1127|    822|   ugamma = png_get_uint_32(buf);
  ------------------
  |  |  322|    822|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    822|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    822|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    822|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    822|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    822|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1128|       |
 1129|    822|   if (ugamma > PNG_UINT_31_MAX)
  ------------------
  |  |  647|    822|#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
  ------------------
  |  Branch (1129:8): [True: 19, False: 803]
  ------------------
 1130|     19|   {
 1131|     19|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     19|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1132|     19|      return handled_error;
 1133|     19|   }
 1134|       |
 1135|    803|   png_set_gAMA_fixed(png_ptr, info_ptr, (png_fixed_point)/*SAFE*/ugamma);
  ------------------
  |  |  393|    803|#define png_set_gAMA_fixed OSS_FUZZ_png_set_gAMA_fixed
  ------------------
 1136|       |
 1137|    803|#ifdef PNG_READ_GAMMA_SUPPORTED
 1138|       |      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  gAMA is
 1139|       |       * at the end of the chain so simply check for an unset value.
 1140|       |       */
 1141|    803|      if (png_ptr->chunk_gamma == 0)
  ------------------
  |  Branch (1141:11): [True: 630, False: 173]
  ------------------
 1142|    630|         png_ptr->chunk_gamma = (png_fixed_point)/*SAFE*/ugamma;
 1143|    803|#endif /*READ_GAMMA*/
 1144|       |
 1145|    803|   return handled_ok;
 1146|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1147|      0|}
pngrutil.c:png_handle_hIST:
 2060|     58|{
 2061|     58|   unsigned int num, i;
 2062|     58|   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
 2063|       |
 2064|     58|   png_debug(1, "in png_handle_hIST");
  ------------------
  |  |  148|     58|#  define png_debug(l, m) ((void)0)
  ------------------
 2065|       |
 2066|       |   /* This cast is safe because the chunk definition limits the length to a
 2067|       |    * maximum of 1024 bytes.
 2068|       |    *
 2069|       |    * TODO: maybe use png_uint_32 anyway, not unsigned int, to reduce the
 2070|       |    * casts.
 2071|       |    */
 2072|     58|   num = (unsigned int)length / 2 ;
 2073|       |
 2074|     58|   if (length != num * 2 ||
  ------------------
  |  Branch (2074:8): [True: 10, False: 48]
  ------------------
 2075|     58|       num != (unsigned int)png_ptr->num_palette ||
  ------------------
  |  Branch (2075:8): [True: 47, False: 1]
  ------------------
 2076|     58|       num > (unsigned int)PNG_MAX_PALETTE_LENGTH)
  ------------------
  |  |  723|      1|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  |  Branch (2076:8): [True: 0, False: 1]
  ------------------
 2077|     57|   {
 2078|     57|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     57|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2079|     57|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     57|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2080|     57|      return handled_error;
 2081|     57|   }
 2082|       |
 2083|      1|   for (i = 0; i < num; i++)
  ------------------
  |  Branch (2083:16): [True: 0, False: 1]
  ------------------
 2084|      0|   {
 2085|      0|      png_byte buf[2];
 2086|       |
 2087|      0|      png_crc_read(png_ptr, buf, 2);
  ------------------
  |  |   24|      0|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2088|      0|      readbuf[i] = png_get_uint_16(buf);
  ------------------
  |  |  320|      0|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|      0|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|      0|   ((png_uint_16) \
  |  |  |  |  |  | 2690|      0|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|      0|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2089|      0|   }
 2090|       |
 2091|      1|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2091:8): [True: 0, False: 1]
  ------------------
 2092|      0|      return handled_error;
 2093|       |
 2094|      1|   png_set_hIST(png_ptr, info_ptr, readbuf);
  ------------------
  |  |  397|      1|#define png_set_hIST OSS_FUZZ_png_set_hIST
  ------------------
 2095|      1|   return handled_ok;
 2096|      1|}
pngrutil.c:png_handle_iCCP:
 1342|    729|{
 1343|    729|   png_const_charp errmsg = NULL; /* error message output, or no error */
 1344|    729|   int finished = 0; /* crc checked */
 1345|       |
 1346|    729|   png_debug(1, "in png_handle_iCCP");
  ------------------
  |  |  148|    729|#  define png_debug(l, m) ((void)0)
  ------------------
 1347|       |
 1348|       |   /* PNGv3: allow PNG files with both sRGB and iCCP because the PNG spec only
 1349|       |    * ever said that there "should" be only one, not "shall" and the PNGv3
 1350|       |    * colour chunk precedence rules give a handling for this case anyway.
 1351|       |    */
 1352|    729|   {
 1353|    729|      uInt read_length, keyword_length;
 1354|    729|      char keyword[81];
 1355|       |
 1356|       |      /* Find the keyword; the keyword plus separator and compression method
 1357|       |       * bytes can be at most 81 characters long.
 1358|       |       */
 1359|    729|      read_length = 81; /* maximum */
 1360|    729|      if (read_length > length)
  ------------------
  |  Branch (1360:11): [True: 10, False: 719]
  ------------------
 1361|     10|         read_length = (uInt)/*SAFE*/length;
 1362|       |
 1363|    729|      png_crc_read(png_ptr, (png_bytep)keyword, read_length);
  ------------------
  |  |   24|    729|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1364|    729|      length -= read_length;
 1365|       |
 1366|    729|      if (length < LZ77Min)
  ------------------
  |  |   23|    729|#define LZ77Min  (2U+5U+4U)
  ------------------
  |  Branch (1366:11): [True: 10, False: 719]
  ------------------
 1367|     10|      {
 1368|     10|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     10|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1369|     10|         png_chunk_benign_error(png_ptr, "too short");
  ------------------
  |  |  238|     10|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1370|     10|         return handled_error;
 1371|     10|      }
 1372|       |
 1373|    719|      keyword_length = 0;
 1374|  17.2k|      while (keyword_length < 80 && keyword_length < read_length &&
  ------------------
  |  Branch (1374:14): [True: 17.2k, False: 22]
  |  Branch (1374:37): [True: 17.2k, False: 0]
  ------------------
 1375|  17.2k|         keyword[keyword_length] != 0)
  ------------------
  |  Branch (1375:10): [True: 16.5k, False: 697]
  ------------------
 1376|  16.5k|         ++keyword_length;
 1377|       |
 1378|       |      /* TODO: make the keyword checking common */
 1379|    719|      if (keyword_length >= 1 && keyword_length <= 79)
  ------------------
  |  Branch (1379:11): [True: 683, False: 36]
  |  Branch (1379:34): [True: 663, False: 20]
  ------------------
 1380|    663|      {
 1381|       |         /* We only understand '0' compression - deflate - so if we get a
 1382|       |          * different value we can't safely decode the chunk.
 1383|       |          */
 1384|    663|         if (keyword_length+1 < read_length &&
  ------------------
  |  Branch (1384:14): [True: 663, False: 0]
  ------------------
 1385|    663|            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)
  ------------------
  |  |  676|    663|#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
  ------------------
  |  Branch (1385:13): [True: 650, False: 13]
  ------------------
 1386|    650|         {
 1387|    650|            read_length -= keyword_length+2;
 1388|       |
 1389|    650|            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
  ------------------
  |  |  880|    650|#define png_iCCP PNG_U32(105,  67,  67,  80)
  |  |  ------------------
  |  |  |  |  821|    650|   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    650|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    650|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    650|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  |  |                  (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))
  |  |  |  |  ------------------
  |  |  |  |  |  |  819|    650|#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1389:17): [True: 650, False: 0]
  ------------------
 1390|    650|            {
 1391|    650|               Byte profile_header[132]={0};
 1392|    650|               Byte local_buffer[PNG_INFLATE_BUF_SIZE];
 1393|    650|               png_alloc_size_t size = (sizeof profile_header);
 1394|       |
 1395|    650|               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);
 1396|    650|               png_ptr->zstream.avail_in = read_length;
 1397|    650|               (void)png_inflate_read(png_ptr, local_buffer,
 1398|    650|                   (sizeof local_buffer), &length, profile_header, &size,
 1399|    650|                   0/*finish: don't, because the output is too small*/);
 1400|       |
 1401|    650|               if (size == 0)
  ------------------
  |  Branch (1401:20): [True: 525, False: 125]
  ------------------
 1402|    525|               {
 1403|       |                  /* We have the ICC profile header; do the basic header checks.
 1404|       |                   */
 1405|    525|                  png_uint_32 profile_length = png_get_uint_32(profile_header);
  ------------------
  |  |  322|    525|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    525|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    525|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    525|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    525|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    525|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1406|       |
 1407|    525|                  if (png_icc_check_length(png_ptr, keyword, profile_length) !=
  ------------------
  |  |   68|    525|#define png_icc_check_length OSS_FUZZ_png_icc_check_length
  ------------------
  |  Branch (1407:23): [True: 67, False: 458]
  ------------------
 1408|    525|                      0)
 1409|     67|                  {
 1410|       |                     /* The length is apparently ok, so we can check the 132
 1411|       |                      * byte header.
 1412|       |                      */
 1413|     67|                     if (png_icc_check_header(png_ptr, keyword, profile_length,
  ------------------
  |  |   69|     67|#define png_icc_check_header OSS_FUZZ_png_icc_check_header
  ------------------
  |  Branch (1413:26): [True: 0, False: 67]
  ------------------
 1414|     67|                              profile_header, png_ptr->color_type) != 0)
 1415|      0|                     {
 1416|       |                        /* Now read the tag table; a variable size buffer is
 1417|       |                         * needed at this point, allocate one for the whole
 1418|       |                         * profile.  The header check has already validated
 1419|       |                         * that none of this stuff will overflow.
 1420|       |                         */
 1421|      0|                        png_uint_32 tag_count =
 1422|      0|                           png_get_uint_32(profile_header + 128);
  ------------------
  |  |  322|      0|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|      0|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|      0|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|      0|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|      0|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|      0|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1423|      0|                        png_bytep profile = png_read_buffer(png_ptr,
 1424|      0|                              profile_length);
 1425|       |
 1426|      0|                        if (profile != NULL)
  ------------------
  |  Branch (1426:29): [True: 0, False: 0]
  ------------------
 1427|      0|                        {
 1428|      0|                           memcpy(profile, profile_header,
 1429|      0|                               (sizeof profile_header));
 1430|       |
 1431|      0|                           size = 12 * tag_count;
 1432|       |
 1433|      0|                           (void)png_inflate_read(png_ptr, local_buffer,
 1434|      0|                               (sizeof local_buffer), &length,
 1435|      0|                               profile + (sizeof profile_header), &size, 0);
 1436|       |
 1437|       |                           /* Still expect a buffer error because we expect
 1438|       |                            * there to be some tag data!
 1439|       |                            */
 1440|      0|                           if (size == 0)
  ------------------
  |  Branch (1440:32): [True: 0, False: 0]
  ------------------
 1441|      0|                           {
 1442|      0|                              if (png_icc_check_tag_table(png_ptr,
  ------------------
  |  |   70|      0|#define png_icc_check_tag_table OSS_FUZZ_png_icc_check_tag_table
  ------------------
  |  Branch (1442:35): [True: 0, False: 0]
  ------------------
 1443|      0|                                       keyword, profile_length, profile) != 0)
 1444|      0|                              {
 1445|       |                                 /* The profile has been validated for basic
 1446|       |                                  * security issues, so read the whole thing in.
 1447|       |                                  */
 1448|      0|                                 size = profile_length - (sizeof profile_header)
 1449|      0|                                     - 12 * tag_count;
 1450|       |
 1451|      0|                                 (void)png_inflate_read(png_ptr, local_buffer,
 1452|      0|                                     (sizeof local_buffer), &length,
 1453|      0|                                     profile + (sizeof profile_header) +
 1454|      0|                                     12 * tag_count, &size, 1/*finish*/);
 1455|       |
 1456|      0|                                 if (length > 0 && !(png_ptr->flags &
  ------------------
  |  Branch (1456:38): [True: 0, False: 0]
  |  Branch (1456:52): [True: 0, False: 0]
  ------------------
 1457|      0|                                     PNG_FLAG_BENIGN_ERRORS_WARN))
  ------------------
  |  |  691|      0|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
 1458|      0|                                    errmsg = "extra compressed data";
 1459|       |
 1460|       |                                 /* But otherwise allow extra data: */
 1461|      0|                                 else if (size == 0)
  ------------------
  |  Branch (1461:43): [True: 0, False: 0]
  ------------------
 1462|      0|                                 {
 1463|      0|                                    if (length > 0)
  ------------------
  |  Branch (1463:41): [True: 0, False: 0]
  ------------------
 1464|      0|                                    {
 1465|       |                                       /* This can be handled completely, so
 1466|       |                                        * keep going.
 1467|       |                                        */
 1468|      0|                                       png_chunk_warning(png_ptr,
  ------------------
  |  |  240|      0|#define png_chunk_warning OSS_FUZZ_png_chunk_warning
  ------------------
 1469|      0|                                           "extra compressed data");
 1470|      0|                                    }
 1471|       |
 1472|      0|                                    png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1473|      0|                                    finished = 1;
 1474|       |
 1475|       |                                    /* Steal the profile for info_ptr. */
 1476|      0|                                    if (info_ptr != NULL)
  ------------------
  |  Branch (1476:41): [True: 0, False: 0]
  ------------------
 1477|      0|                                    {
 1478|      0|                                       png_free_data(png_ptr, info_ptr,
  ------------------
  |  |  254|      0|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
 1479|      0|                                           PNG_FREE_ICCP, 0);
  ------------------
  |  | 1759|      0|#define PNG_FREE_ICCP 0x0010U
  ------------------
 1480|       |
 1481|      0|                                       info_ptr->iccp_name = png_voidcast(char*,
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
 1482|      0|                                           png_malloc_base(png_ptr,
 1483|      0|                                           keyword_length+1));
 1484|      0|                                       if (info_ptr->iccp_name != NULL)
  ------------------
  |  Branch (1484:44): [True: 0, False: 0]
  ------------------
 1485|      0|                                       {
 1486|      0|                                          memcpy(info_ptr->iccp_name, keyword,
 1487|      0|                                              keyword_length+1);
 1488|      0|                                          info_ptr->iccp_proflen =
 1489|      0|                                              profile_length;
 1490|      0|                                          info_ptr->iccp_profile = profile;
 1491|      0|                                          png_ptr->read_buffer = NULL; /*steal*/
 1492|      0|                                          info_ptr->free_me |= PNG_FREE_ICCP;
  ------------------
  |  | 1759|      0|#define PNG_FREE_ICCP 0x0010U
  ------------------
 1493|      0|                                          info_ptr->valid |= PNG_INFO_iCCP;
  ------------------
  |  |  742|      0|#define PNG_INFO_iCCP 0x1000U  /* ESR, 1.0.6 */
  ------------------
 1494|      0|                                       }
 1495|       |
 1496|      0|                                       else
 1497|      0|                                          errmsg = "out of memory";
 1498|      0|                                    }
 1499|       |
 1500|       |                                    /* else the profile remains in the read
 1501|       |                                     * buffer which gets reused for subsequent
 1502|       |                                     * chunks.
 1503|       |                                     */
 1504|       |
 1505|      0|                                    if (errmsg == NULL)
  ------------------
  |  Branch (1505:41): [True: 0, False: 0]
  ------------------
 1506|      0|                                    {
 1507|      0|                                       png_ptr->zowner = 0;
 1508|      0|                                       return handled_ok;
 1509|      0|                                    }
 1510|      0|                                 }
 1511|      0|                                 if (errmsg == NULL)
  ------------------
  |  Branch (1511:38): [True: 0, False: 0]
  ------------------
 1512|      0|                                    errmsg = png_ptr->zstream.msg;
 1513|      0|                              }
 1514|       |                              /* else png_icc_check_tag_table output an error */
 1515|      0|                           }
 1516|      0|                           else /* profile truncated */
 1517|      0|                              errmsg = png_ptr->zstream.msg;
 1518|      0|                        }
 1519|       |
 1520|      0|                        else
 1521|      0|                           errmsg = "out of memory";
 1522|      0|                     }
 1523|       |
 1524|       |                     /* else png_icc_check_header output an error */
 1525|     67|                  }
 1526|       |
 1527|       |                  /* else png_icc_check_length output an error */
 1528|    525|               }
 1529|       |
 1530|    125|               else /* profile truncated */
 1531|    125|                  errmsg = png_ptr->zstream.msg;
 1532|       |
 1533|       |               /* Release the stream */
 1534|    650|               png_ptr->zowner = 0;
 1535|    650|            }
 1536|       |
 1537|      0|            else /* png_inflate_claim failed */
 1538|      0|               errmsg = png_ptr->zstream.msg;
 1539|    650|         }
 1540|       |
 1541|     13|         else
 1542|     13|            errmsg = "bad compression method"; /* or missing */
 1543|    663|      }
 1544|       |
 1545|     56|      else
 1546|     56|         errmsg = "bad keyword";
 1547|    719|   }
 1548|       |
 1549|       |   /* Failure: the reason is in 'errmsg' */
 1550|    719|   if (finished == 0)
  ------------------
  |  Branch (1550:8): [True: 713, False: 6]
  ------------------
 1551|    713|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|    713|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1552|       |
 1553|    719|   if (errmsg != NULL) /* else already output */
  ------------------
  |  Branch (1553:8): [True: 169, False: 550]
  ------------------
 1554|    169|      png_chunk_benign_error(png_ptr, errmsg);
  ------------------
  |  |  238|    169|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1555|       |
 1556|    719|   return handled_error;
 1557|    719|}
pngrutil.c:png_inflate_read:
  839|    650|{
  840|    650|   if (png_ptr->zowner == png_ptr->chunk_name)
  ------------------
  |  Branch (840:8): [True: 650, False: 0]
  ------------------
  841|    650|   {
  842|    650|      int ret;
  843|       |
  844|       |      /* next_in and avail_in must have been initialized by the caller. */
  845|    650|      png_ptr->zstream.next_out = next_out;
  846|    650|      png_ptr->zstream.avail_out = 0; /* set in the loop */
  847|       |
  848|    650|      do
  849|  1.14k|      {
  850|  1.14k|         if (png_ptr->zstream.avail_in == 0)
  ------------------
  |  Branch (850:14): [True: 499, False: 644]
  ------------------
  851|    499|         {
  852|    499|            if (read_size > *chunk_bytes)
  ------------------
  |  Branch (852:17): [True: 498, False: 1]
  ------------------
  853|    498|               read_size = (uInt)*chunk_bytes;
  854|    499|            *chunk_bytes -= read_size;
  855|       |
  856|    499|            if (read_size > 0)
  ------------------
  |  Branch (856:17): [True: 481, False: 18]
  ------------------
  857|    481|               png_crc_read(png_ptr, read_buffer, read_size);
  ------------------
  |  |   24|    481|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
  858|       |
  859|    499|            png_ptr->zstream.next_in = read_buffer;
  860|    499|            png_ptr->zstream.avail_in = read_size;
  861|    499|         }
  862|       |
  863|  1.14k|         if (png_ptr->zstream.avail_out == 0)
  ------------------
  |  Branch (863:14): [True: 650, False: 493]
  ------------------
  864|    650|         {
  865|    650|            uInt avail = ZLIB_IO_MAX;
  ------------------
  |  |   53|    650|#  define ZLIB_IO_MAX ((uInt)-1)
  ------------------
  866|    650|            if (avail > *out_size)
  ------------------
  |  Branch (866:17): [True: 650, False: 0]
  ------------------
  867|    650|               avail = (uInt)*out_size;
  868|    650|            *out_size -= avail;
  869|       |
  870|    650|            png_ptr->zstream.avail_out = avail;
  871|    650|         }
  872|       |
  873|       |         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
  874|       |          * the available output is produced; this allows reading of truncated
  875|       |          * streams.
  876|       |          */
  877|  1.14k|         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?
  ------------------
  |  | 1554|  3.28k|#  define PNG_INFLATE(pp, flush) png_zlib_inflate(pp, flush)
  |  |  ------------------
  |  |  |  |   42|  1.14k|#define png_zlib_inflate OSS_FUZZ_png_zlib_inflate
  |  |  ------------------
  |  |  |  Branch (1554:55): [True: 0, False: 499]
  |  |  |  Branch (1554:55): [True: 644, False: 499]
  |  |  ------------------
  ------------------
  878|  1.14k|             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));
  879|  1.14k|      }
  880|  1.14k|      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));
  ------------------
  |  Branch (880:14): [True: 1.01k, False: 125]
  |  Branch (880:30): [True: 0, False: 1.01k]
  |  Branch (880:47): [True: 493, False: 525]
  ------------------
  881|       |
  882|    650|      *out_size += png_ptr->zstream.avail_out;
  883|    650|      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */
  884|       |
  885|       |      /* Ensure the error message pointer is always set: */
  886|    650|      png_zstream_error(png_ptr, ret);
  ------------------
  |  |    4|    650|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  887|    650|      return ret;
  888|    650|   }
  889|       |
  890|      0|   else
  891|      0|   {
  892|      0|      png_ptr->zstream.msg = PNGZ_MSG_CAST("zstream unclaimed");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
  893|      0|      return Z_STREAM_ERROR;
  894|      0|   }
  895|    650|}
pngrutil.c:png_handle_iTXt:
 2584|  2.51k|{
 2585|  2.51k|   png_const_charp errmsg = NULL;
 2586|  2.51k|   png_bytep buffer;
 2587|  2.51k|   png_uint_32 prefix_length;
 2588|       |
 2589|  2.51k|   png_debug(1, "in png_handle_iTXt");
  ------------------
  |  |  148|  2.51k|#  define png_debug(l, m) ((void)0)
  ------------------
 2590|       |
 2591|  2.51k|#ifdef PNG_USER_LIMITS_SUPPORTED
 2592|  2.51k|   if (png_ptr->user_chunk_cache_max != 0)
  ------------------
  |  Branch (2592:8): [True: 2.51k, False: 0]
  ------------------
 2593|  2.51k|   {
 2594|  2.51k|      if (png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2594:11): [True: 0, False: 2.51k]
  ------------------
 2595|      0|      {
 2596|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2597|      0|         return handled_error;
 2598|      0|      }
 2599|       |
 2600|  2.51k|      if (--png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2600:11): [True: 0, False: 2.51k]
  ------------------
 2601|      0|      {
 2602|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2603|      0|         png_chunk_benign_error(png_ptr, "no space in chunk cache");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2604|      0|         return handled_error;
 2605|      0|      }
 2606|  2.51k|   }
 2607|  2.51k|#endif
 2608|       |
 2609|       |   /* TODO: should not be necessary. */
 2610|  2.51k|   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|  2.51k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (2610:8): [True: 406, False: 2.10k]
  ------------------
 2611|    406|      png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|    406|#define PNG_AFTER_IDAT 0x08
  ------------------
 2612|       |
 2613|  2.51k|   buffer = png_read_buffer(png_ptr, length+1);
 2614|       |
 2615|  2.51k|   if (buffer == NULL)
  ------------------
  |  Branch (2615:8): [True: 1, False: 2.51k]
  ------------------
 2616|      1|   {
 2617|      1|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2618|      1|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2619|      1|      return handled_error;
 2620|      1|   }
 2621|       |
 2622|  2.51k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  2.51k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2623|       |
 2624|  2.51k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  2.51k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2624:8): [True: 561, False: 1.95k]
  ------------------
 2625|    561|      return handled_error;
 2626|       |
 2627|       |   /* First the keyword. */
 2628|  1.95k|   for (prefix_length=0;
 2629|  21.6k|      prefix_length < length && buffer[prefix_length] != 0;
  ------------------
  |  Branch (2629:7): [True: 21.6k, False: 20]
  |  Branch (2629:33): [True: 19.7k, False: 1.93k]
  ------------------
 2630|  19.7k|      ++prefix_length)
 2631|  19.7k|      /* Empty loop */ ;
 2632|       |
 2633|       |   /* Perform a basic check on the keyword length here. */
 2634|  1.95k|   if (prefix_length > 79 || prefix_length < 1)
  ------------------
  |  Branch (2634:8): [True: 22, False: 1.93k]
  |  Branch (2634:30): [True: 20, False: 1.91k]
  ------------------
 2635|     36|      errmsg = "bad keyword";
 2636|       |
 2637|       |   /* Expect keyword, compression flag, compression type, language, translated
 2638|       |    * keyword (both may be empty but are 0 terminated) then the text, which may
 2639|       |    * be empty.
 2640|       |    */
 2641|  1.91k|   else if (prefix_length + 5 > length)
  ------------------
  |  Branch (2641:13): [True: 11, False: 1.90k]
  ------------------
 2642|     11|      errmsg = "truncated";
 2643|       |
 2644|  1.90k|   else if (buffer[prefix_length+1] == 0 ||
  ------------------
  |  Branch (2644:13): [True: 642, False: 1.26k]
  ------------------
 2645|  1.90k|      (buffer[prefix_length+1] == 1 &&
  ------------------
  |  Branch (2645:8): [True: 1.21k, False: 51]
  ------------------
 2646|  1.26k|      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
  ------------------
  |  |  676|  1.21k|#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
  ------------------
  |  Branch (2646:7): [True: 1.17k, False: 39]
  ------------------
 2647|  1.80k|   {
 2648|  1.80k|      int compressed = buffer[prefix_length+1] != 0;
 2649|  1.80k|      png_uint_32 language_offset, translated_keyword_offset;
 2650|  1.80k|      png_alloc_size_t uncompressed_length = 0;
 2651|       |
 2652|       |      /* Now the language tag */
 2653|  1.80k|      prefix_length += 3;
 2654|  1.80k|      language_offset = prefix_length;
 2655|       |
 2656|  16.4k|      for (; prefix_length < length && buffer[prefix_length] != 0;
  ------------------
  |  Branch (2656:14): [True: 16.4k, False: 16]
  |  Branch (2656:40): [True: 14.6k, False: 1.79k]
  ------------------
 2657|  14.6k|         ++prefix_length)
 2658|  14.6k|         /* Empty loop */ ;
 2659|       |
 2660|       |      /* WARNING: the length may be invalid here, this is checked below. */
 2661|  1.80k|      translated_keyword_offset = ++prefix_length;
 2662|       |
 2663|  23.5k|      for (; prefix_length < length && buffer[prefix_length] != 0;
  ------------------
  |  Branch (2663:14): [True: 23.4k, False: 31]
  |  Branch (2663:40): [True: 21.7k, False: 1.77k]
  ------------------
 2664|  21.7k|         ++prefix_length)
 2665|  21.7k|         /* Empty loop */ ;
 2666|       |
 2667|       |      /* prefix_length should now be at the trailing '\0' of the translated
 2668|       |       * keyword, but it may already be over the end.  None of this arithmetic
 2669|       |       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
 2670|       |       * systems the available allocation may overflow.
 2671|       |       */
 2672|  1.80k|      ++prefix_length;
 2673|       |
 2674|  1.80k|      if (compressed == 0 && prefix_length <= length)
  ------------------
  |  Branch (2674:11): [True: 636, False: 1.17k]
  |  Branch (2674:30): [True: 620, False: 16]
  ------------------
 2675|    620|         uncompressed_length = length - prefix_length;
 2676|       |
 2677|  1.18k|      else if (compressed != 0 && prefix_length < length)
  ------------------
  |  Branch (2677:16): [True: 1.17k, False: 16]
  |  Branch (2677:35): [True: 1.15k, False: 15]
  ------------------
 2678|  1.15k|      {
 2679|  1.15k|         uncompressed_length = PNG_SIZE_MAX;
  ------------------
  |  |  649|  1.15k|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
 2680|       |
 2681|       |         /* TODO: at present png_decompress_chunk imposes a single application
 2682|       |          * level memory limit, this should be split to different values for
 2683|       |          * iCCP and text chunks.
 2684|       |          */
 2685|  1.15k|         if (png_decompress_chunk(png_ptr, length, prefix_length,
  ------------------
  |  Branch (2685:14): [True: 303, False: 855]
  ------------------
 2686|  1.15k|             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
 2687|    303|            buffer = png_ptr->read_buffer;
 2688|       |
 2689|    855|         else
 2690|    855|            errmsg = png_ptr->zstream.msg;
 2691|  1.15k|      }
 2692|       |
 2693|     31|      else
 2694|     31|         errmsg = "truncated";
 2695|       |
 2696|  1.80k|      if (errmsg == NULL)
  ------------------
  |  Branch (2696:11): [True: 923, False: 886]
  ------------------
 2697|    923|      {
 2698|    923|         png_text text;
 2699|       |
 2700|    923|         buffer[uncompressed_length+prefix_length] = 0;
 2701|       |
 2702|    923|         if (compressed == 0)
  ------------------
  |  Branch (2702:14): [True: 620, False: 303]
  ------------------
 2703|    620|            text.compression = PNG_ITXT_COMPRESSION_NONE;
  ------------------
  |  |  588|    620|#define PNG_ITXT_COMPRESSION_NONE     1
  ------------------
 2704|       |
 2705|    303|         else
 2706|    303|            text.compression = PNG_ITXT_COMPRESSION_zTXt;
  ------------------
  |  |  589|    303|#define PNG_ITXT_COMPRESSION_zTXt     2
  ------------------
 2707|       |
 2708|    923|         text.key = (png_charp)buffer;
 2709|    923|         text.lang = (png_charp)buffer + language_offset;
 2710|    923|         text.lang_key = (png_charp)buffer + translated_keyword_offset;
 2711|    923|         text.text = (png_charp)buffer + prefix_length;
 2712|    923|         text.text_length = 0;
 2713|    923|         text.itxt_length = uncompressed_length;
 2714|       |
 2715|    923|         if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)
  ------------------
  |  |   31|    923|#define png_set_text_2 OSS_FUZZ_png_set_text_2
  ------------------
  |  Branch (2715:14): [True: 923, False: 0]
  ------------------
 2716|    923|            return handled_ok;
 2717|       |
 2718|      0|         errmsg = "out of memory";
 2719|      0|      }
 2720|  1.80k|   }
 2721|       |
 2722|     96|   else
 2723|     96|      errmsg = "bad compression info";
 2724|       |
 2725|  1.02k|   if (errmsg != NULL)
  ------------------
  |  Branch (2725:8): [True: 1.02k, False: 6]
  ------------------
 2726|  1.02k|      png_chunk_benign_error(png_ptr, errmsg);
  ------------------
  |  |  238|  1.02k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2727|  1.02k|   return handled_error;
 2728|  1.95k|}
pngrutil.c:png_decompress_chunk:
  685|  2.03k|{
  686|       |   /* TODO: implement different limits for different types of chunk.
  687|       |    *
  688|       |    * The caller supplies *newlength set to the maximum length of the
  689|       |    * uncompressed data, but this routine allocates space for the prefix and
  690|       |    * maybe a '\0' terminator too.  We have to assume that 'prefix_size' is
  691|       |    * limited only by the maximum chunk size.
  692|       |    */
  693|  2.03k|   png_alloc_size_t limit = png_chunk_max(png_ptr);
  ------------------
  |  | 1097|  2.03k|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
  694|       |
  695|  2.03k|   if (limit >= prefix_size + (terminate != 0))
  ------------------
  |  Branch (695:8): [True: 2.03k, False: 0]
  ------------------
  696|  2.03k|   {
  697|  2.03k|      int ret;
  698|       |
  699|  2.03k|      limit -= prefix_size + (terminate != 0);
  700|       |
  701|  2.03k|      if (limit < *newlength)
  ------------------
  |  Branch (701:11): [True: 2.03k, False: 0]
  ------------------
  702|  2.03k|         *newlength = limit;
  703|       |
  704|       |      /* Now try to claim the stream. */
  705|  2.03k|      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);
  706|       |
  707|  2.03k|      if (ret == Z_OK)
  ------------------
  |  Branch (707:11): [True: 2.03k, False: 0]
  ------------------
  708|  2.03k|      {
  709|  2.03k|         png_uint_32 lzsize = chunklength - prefix_size;
  710|       |
  711|  2.03k|         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,
  712|  2.03k|             /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,
  713|       |             /* output: */ NULL, newlength);
  714|       |
  715|  2.03k|         if (ret == Z_STREAM_END)
  ------------------
  |  Branch (715:14): [True: 317, False: 1.71k]
  ------------------
  716|    317|         {
  717|       |            /* Use 'inflateReset' here, not 'inflateReset2' because this
  718|       |             * preserves the previously decided window size (otherwise it would
  719|       |             * be necessary to store the previous window size.)  In practice
  720|       |             * this doesn't matter anyway, because png_inflate will call inflate
  721|       |             * with Z_FINISH in almost all cases, so the window will not be
  722|       |             * maintained.
  723|       |             */
  724|    317|            if (inflateReset(&png_ptr->zstream) == Z_OK)
  ------------------
  |  Branch (724:17): [True: 317, False: 0]
  ------------------
  725|    317|            {
  726|       |               /* Because of the limit checks above we know that the new,
  727|       |                * expanded, size will fit in a size_t (let alone an
  728|       |                * png_alloc_size_t).  Use png_malloc_base here to avoid an
  729|       |                * extra OOM message.
  730|       |                */
  731|    317|               png_alloc_size_t new_size = *newlength;
  732|    317|               png_alloc_size_t buffer_size = prefix_size + new_size +
  733|    317|                   (terminate != 0);
  734|    317|               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,
  ------------------
  |  |  511|    317|#  define png_voidcast(type, value) (value)
  ------------------
  735|    317|                   buffer_size));
  736|       |
  737|    317|               if (text != NULL)
  ------------------
  |  Branch (737:20): [True: 317, False: 0]
  ------------------
  738|    317|               {
  739|    317|                  memset(text, 0, buffer_size);
  740|       |
  741|    317|                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,
  742|    317|                      png_ptr->read_buffer + prefix_size, &lzsize,
  743|    317|                      text + prefix_size, newlength);
  744|       |
  745|    317|                  if (ret == Z_STREAM_END)
  ------------------
  |  Branch (745:23): [True: 317, False: 0]
  ------------------
  746|    317|                  {
  747|    317|                     if (new_size == *newlength)
  ------------------
  |  Branch (747:26): [True: 317, False: 0]
  ------------------
  748|    317|                     {
  749|    317|                        if (terminate != 0)
  ------------------
  |  Branch (749:29): [True: 317, False: 0]
  ------------------
  750|    317|                           text[prefix_size + *newlength] = 0;
  751|       |
  752|    317|                        if (prefix_size > 0)
  ------------------
  |  Branch (752:29): [True: 317, False: 0]
  ------------------
  753|    317|                           memcpy(text, png_ptr->read_buffer, prefix_size);
  754|       |
  755|    317|                        {
  756|    317|                           png_bytep old_ptr = png_ptr->read_buffer;
  757|       |
  758|    317|                           png_ptr->read_buffer = text;
  759|    317|                           png_ptr->read_buffer_size = buffer_size;
  760|    317|                           text = old_ptr; /* freed below */
  761|    317|                        }
  762|    317|                     }
  763|       |
  764|      0|                     else
  765|      0|                     {
  766|       |                        /* The size changed on the second read, there can be no
  767|       |                         * guarantee that anything is correct at this point.
  768|       |                         * The 'msg' pointer has been set to "unexpected end of
  769|       |                         * LZ stream", which is fine, but return an error code
  770|       |                         * that the caller won't accept.
  771|       |                         */
  772|      0|                        ret = PNG_UNEXPECTED_ZLIB_RETURN;
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  773|      0|                     }
  774|    317|                  }
  775|       |
  776|      0|                  else if (ret == Z_OK)
  ------------------
  |  Branch (776:28): [True: 0, False: 0]
  ------------------
  777|      0|                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  778|       |
  779|       |                  /* Free the text pointer (this is the old read_buffer on
  780|       |                   * success)
  781|       |                   */
  782|    317|                  png_free(png_ptr, text);
  ------------------
  |  |  253|    317|#define png_free OSS_FUZZ_png_free
  ------------------
  783|       |
  784|       |                  /* This really is very benign, but it's still an error because
  785|       |                   * the extra space may otherwise be used as a Trojan Horse.
  786|       |                   */
  787|    317|                  if (ret == Z_STREAM_END &&
  ------------------
  |  Branch (787:23): [True: 317, False: 0]
  ------------------
  788|    317|                      chunklength - prefix_size != lzsize)
  ------------------
  |  Branch (788:23): [True: 1, False: 316]
  ------------------
  789|      1|                     png_chunk_benign_error(png_ptr, "extra compressed data");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
  790|    317|               }
  791|       |
  792|      0|               else
  793|      0|               {
  794|       |                  /* Out of memory allocating the buffer */
  795|      0|                  ret = Z_MEM_ERROR;
  796|      0|                  png_zstream_error(png_ptr, Z_MEM_ERROR);
  ------------------
  |  |    4|      0|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  797|      0|               }
  798|    317|            }
  799|       |
  800|      0|            else
  801|      0|            {
  802|       |               /* inflateReset failed, store the error message */
  803|      0|               png_zstream_error(png_ptr, ret);
  ------------------
  |  |    4|      0|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  804|      0|               ret = PNG_UNEXPECTED_ZLIB_RETURN;
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  805|      0|            }
  806|    317|         }
  807|       |
  808|  1.71k|         else if (ret == Z_OK)
  ------------------
  |  Branch (808:19): [True: 0, False: 1.71k]
  ------------------
  809|      0|            ret = PNG_UNEXPECTED_ZLIB_RETURN;
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  810|       |
  811|       |         /* Release the claimed stream */
  812|  2.03k|         png_ptr->zowner = 0;
  813|  2.03k|      }
  814|       |
  815|      0|      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */
  ------------------
  |  Branch (815:39): [True: 0, False: 0]
  ------------------
  816|      0|         ret = PNG_UNEXPECTED_ZLIB_RETURN;
  ------------------
  |  | 1053|      0|#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
  ------------------
  817|       |
  818|  2.03k|      return ret;
  819|  2.03k|   }
  820|       |
  821|      0|   else
  822|      0|   {
  823|       |      /* Application/configuration limits exceeded */
  824|      0|      png_zstream_error(png_ptr, Z_MEM_ERROR);
  ------------------
  |  |    4|      0|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  825|      0|      return Z_MEM_ERROR;
  826|      0|   }
  827|  2.03k|}
pngrutil.c:png_inflate:
  559|  2.34k|{
  560|  2.34k|   if (png_ptr->zowner == owner) /* Else not claimed */
  ------------------
  |  Branch (560:8): [True: 2.34k, False: 0]
  ------------------
  561|  2.34k|   {
  562|  2.34k|      int ret;
  563|  2.34k|      png_alloc_size_t avail_out = *output_size_ptr;
  564|  2.34k|      png_uint_32 avail_in = *input_size_ptr;
  565|       |
  566|       |      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it
  567|       |       * can't even necessarily handle 65536 bytes) because the type uInt is
  568|       |       * "16 bits or more".  Consequently it is necessary to chunk the input to
  569|       |       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the
  570|       |       * maximum value that can be stored in a uInt.)  It is possible to set
  571|       |       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have
  572|       |       * a performance advantage, because it reduces the amount of data accessed
  573|       |       * at each step and that may give the OS more time to page it in.
  574|       |       */
  575|  2.34k|      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);
  ------------------
  |  |   41|  2.34k|#  define PNGZ_INPUT_CAST(b) (b)
  ------------------
  576|       |      /* avail_in and avail_out are set below from 'size' */
  577|  2.34k|      png_ptr->zstream.avail_in = 0;
  578|  2.34k|      png_ptr->zstream.avail_out = 0;
  579|       |
  580|       |      /* Read directly into the output if it is available (this is set to
  581|       |       * a local buffer below if output is NULL).
  582|       |       */
  583|  2.34k|      if (output != NULL)
  ------------------
  |  Branch (583:11): [True: 317, False: 2.03k]
  ------------------
  584|    317|         png_ptr->zstream.next_out = output;
  585|       |
  586|  2.34k|      do
  587|  2.81k|      {
  588|  2.81k|         uInt avail;
  589|  2.81k|         Byte local_buffer[PNG_INFLATE_BUF_SIZE];
  590|       |
  591|       |         /* zlib INPUT BUFFER */
  592|       |         /* The setting of 'avail_in' used to be outside the loop; by setting it
  593|       |          * inside it is possible to chunk the input to zlib and simply rely on
  594|       |          * zlib to advance the 'next_in' pointer.  This allows arbitrary
  595|       |          * amounts of data to be passed through zlib at the unavoidable cost of
  596|       |          * requiring a window save (memcpy of up to 32768 output bytes)
  597|       |          * every ZLIB_IO_MAX input bytes.
  598|       |          */
  599|  2.81k|         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */
  600|       |
  601|  2.81k|         avail = ZLIB_IO_MAX;
  ------------------
  |  |   53|  2.81k|#  define ZLIB_IO_MAX ((uInt)-1)
  ------------------
  602|       |
  603|  2.81k|         if (avail_in < avail)
  ------------------
  |  Branch (603:14): [True: 2.81k, False: 0]
  ------------------
  604|  2.81k|            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */
  605|       |
  606|  2.81k|         avail_in -= avail;
  607|  2.81k|         png_ptr->zstream.avail_in = avail;
  608|       |
  609|       |         /* zlib OUTPUT BUFFER */
  610|  2.81k|         avail_out += png_ptr->zstream.avail_out; /* not written last time */
  611|       |
  612|  2.81k|         avail = ZLIB_IO_MAX; /* maximum zlib can process */
  ------------------
  |  |   53|  2.81k|#  define ZLIB_IO_MAX ((uInt)-1)
  ------------------
  613|       |
  614|  2.81k|         if (output == NULL)
  ------------------
  |  Branch (614:14): [True: 2.49k, False: 317]
  ------------------
  615|  2.49k|         {
  616|       |            /* Reset the output buffer each time round if output is NULL and
  617|       |             * make available the full buffer, up to 'remaining_space'
  618|       |             */
  619|  2.49k|            png_ptr->zstream.next_out = local_buffer;
  620|  2.49k|            if ((sizeof local_buffer) < avail)
  ------------------
  |  Branch (620:17): [True: 2.49k, False: 0]
  ------------------
  621|  2.49k|               avail = (sizeof local_buffer);
  622|  2.49k|         }
  623|       |
  624|  2.81k|         if (avail_out < avail)
  ------------------
  |  Branch (624:14): [True: 317, False: 2.49k]
  ------------------
  625|    317|            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */
  626|       |
  627|  2.81k|         png_ptr->zstream.avail_out = avail;
  628|  2.81k|         avail_out -= avail;
  629|       |
  630|       |         /* zlib inflate call */
  631|       |         /* In fact 'avail_out' may be 0 at this point, that happens at the end
  632|       |          * of the read when the final LZ end code was not passed at the end of
  633|       |          * the previous chunk of input data.  Tell zlib if we have reached the
  634|       |          * end of the output buffer.
  635|       |          */
  636|  2.81k|         ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :
  ------------------
  |  | 1554|  6.25k|#  define PNG_INFLATE(pp, flush) png_zlib_inflate(pp, flush)
  |  |  ------------------
  |  |  |  |   42|  2.81k|#define png_zlib_inflate OSS_FUZZ_png_zlib_inflate
  |  |  ------------------
  |  |  |  Branch (1554:55): [True: 317, False: 0]
  |  |  |  Branch (1554:55): [True: 2.49k, False: 317]
  |  |  ------------------
  ------------------
  637|  2.81k|             (finish ? Z_FINISH : Z_SYNC_FLUSH));
  638|  2.81k|      } while (ret == Z_OK);
  ------------------
  |  Branch (638:16): [True: 461, False: 2.34k]
  ------------------
  639|       |
  640|       |      /* For safety kill the local buffer pointer now */
  641|  2.34k|      if (output == NULL)
  ------------------
  |  Branch (641:11): [True: 2.03k, False: 317]
  ------------------
  642|  2.03k|         png_ptr->zstream.next_out = NULL;
  643|       |
  644|       |      /* Claw back the 'size' and 'remaining_space' byte counts. */
  645|  2.34k|      avail_in += png_ptr->zstream.avail_in;
  646|  2.34k|      avail_out += png_ptr->zstream.avail_out;
  647|       |
  648|       |      /* Update the input and output sizes; the updated values are the amount
  649|       |       * consumed or written, effectively the inverse of what zlib uses.
  650|       |       */
  651|  2.34k|      if (avail_out > 0)
  ------------------
  |  Branch (651:11): [True: 2.03k, False: 317]
  ------------------
  652|  2.03k|         *output_size_ptr -= avail_out;
  653|       |
  654|  2.34k|      if (avail_in > 0)
  ------------------
  |  Branch (654:11): [True: 1.22k, False: 1.12k]
  ------------------
  655|  1.22k|         *input_size_ptr -= avail_in;
  656|       |
  657|       |      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */
  658|  2.34k|      png_zstream_error(png_ptr, ret);
  ------------------
  |  |    4|  2.34k|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  659|  2.34k|      return ret;
  660|  2.34k|   }
  661|       |
  662|      0|   else
  663|      0|   {
  664|       |      /* This is a bad internal error.  The recovery assigns to the zstream msg
  665|       |       * pointer, which is not owned by the caller, but this is safe; it's only
  666|       |       * used on errors!
  667|       |       */
  668|      0|      png_ptr->zstream.msg = PNGZ_MSG_CAST("zstream unclaimed");
  ------------------
  |  |   40|      0|#  define PNGZ_MSG_CAST(s) (s)
  ------------------
  669|      0|      return Z_STREAM_ERROR;
  670|      0|   }
  671|  2.34k|}
pngrutil.c:png_handle_mDCV:
 1962|    562|{
 1963|    562|   png_xy chromaticities;
 1964|    562|   png_byte buf[24];
 1965|       |
 1966|    562|   png_debug(1, "in png_handle_mDCV");
  ------------------
  |  |  148|    562|#  define png_debug(l, m) ((void)0)
  ------------------
 1967|       |
 1968|    562|   png_crc_read(png_ptr, buf, 24);
  ------------------
  |  |   24|    562|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1969|       |
 1970|    562|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    562|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1970:8): [True: 347, False: 215]
  ------------------
 1971|    347|      return handled_error;
 1972|       |
 1973|       |   /* The error checking happens here, this puts it in just one place.  The
 1974|       |    * odd /50000 scaling factor makes it more difficult but the (x.y) values are
 1975|       |    * only two bytes so a <<1 is safe.
 1976|       |    *
 1977|       |    * WARNING: the PNG specification defines the cHRM chunk to **start** with
 1978|       |    * the white point (x,y).  The W3C PNG v3 specification puts the white point
 1979|       |    * **after* R,G,B.  The x,y values in mDCV are also scaled by 50,000 and
 1980|       |    * stored in just two bytes, whereas those in cHRM are scaled by 100,000 and
 1981|       |    * stored in four bytes.  This is very, very confusing.  These APIs remove
 1982|       |    * the confusion by copying the existing, well established, API.
 1983|       |    */
 1984|    215|   chromaticities.redx   = png_get_uint_16(buf+ 0U) << 1; /* red x */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1985|    215|   chromaticities.redy   = png_get_uint_16(buf+ 2U) << 1; /* red y */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1986|    215|   chromaticities.greenx = png_get_uint_16(buf+ 4U) << 1; /* green x */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1987|    215|   chromaticities.greeny = png_get_uint_16(buf+ 6U) << 1; /* green y */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1988|    215|   chromaticities.bluex  = png_get_uint_16(buf+ 8U) << 1; /* blue x */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1989|    215|   chromaticities.bluey  = png_get_uint_16(buf+10U) << 1; /* blue y */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1990|    215|   chromaticities.whitex = png_get_uint_16(buf+12U) << 1; /* white x */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1991|    215|   chromaticities.whitey = png_get_uint_16(buf+14U) << 1; /* white y */
  ------------------
  |  |  320|    215|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    215|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    215|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    215|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    215|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1992|       |
 1993|    215|   png_set_mDCV_fixed(png_ptr, info_ptr,
  ------------------
  |  |  406|    215|#define png_set_mDCV_fixed OSS_FUZZ_png_set_mDCV_fixed
  ------------------
 1994|    215|         chromaticities.whitex, chromaticities.whitey,
 1995|    215|         chromaticities.redx, chromaticities.redy,
 1996|    215|         chromaticities.greenx, chromaticities.greeny,
 1997|    215|         chromaticities.bluex, chromaticities.bluey,
 1998|    215|         png_get_uint_32(buf+16U), /* peak luminance */
  ------------------
  |  |  322|    215|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    215|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    215|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    215|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    215|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    215|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1999|    215|         png_get_uint_32(buf+20U));/* minimum perceivable luminance */
  ------------------
  |  |  322|    215|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|    215|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|    215|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|    215|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|    215|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|    215|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2000|       |
 2001|       |   /* We only use 'chromaticities' for RGB to gray */
 2002|    215|#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 2003|    215|      png_ptr->chromaticities = chromaticities;
 2004|    215|#  endif /* READ_RGB_TO_GRAY */
 2005|       |
 2006|    215|   return handled_ok;
 2007|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 2008|      0|}
pngrutil.c:png_handle_oFFs:
 2130|    301|{
 2131|    301|   png_byte buf[9];
 2132|    301|   png_int_32 offset_x, offset_y;
 2133|    301|   int unit_type;
 2134|       |
 2135|    301|   png_debug(1, "in png_handle_oFFs");
  ------------------
  |  |  148|    301|#  define png_debug(l, m) ((void)0)
  ------------------
 2136|       |
 2137|    301|   png_crc_read(png_ptr, buf, 9);
  ------------------
  |  |   24|    301|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2138|       |
 2139|    301|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    301|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2139:8): [True: 50, False: 251]
  ------------------
 2140|     50|      return handled_error;
 2141|       |
 2142|    251|   offset_x = png_get_int_32(buf);
  ------------------
  |  |  288|    251|#define png_get_int_32 OSS_FUZZ_png_get_int_32
  |  |  ------------------
  |  |  |  |  464|    251|#define OSS_FUZZ_png_get_int_32(buf) PNG_get_int_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2694|    251|   ((png_int_32)((*(buf) & 0x80) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2694:18): [True: 232, False: 19]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2695|    251|    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|    232|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|    232|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|    232|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|    232|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|    232|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|    232|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2696|    251|    : (png_int_32)png_get_uint_32(buf)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|     19|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|     19|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|     19|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|     19|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|     19|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|     19|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2143|    251|   offset_y = png_get_int_32(buf + 4);
  ------------------
  |  |  288|    251|#define png_get_int_32 OSS_FUZZ_png_get_int_32
  |  |  ------------------
  |  |  |  |  464|    251|#define OSS_FUZZ_png_get_int_32(buf) PNG_get_int_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2694|    251|   ((png_int_32)((*(buf) & 0x80) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2694:18): [True: 4, False: 247]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2695|    251|    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|      4|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|      4|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|      4|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|      4|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|      4|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|      4|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2696|    251|    : (png_int_32)png_get_uint_32(buf)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|    247|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|    247|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|    247|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|    247|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|    247|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|    247|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2144|    251|   unit_type = buf[8];
 2145|    251|   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
  ------------------
  |  |  408|    251|#define png_set_oFFs OSS_FUZZ_png_set_oFFs
  ------------------
 2146|    251|   return handled_ok;
 2147|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 2148|      0|}
pngrutil.c:png_handle_pCAL:
 2157|  1.53k|{
 2158|  1.53k|   png_int_32 X0, X1;
 2159|  1.53k|   png_byte type, nparams;
 2160|  1.53k|   png_bytep buffer, buf, units, endptr;
 2161|  1.53k|   png_charpp params;
 2162|  1.53k|   int i;
 2163|       |
 2164|  1.53k|   png_debug(1, "in png_handle_pCAL");
  ------------------
  |  |  148|  1.53k|#  define png_debug(l, m) ((void)0)
  ------------------
 2165|  1.53k|   png_debug1(2, "Allocating and reading pCAL chunk data (%u bytes)",
  ------------------
  |  |  151|  1.53k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 2166|  1.53k|       length + 1);
 2167|       |
 2168|  1.53k|   buffer = png_read_buffer(png_ptr, length+1);
 2169|       |
 2170|  1.53k|   if (buffer == NULL)
  ------------------
  |  Branch (2170:8): [True: 1, False: 1.53k]
  ------------------
 2171|      1|   {
 2172|      1|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2173|      1|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2174|      1|      return handled_error;
 2175|      1|   }
 2176|       |
 2177|  1.53k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  1.53k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2178|       |
 2179|  1.53k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  1.53k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2179:8): [True: 404, False: 1.12k]
  ------------------
 2180|    404|      return handled_error;
 2181|       |
 2182|  1.12k|   buffer[length] = 0; /* Null terminate the last string */
 2183|       |
 2184|  1.12k|   png_debug(3, "Finding end of pCAL purpose string");
  ------------------
  |  |  148|  1.12k|#  define png_debug(l, m) ((void)0)
  ------------------
 2185|  13.5k|   for (buf = buffer; *buf; buf++)
  ------------------
  |  Branch (2185:23): [True: 12.4k, False: 1.12k]
  ------------------
 2186|  12.4k|      /* Empty loop */ ;
 2187|       |
 2188|  1.12k|   endptr = buffer + length;
 2189|       |
 2190|       |   /* We need to have at least 12 bytes after the purpose string
 2191|       |    * in order to get the parameter information.
 2192|       |    */
 2193|  1.12k|   if (endptr - buf <= 12)
  ------------------
  |  Branch (2193:8): [True: 20, False: 1.10k]
  ------------------
 2194|     20|   {
 2195|     20|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     20|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2196|     20|      return handled_error;
 2197|     20|   }
 2198|       |
 2199|  1.10k|   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
  ------------------
  |  |  148|  1.10k|#  define png_debug(l, m) ((void)0)
  ------------------
 2200|  1.10k|   X0 = png_get_int_32((png_bytep)buf+1);
  ------------------
  |  |  288|  1.10k|#define png_get_int_32 OSS_FUZZ_png_get_int_32
  |  |  ------------------
  |  |  |  |  464|  1.10k|#define OSS_FUZZ_png_get_int_32(buf) PNG_get_int_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2694|  1.10k|   ((png_int_32)((*(buf) & 0x80) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2694:18): [True: 40, False: 1.06k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2695|  1.10k|    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|     40|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|     40|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|     40|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|     40|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|     40|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|     40|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2696|  1.10k|    : (png_int_32)png_get_uint_32(buf)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|  1.06k|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|  1.06k|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|  1.06k|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|  1.06k|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|  1.06k|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|  1.06k|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2201|  1.10k|   X1 = png_get_int_32((png_bytep)buf+5);
  ------------------
  |  |  288|  1.10k|#define png_get_int_32 OSS_FUZZ_png_get_int_32
  |  |  ------------------
  |  |  |  |  464|  1.10k|#define OSS_FUZZ_png_get_int_32(buf) PNG_get_int_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2694|  1.10k|   ((png_int_32)((*(buf) & 0x80) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2694:18): [True: 24, False: 1.08k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2695|  1.10k|    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|     24|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|     24|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|     24|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|     24|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|     24|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|     24|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2696|  1.10k|    : (png_int_32)png_get_uint_32(buf)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  322|  1.08k|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  462|  1.08k|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2680|  1.08k|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2681|  1.08k|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2682|  1.08k|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  |  |  |  |  |  |  | 2683|  1.08k|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2202|  1.10k|   type = buf[9];
 2203|  1.10k|   nparams = buf[10];
 2204|  1.10k|   units = buf + 11;
 2205|       |
 2206|  1.10k|   png_debug(3, "Checking pCAL equation type and number of parameters");
  ------------------
  |  |  148|  1.10k|#  define png_debug(l, m) ((void)0)
  ------------------
 2207|       |   /* Check that we have the right number of parameters for known
 2208|       |    * equation types.
 2209|       |    */
 2210|  1.10k|   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
  ------------------
  |  |  695|  2.21k|#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
  ------------------
  |  Branch (2210:9): [True: 853, False: 256]
  |  Branch (2210:40): [True: 561, False: 292]
  ------------------
 2211|  1.10k|       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
  ------------------
  |  |  696|  1.08k|#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
  ------------------
  |  Branch (2211:9): [True: 29, False: 515]
  |  Branch (2211:40): [True: 19, False: 10]
  ------------------
 2212|  1.10k|       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
  ------------------
  |  |  697|  1.05k|#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
  ------------------
  |  Branch (2212:9): [True: 33, False: 492]
  |  Branch (2212:43): [True: 23, False: 10]
  ------------------
 2213|  1.10k|       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
  ------------------
  |  |  698|  1.00k|#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
  ------------------
  |  Branch (2213:9): [True: 19, False: 483]
  |  Branch (2213:44): [True: 18, False: 1]
  ------------------
 2214|    621|   {
 2215|    621|      png_chunk_benign_error(png_ptr, "invalid parameter count");
  ------------------
  |  |  238|    621|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2216|    621|      return handled_error;
 2217|    621|   }
 2218|       |
 2219|    488|   else if (type >= PNG_EQUATION_LAST)
  ------------------
  |  |  699|    488|#define PNG_EQUATION_LAST         4 /* Not a valid value */
  ------------------
  |  Branch (2219:13): [True: 171, False: 317]
  ------------------
 2220|    171|   {
 2221|    171|      png_chunk_benign_error(png_ptr, "unrecognized equation type");
  ------------------
  |  |  238|    171|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2222|    171|   }
 2223|       |
 2224|  5.57k|   for (buf = units; *buf; buf++)
  ------------------
  |  Branch (2224:22): [True: 5.08k, False: 488]
  ------------------
 2225|  5.08k|      /* Empty loop to move past the units string. */ ;
 2226|       |
 2227|    488|   png_debug(3, "Allocating pCAL parameters array");
  ------------------
  |  |  148|    488|#  define png_debug(l, m) ((void)0)
  ------------------
 2228|       |
 2229|    488|   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
  ------------------
  |  |  511|    488|#  define png_voidcast(type, value) (value)
  ------------------
 2230|    488|       nparams * (sizeof (png_charp))));
 2231|       |
 2232|    488|   if (params == NULL)
  ------------------
  |  Branch (2232:8): [True: 0, False: 488]
  ------------------
 2233|      0|   {
 2234|      0|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2235|      0|      return handled_error;
 2236|      0|   }
 2237|       |
 2238|       |   /* Get pointers to the start of each parameter string. */
 2239|  2.12k|   for (i = 0; i < nparams; i++)
  ------------------
  |  Branch (2239:16): [True: 1.89k, False: 230]
  ------------------
 2240|  1.89k|   {
 2241|  1.89k|      buf++; /* Skip the null string terminator from previous parameter. */
 2242|       |
 2243|  1.89k|      png_debug1(3, "Reading pCAL parameter %d", i);
  ------------------
  |  |  151|  1.89k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 2244|       |
 2245|  10.0k|      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)
  ------------------
  |  Branch (2245:40): [True: 9.74k, False: 258]
  |  Branch (2245:57): [True: 8.10k, False: 1.63k]
  ------------------
 2246|  8.10k|         /* Empty loop to move past each parameter string */ ;
 2247|       |
 2248|       |      /* Make sure we haven't run out of data yet */
 2249|  1.89k|      if (buf > endptr)
  ------------------
  |  Branch (2249:11): [True: 258, False: 1.63k]
  ------------------
 2250|    258|      {
 2251|    258|         png_free(png_ptr, params);
  ------------------
  |  |  253|    258|#define png_free OSS_FUZZ_png_free
  ------------------
 2252|    258|         png_chunk_benign_error(png_ptr, "invalid data");
  ------------------
  |  |  238|    258|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2253|    258|         return handled_error;
 2254|    258|      }
 2255|  1.89k|   }
 2256|       |
 2257|    230|   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,
  ------------------
  |  |  410|    230|#define png_set_pCAL OSS_FUZZ_png_set_pCAL
  ------------------
 2258|    230|       (png_charp)units, params);
 2259|       |
 2260|       |   /* TODO: BUG: png_set_pCAL calls png_chunk_report which, in this case, calls
 2261|       |    * png_benign_error and that can error out.
 2262|       |    *
 2263|       |    * png_read_buffer needs to be allocated with space for both nparams and the
 2264|       |    * parameter strings.  Not hard to do.
 2265|       |    */
 2266|    230|   png_free(png_ptr, params);
  ------------------
  |  |  253|    230|#define png_free OSS_FUZZ_png_free
  ------------------
 2267|    230|   return handled_ok;
 2268|    488|}
pngrutil.c:png_handle_pHYs:
 2104|    332|{
 2105|    332|   png_byte buf[9];
 2106|    332|   png_uint_32 res_x, res_y;
 2107|    332|   int unit_type;
 2108|       |
 2109|    332|   png_debug(1, "in png_handle_pHYs");
  ------------------
  |  |  148|    332|#  define png_debug(l, m) ((void)0)
  ------------------
 2110|       |
 2111|    332|   png_crc_read(png_ptr, buf, 9);
  ------------------
  |  |   24|    332|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2112|       |
 2113|    332|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    332|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2113:8): [True: 251, False: 81]
  ------------------
 2114|    251|      return handled_error;
 2115|       |
 2116|     81|   res_x = png_get_uint_32(buf);
  ------------------
  |  |  322|     81|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     81|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     81|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     81|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     81|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     81|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2117|     81|   res_y = png_get_uint_32(buf + 4);
  ------------------
  |  |  322|     81|#define png_get_uint_32 OSS_FUZZ_png_get_uint_32
  |  |  ------------------
  |  |  |  |  462|     81|#define OSS_FUZZ_png_get_uint_32(buf) PNG_get_uint_32(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2680|     81|   (((png_uint_32)(*(buf)) << 24) + \
  |  |  |  |  |  | 2681|     81|    ((png_uint_32)(*((buf) + 1)) << 16) + \
  |  |  |  |  |  | 2682|     81|    ((png_uint_32)(*((buf) + 2)) << 8) + \
  |  |  |  |  |  | 2683|     81|    ((png_uint_32)(*((buf) + 3))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2118|     81|   unit_type = buf[8];
 2119|     81|   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
  ------------------
  |  |  411|     81|#define png_set_pHYs OSS_FUZZ_png_set_pHYs
  ------------------
 2120|     81|   return handled_ok;
 2121|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 2122|      0|}
pngrutil.c:png_handle_sBIT:
 1155|    686|{
 1156|    686|   unsigned int truelen, i;
 1157|    686|   png_byte sample_depth;
 1158|    686|   png_byte buf[4];
 1159|       |
 1160|    686|   png_debug(1, "in png_handle_sBIT");
  ------------------
  |  |  148|    686|#  define png_debug(l, m) ((void)0)
  ------------------
 1161|       |
 1162|    686|   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|    686|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    686|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    686|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1162:8): [True: 75, False: 611]
  ------------------
 1163|     75|   {
 1164|     75|      truelen = 3;
 1165|     75|      sample_depth = 8;
 1166|     75|   }
 1167|       |
 1168|    611|   else
 1169|    611|   {
 1170|    611|      truelen = png_ptr->channels;
 1171|    611|      sample_depth = png_ptr->bit_depth;
 1172|    611|   }
 1173|       |
 1174|    686|   if (length != truelen)
  ------------------
  |  Branch (1174:8): [True: 170, False: 516]
  ------------------
 1175|    170|   {
 1176|    170|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|    170|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1177|    170|      png_chunk_benign_error(png_ptr, "bad length");
  ------------------
  |  |  238|    170|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1178|    170|      return handled_error;
 1179|    170|   }
 1180|       |
 1181|    516|   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;
 1182|    516|   png_crc_read(png_ptr, buf, truelen);
  ------------------
  |  |   24|    516|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1183|       |
 1184|    516|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    516|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1184:8): [True: 160, False: 356]
  ------------------
 1185|    160|      return handled_error;
 1186|       |
 1187|  1.57k|   for (i=0; i<truelen; ++i)
  ------------------
  |  Branch (1187:14): [True: 1.31k, False: 259]
  ------------------
 1188|  1.31k|   {
 1189|  1.31k|      if (buf[i] == 0 || buf[i] > sample_depth)
  ------------------
  |  Branch (1189:11): [True: 23, False: 1.29k]
  |  Branch (1189:26): [True: 74, False: 1.22k]
  ------------------
 1190|     97|      {
 1191|     97|         png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     97|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1192|     97|         return handled_error;
 1193|     97|      }
 1194|  1.31k|   }
 1195|       |
 1196|    259|   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|    259|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (1196:8): [True: 258, False: 1]
  ------------------
 1197|    258|   {
 1198|    258|      png_ptr->sig_bit.red = buf[0];
 1199|    258|      png_ptr->sig_bit.green = buf[1];
 1200|    258|      png_ptr->sig_bit.blue = buf[2];
 1201|    258|      png_ptr->sig_bit.alpha = buf[3];
 1202|    258|   }
 1203|       |
 1204|      1|   else /* grayscale */
 1205|      1|   {
 1206|      1|      png_ptr->sig_bit.gray = buf[0];
 1207|      1|      png_ptr->sig_bit.red = buf[0];
 1208|      1|      png_ptr->sig_bit.green = buf[0];
 1209|      1|      png_ptr->sig_bit.blue = buf[0];
 1210|      1|      png_ptr->sig_bit.alpha = buf[1];
 1211|      1|   }
 1212|       |
 1213|    259|   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
  ------------------
  |  |  424|    259|#define png_set_sBIT OSS_FUZZ_png_set_sBIT
  ------------------
 1214|    259|   return handled_ok;
 1215|    356|}
pngrutil.c:png_handle_sCAL:
 2277|  3.29k|{
 2278|  3.29k|   png_bytep buffer;
 2279|  3.29k|   size_t i;
 2280|  3.29k|   int state;
 2281|       |
 2282|  3.29k|   png_debug(1, "in png_handle_sCAL");
  ------------------
  |  |  148|  3.29k|#  define png_debug(l, m) ((void)0)
  ------------------
 2283|  3.29k|   png_debug1(2, "Allocating and reading sCAL chunk data (%u bytes)",
  ------------------
  |  |  151|  3.29k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 2284|  3.29k|       length + 1);
 2285|       |
 2286|  3.29k|   buffer = png_read_buffer(png_ptr, length+1);
 2287|       |
 2288|  3.29k|   if (buffer == NULL)
  ------------------
  |  Branch (2288:8): [True: 1, False: 3.29k]
  ------------------
 2289|      1|   {
 2290|      1|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2291|      1|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2292|      1|      return handled_error;
 2293|      1|   }
 2294|       |
 2295|  3.29k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  3.29k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2296|  3.29k|   buffer[length] = 0; /* Null terminate the last string */
 2297|       |
 2298|  3.29k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  3.29k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2298:8): [True: 380, False: 2.91k]
  ------------------
 2299|    380|      return handled_error;
 2300|       |
 2301|       |   /* Validate the unit. */
 2302|  2.91k|   if (buffer[0] != 1 && buffer[0] != 2)
  ------------------
  |  Branch (2302:8): [True: 105, False: 2.80k]
  |  Branch (2302:26): [True: 70, False: 35]
  ------------------
 2303|     70|   {
 2304|     70|      png_chunk_benign_error(png_ptr, "invalid unit");
  ------------------
  |  |  238|     70|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2305|     70|      return handled_error;
 2306|     70|   }
 2307|       |
 2308|       |   /* Validate the ASCII numbers, need two ASCII numbers separated by
 2309|       |    * a '\0' and they need to fit exactly in the chunk data.
 2310|       |    */
 2311|  2.84k|   i = 1;
 2312|  2.84k|   state = 0;
 2313|       |
 2314|  2.84k|   if (png_check_fp_number((png_const_charp)buffer, length, &state, &i) == 0 ||
  ------------------
  |  |   86|  2.84k|#define png_check_fp_number OSS_FUZZ_png_check_fp_number
  ------------------
  |  Branch (2314:8): [True: 277, False: 2.56k]
  ------------------
 2315|  2.84k|       i >= length || buffer[i++] != 0)
  ------------------
  |  Branch (2315:8): [True: 15, False: 2.55k]
  |  Branch (2315:23): [True: 1.17k, False: 1.37k]
  ------------------
 2316|  1.46k|      png_chunk_benign_error(png_ptr, "bad width format");
  ------------------
  |  |  238|  1.46k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2317|       |
 2318|  1.37k|   else if (PNG_FP_IS_POSITIVE(state) == 0)
  ------------------
  |  | 1931|  1.37k|#define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
  |  |  ------------------
  |  |  |  | 1925|  1.37k|#define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1897|  1.37k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1905|  1.37k|#define PNG_FP_NEGATIVE 128  /* A negative number, including "-0" */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1906|  1.37k|#define PNG_FP_NONZERO  256  /* A non-zero value */
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
  |  |  ------------------
  |  |  |  | 1927|  1.37k|#define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1897|  1.37k|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1906|  1.37k|#define PNG_FP_NONZERO  256  /* A non-zero value */
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2318:13): [True: 18, False: 1.36k]
  ------------------
 2319|     18|      png_chunk_benign_error(png_ptr, "non-positive width");
  ------------------
  |  |  238|     18|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2320|       |
 2321|  1.36k|   else
 2322|  1.36k|   {
 2323|  1.36k|      size_t heighti = i;
 2324|       |
 2325|  1.36k|      state = 0;
 2326|  1.36k|      if (png_check_fp_number((png_const_charp)buffer, length,
  ------------------
  |  |   86|  1.36k|#define png_check_fp_number OSS_FUZZ_png_check_fp_number
  ------------------
  |  Branch (2326:11): [True: 744, False: 617]
  ------------------
 2327|  1.36k|          &state, &i) == 0 || i != length)
  ------------------
  |  Branch (2327:31): [True: 496, False: 121]
  ------------------
 2328|  1.23k|         png_chunk_benign_error(png_ptr, "bad height format");
  ------------------
  |  |  238|  1.23k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2329|       |
 2330|    125|      else if (PNG_FP_IS_POSITIVE(state) == 0)
  ------------------
  |  | 1931|    125|#define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
  |  |  ------------------
  |  |  |  | 1925|    125|#define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1897|    125|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1905|    125|#define PNG_FP_NEGATIVE 128  /* A negative number, including "-0" */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1906|    125|#define PNG_FP_NONZERO  256  /* A non-zero value */
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
  |  |  ------------------
  |  |  |  | 1927|    125|#define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1897|    125|#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
  |  |  |  |  ------------------
  |  |  |  |               #define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
  |  |  |  |  ------------------
  |  |  |  |  |  | 1906|    125|#define PNG_FP_NONZERO  256  /* A non-zero value */
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2330:16): [True: 10, False: 115]
  ------------------
 2331|     10|         png_chunk_benign_error(png_ptr, "non-positive height");
  ------------------
  |  |  238|     10|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2332|       |
 2333|    115|      else
 2334|    115|      {
 2335|       |         /* This is the (only) success case. */
 2336|    115|         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],
  ------------------
  |  |  427|    115|#define png_set_sCAL_s OSS_FUZZ_png_set_sCAL_s
  ------------------
 2337|    115|             (png_charp)buffer+1, (png_charp)buffer+heighti);
 2338|    115|         return handled_ok;
 2339|    115|      }
 2340|  1.36k|   }
 2341|       |
 2342|  2.72k|   return handled_error;
 2343|  2.84k|}
pngrutil.c:png_handle_sPLT:
 1566|  1.18k|{
 1567|  1.18k|   png_bytep entry_start, buffer;
 1568|  1.18k|   png_sPLT_t new_palette;
 1569|  1.18k|   png_sPLT_entryp pp;
 1570|  1.18k|   png_uint_32 data_length;
 1571|  1.18k|   int entry_size, i;
 1572|  1.18k|   png_uint_32 skip = 0;
 1573|  1.18k|   png_uint_32 dl;
 1574|  1.18k|   size_t max_dl;
 1575|       |
 1576|  1.18k|   png_debug(1, "in png_handle_sPLT");
  ------------------
  |  |  148|  1.18k|#  define png_debug(l, m) ((void)0)
  ------------------
 1577|       |
 1578|  1.18k|#ifdef PNG_USER_LIMITS_SUPPORTED
 1579|  1.18k|   if (png_ptr->user_chunk_cache_max != 0)
  ------------------
  |  Branch (1579:8): [True: 1.18k, False: 0]
  ------------------
 1580|  1.18k|   {
 1581|  1.18k|      if (png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (1581:11): [True: 0, False: 1.18k]
  ------------------
 1582|      0|      {
 1583|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1584|      0|         return handled_error;
 1585|      0|      }
 1586|       |
 1587|  1.18k|      if (--png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (1587:11): [True: 0, False: 1.18k]
  ------------------
 1588|      0|      {
 1589|      0|         png_warning(png_ptr, "No space in chunk cache for sPLT");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1590|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1591|      0|         return handled_error;
 1592|      0|      }
 1593|  1.18k|   }
 1594|  1.18k|#endif
 1595|       |
 1596|  1.18k|   buffer = png_read_buffer(png_ptr, length+1);
 1597|  1.18k|   if (buffer == NULL)
  ------------------
  |  Branch (1597:8): [True: 1, False: 1.18k]
  ------------------
 1598|      1|   {
 1599|      1|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1600|      1|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1601|      1|      return handled_error;
 1602|      1|   }
 1603|       |
 1604|       |
 1605|       |   /* WARNING: this may break if size_t is less than 32 bits; it is assumed
 1606|       |    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a
 1607|       |    * potential breakage point if the types in pngconf.h aren't exactly right.
 1608|       |    */
 1609|  1.18k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  1.18k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1610|       |
 1611|  1.18k|   if (png_crc_finish(png_ptr, skip) != 0)
  ------------------
  |  |   25|  1.18k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1611:8): [True: 138, False: 1.04k]
  ------------------
 1612|    138|      return handled_error;
 1613|       |
 1614|  1.04k|   buffer[length] = 0;
 1615|       |
 1616|  6.54k|   for (entry_start = buffer; *entry_start; entry_start++)
  ------------------
  |  Branch (1616:31): [True: 5.50k, False: 1.04k]
  ------------------
 1617|  5.50k|      /* Empty loop to find end of name */ ;
 1618|       |
 1619|  1.04k|   ++entry_start;
 1620|       |
 1621|       |   /* A sample depth should follow the separator, and we should be on it  */
 1622|  1.04k|   if (length < 2U || entry_start > buffer + (length - 2U))
  ------------------
  |  Branch (1622:8): [True: 7, False: 1.04k]
  |  Branch (1622:23): [True: 19, False: 1.02k]
  ------------------
 1623|     19|   {
 1624|     19|      png_warning(png_ptr, "malformed sPLT chunk");
  ------------------
  |  |  450|     19|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1625|     19|      return handled_error;
 1626|     19|   }
 1627|       |
 1628|  1.02k|   new_palette.depth = *entry_start++;
 1629|  1.02k|   entry_size = (new_palette.depth == 8 ? 6 : 10);
  ------------------
  |  Branch (1629:18): [True: 10, False: 1.01k]
  ------------------
 1630|       |   /* This must fit in a png_uint_32 because it is derived from the original
 1631|       |    * chunk data length.
 1632|       |    */
 1633|  1.02k|   data_length = length - (png_uint_32)(entry_start - buffer);
 1634|       |
 1635|       |   /* Integrity-check the data length */
 1636|  1.02k|   if ((data_length % (unsigned int)entry_size) != 0)
  ------------------
  |  Branch (1636:8): [True: 361, False: 667]
  ------------------
 1637|    361|   {
 1638|    361|      png_warning(png_ptr, "sPLT chunk has bad length");
  ------------------
  |  |  450|    361|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1639|    361|      return handled_error;
 1640|    361|   }
 1641|       |
 1642|    667|   dl = (png_uint_32)(data_length / (unsigned int)entry_size);
 1643|    667|   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));
  ------------------
  |  |  649|    667|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
 1644|       |
 1645|    667|   if (dl > max_dl)
  ------------------
  |  Branch (1645:8): [True: 0, False: 667]
  ------------------
 1646|      0|   {
 1647|      0|      png_warning(png_ptr, "sPLT chunk too long");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1648|      0|      return handled_error;
 1649|      0|   }
 1650|       |
 1651|    667|   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);
 1652|       |
 1653|    667|   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
  ------------------
  |  |  349|    667|#define png_malloc_warn OSS_FUZZ_png_malloc_warn
  ------------------
 1654|    667|       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));
 1655|       |
 1656|    667|   if (new_palette.entries == NULL)
  ------------------
  |  Branch (1656:8): [True: 0, False: 667]
  ------------------
 1657|      0|   {
 1658|      0|      png_warning(png_ptr, "sPLT chunk requires too much memory");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1659|      0|      return handled_error;
 1660|      0|   }
 1661|       |
 1662|  8.27k|   for (i = 0; i < new_palette.nentries; i++)
  ------------------
  |  Branch (1662:16): [True: 7.61k, False: 667]
  ------------------
 1663|  7.61k|   {
 1664|  7.61k|      pp = new_palette.entries + i;
 1665|       |
 1666|  7.61k|      if (new_palette.depth == 8)
  ------------------
  |  Branch (1666:11): [True: 274, False: 7.33k]
  ------------------
 1667|    274|      {
 1668|    274|         pp->red = *entry_start++;
 1669|    274|         pp->green = *entry_start++;
 1670|    274|         pp->blue = *entry_start++;
 1671|    274|         pp->alpha = *entry_start++;
 1672|    274|      }
 1673|       |
 1674|  7.33k|      else
 1675|  7.33k|      {
 1676|  7.33k|         pp->red   = png_get_uint_16(entry_start); entry_start += 2;
  ------------------
  |  |  320|  7.33k|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|  7.33k|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|  7.33k|   ((png_uint_16) \
  |  |  |  |  |  | 2690|  7.33k|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|  7.33k|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1677|  7.33k|         pp->green = png_get_uint_16(entry_start); entry_start += 2;
  ------------------
  |  |  320|  7.33k|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|  7.33k|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|  7.33k|   ((png_uint_16) \
  |  |  |  |  |  | 2690|  7.33k|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|  7.33k|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1678|  7.33k|         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
  ------------------
  |  |  320|  7.33k|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|  7.33k|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|  7.33k|   ((png_uint_16) \
  |  |  |  |  |  | 2690|  7.33k|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|  7.33k|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1679|  7.33k|         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
  ------------------
  |  |  320|  7.33k|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|  7.33k|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|  7.33k|   ((png_uint_16) \
  |  |  |  |  |  | 2690|  7.33k|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|  7.33k|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1680|  7.33k|      }
 1681|       |
 1682|  7.61k|      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
  ------------------
  |  |  320|  7.61k|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|  7.61k|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|  7.61k|   ((png_uint_16) \
  |  |  |  |  |  | 2690|  7.61k|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|  7.61k|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1683|  7.61k|   }
 1684|       |
 1685|       |   /* Discard all chunk data except the name and stash that */
 1686|    667|   new_palette.name = (png_charp)buffer;
 1687|       |
 1688|    667|   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);
  ------------------
  |  |  428|    667|#define png_set_sPLT OSS_FUZZ_png_set_sPLT
  ------------------
 1689|       |
 1690|    667|   png_free(png_ptr, new_palette.entries);
  ------------------
  |  |  253|    667|#define png_free OSS_FUZZ_png_free
  ------------------
 1691|    667|   return handled_ok;
 1692|    667|}
pngrutil.c:png_handle_sRGB:
 1296|    845|{
 1297|    845|   png_byte intent;
 1298|       |
 1299|    845|   png_debug(1, "in png_handle_sRGB");
  ------------------
  |  |  148|    845|#  define png_debug(l, m) ((void)0)
  ------------------
 1300|       |
 1301|    845|   png_crc_read(png_ptr, &intent, 1);
  ------------------
  |  |   24|    845|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1302|       |
 1303|    845|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    845|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1303:8): [True: 225, False: 620]
  ------------------
 1304|    225|      return handled_error;
 1305|       |
 1306|       |   /* This checks the range of the "rendering intent" because it is specified in
 1307|       |    * the PNG spec itself; the "reserved" values will result in the chunk not
 1308|       |    * being accepted, just as they do with the various "reserved" values in
 1309|       |    * IHDR.
 1310|       |    */
 1311|    620|   if (intent > 3/*PNGv3 spec*/)
  ------------------
  |  Branch (1311:8): [True: 316, False: 304]
  ------------------
 1312|    316|   {
 1313|    316|      png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|    316|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1314|    316|      return handled_error;
 1315|    316|   }
 1316|       |
 1317|    304|   png_set_sRGB(png_ptr, info_ptr, intent);
  ------------------
  |  |  429|    304|#define png_set_sRGB OSS_FUZZ_png_set_sRGB
  ------------------
 1318|       |   /* NOTE: png_struct::chromaticities is not set here because the RGB to gray
 1319|       |    * coefficients are known without a need for the chromaticities.
 1320|       |    */
 1321|       |
 1322|    304|#ifdef PNG_READ_GAMMA_SUPPORTED
 1323|       |      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  iCCP is
 1324|       |       * not supported by libpng so the only requirement is to check for cICP
 1325|       |       * setting the gamma (this is NYI, but this check is safe.)
 1326|       |       */
 1327|    304|      if (!png_has_chunk(png_ptr, cICP) || png_ptr->chunk_gamma == 0)
  ------------------
  |  |  194|    304|      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)
  |  |  ------------------
  |  |  |  |  115|    608|   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    304|#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1327:11): [True: 139, False: 165]
  |  Branch (1327:44): [True: 129, False: 36]
  ------------------
 1328|    268|         png_ptr->chunk_gamma = PNG_GAMMA_sRGB_INVERSE;
  ------------------
  |  |  976|    268|#define PNG_GAMMA_sRGB_INVERSE 45455
  ------------------
 1329|    304|#endif /*READ_GAMMA*/
 1330|       |
 1331|    304|   return handled_ok;
 1332|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 1333|      0|}
pngrutil.c:png_handle_tEXt:
 2388|  2.92k|{
 2389|  2.92k|   png_text  text_info;
 2390|  2.92k|   png_bytep buffer;
 2391|  2.92k|   png_charp key;
 2392|  2.92k|   png_charp text;
 2393|  2.92k|   png_uint_32 skip = 0;
 2394|       |
 2395|  2.92k|   png_debug(1, "in png_handle_tEXt");
  ------------------
  |  |  148|  2.92k|#  define png_debug(l, m) ((void)0)
  ------------------
 2396|       |
 2397|  2.92k|#ifdef PNG_USER_LIMITS_SUPPORTED
 2398|  2.92k|   if (png_ptr->user_chunk_cache_max != 0)
  ------------------
  |  Branch (2398:8): [True: 2.92k, False: 0]
  ------------------
 2399|  2.92k|   {
 2400|  2.92k|      if (png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2400:11): [True: 0, False: 2.92k]
  ------------------
 2401|      0|      {
 2402|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2403|      0|         return handled_error;
 2404|      0|      }
 2405|       |
 2406|  2.92k|      if (--png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2406:11): [True: 0, False: 2.92k]
  ------------------
 2407|      0|      {
 2408|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2409|      0|         png_chunk_benign_error(png_ptr, "no space in chunk cache");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2410|      0|         return handled_error;
 2411|      0|      }
 2412|  2.92k|   }
 2413|  2.92k|#endif
 2414|       |
 2415|       |   /* TODO: this doesn't work and shouldn't be necessary. */
 2416|  2.92k|   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|  2.92k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (2416:8): [True: 308, False: 2.61k]
  ------------------
 2417|    308|      png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|    308|#define PNG_AFTER_IDAT 0x08
  ------------------
 2418|       |
 2419|  2.92k|   buffer = png_read_buffer(png_ptr, length+1);
 2420|       |
 2421|  2.92k|   if (buffer == NULL)
  ------------------
  |  Branch (2421:8): [True: 1, False: 2.91k]
  ------------------
 2422|      1|   {
 2423|      1|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      1|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2424|      1|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      1|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2425|      1|      return handled_error;
 2426|      1|   }
 2427|       |
 2428|  2.91k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  2.91k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2429|       |
 2430|  2.91k|   if (png_crc_finish(png_ptr, skip) != 0)
  ------------------
  |  |   25|  2.91k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2430:8): [True: 518, False: 2.40k]
  ------------------
 2431|    518|      return handled_error;
 2432|       |
 2433|  2.40k|   key = (png_charp)buffer;
 2434|  2.40k|   key[length] = 0;
 2435|       |
 2436|  26.0k|   for (text = key; *text; text++)
  ------------------
  |  Branch (2436:21): [True: 23.6k, False: 2.40k]
  ------------------
 2437|  23.6k|      /* Empty loop to find end of key */ ;
 2438|       |
 2439|  2.40k|   if (text != key + length)
  ------------------
  |  Branch (2439:8): [True: 2.25k, False: 148]
  ------------------
 2440|  2.25k|      text++;
 2441|       |
 2442|  2.40k|   text_info.compression = PNG_TEXT_COMPRESSION_NONE;
  ------------------
  |  |  586|  2.40k|#define PNG_TEXT_COMPRESSION_NONE    -1
  ------------------
 2443|  2.40k|   text_info.key = key;
 2444|  2.40k|   text_info.lang = NULL;
 2445|  2.40k|   text_info.lang_key = NULL;
 2446|  2.40k|   text_info.itxt_length = 0;
 2447|  2.40k|   text_info.text = text;
 2448|  2.40k|   text_info.text_length = strlen(text);
 2449|       |
 2450|  2.40k|   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) == 0)
  ------------------
  |  |   31|  2.40k|#define png_set_text_2 OSS_FUZZ_png_set_text_2
  ------------------
  |  Branch (2450:8): [True: 2.39k, False: 7]
  ------------------
 2451|  2.39k|      return handled_ok;
 2452|       |
 2453|      7|   png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      7|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2454|      7|   return handled_error;
 2455|  2.40k|}
pngrutil.c:png_handle_tIME:
 2351|    290|{
 2352|    290|   png_byte buf[7];
 2353|    290|   png_time mod_time;
 2354|       |
 2355|    290|   png_debug(1, "in png_handle_tIME");
  ------------------
  |  |  148|    290|#  define png_debug(l, m) ((void)0)
  ------------------
 2356|       |
 2357|       |   /* TODO: what is this doing here?  It should be happened in pngread.c and
 2358|       |    * pngpread.c, although it could be moved to png_handle_chunk below and
 2359|       |    * thereby avoid some code duplication.
 2360|       |    */
 2361|    290|   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|    290|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (2361:8): [True: 1, False: 289]
  ------------------
 2362|      1|      png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|      1|#define PNG_AFTER_IDAT 0x08
  ------------------
 2363|       |
 2364|    290|   png_crc_read(png_ptr, buf, 7);
  ------------------
  |  |   24|    290|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2365|       |
 2366|    290|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    290|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2366:8): [True: 201, False: 89]
  ------------------
 2367|    201|      return handled_error;
 2368|       |
 2369|     89|   mod_time.second = buf[6];
 2370|     89|   mod_time.minute = buf[5];
 2371|     89|   mod_time.hour = buf[4];
 2372|     89|   mod_time.day = buf[3];
 2373|     89|   mod_time.month = buf[2];
 2374|     89|   mod_time.year = png_get_uint_16(buf);
  ------------------
  |  |  320|     89|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|     89|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|     89|   ((png_uint_16) \
  |  |  |  |  |  | 2690|     89|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|     89|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2375|       |
 2376|     89|   png_set_tIME(png_ptr, info_ptr, &mod_time);
  ------------------
  |  |  438|     89|#define png_set_tIME OSS_FUZZ_png_set_tIME
  ------------------
 2377|     89|   return handled_ok;
 2378|      0|   PNG_UNUSED(length)
  ------------------
  |  |  455|      0|#  define PNG_UNUSED(param) (void)param;
  ------------------
 2379|      0|}
pngrutil.c:png_handle_tRNS:
 1700|    931|{
 1701|    931|   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
 1702|       |
 1703|    931|   png_debug(1, "in png_handle_tRNS");
  ------------------
  |  |  148|    931|#  define png_debug(l, m) ((void)0)
  ------------------
 1704|       |
 1705|    931|   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
  ------------------
  |  |  666|    931|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (1705:8): [True: 371, False: 560]
  ------------------
 1706|    371|   {
 1707|    371|      png_byte buf[2];
 1708|       |
 1709|    371|      if (length != 2)
  ------------------
  |  Branch (1709:11): [True: 34, False: 337]
  ------------------
 1710|     34|      {
 1711|     34|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     34|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1712|     34|         png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     34|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1713|     34|         return handled_error;
 1714|     34|      }
 1715|       |
 1716|    337|      png_crc_read(png_ptr, buf, 2);
  ------------------
  |  |   24|    337|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1717|    337|      png_ptr->num_trans = 1;
 1718|    337|      png_ptr->trans_color.gray = png_get_uint_16(buf);
  ------------------
  |  |  320|    337|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    337|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    337|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    337|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    337|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1719|    337|   }
 1720|       |
 1721|    560|   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
  ------------------
  |  |  668|    560|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    560|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (1721:13): [True: 259, False: 301]
  ------------------
 1722|    259|   {
 1723|    259|      png_byte buf[6];
 1724|       |
 1725|    259|      if (length != 6)
  ------------------
  |  Branch (1725:11): [True: 67, False: 192]
  ------------------
 1726|     67|      {
 1727|     67|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     67|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1728|     67|         png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     67|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1729|     67|         return handled_error;
 1730|     67|      }
 1731|       |
 1732|    192|      png_crc_read(png_ptr, buf, length);
  ------------------
  |  |   24|    192|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1733|    192|      png_ptr->num_trans = 1;
 1734|    192|      png_ptr->trans_color.red = png_get_uint_16(buf);
  ------------------
  |  |  320|    192|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    192|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    192|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    192|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    192|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1735|    192|      png_ptr->trans_color.green = png_get_uint_16(buf + 2);
  ------------------
  |  |  320|    192|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    192|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    192|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    192|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    192|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1736|    192|      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);
  ------------------
  |  |  320|    192|#define png_get_uint_16 OSS_FUZZ_png_get_uint_16
  |  |  ------------------
  |  |  |  |  463|    192|#define OSS_FUZZ_png_get_uint_16(buf) PNG_get_uint_16(buf)
  |  |  |  |  ------------------
  |  |  |  |  |  | 2689|    192|   ((png_uint_16) \
  |  |  |  |  |  | 2690|    192|    (((unsigned int)(*(buf)) << 8) + \
  |  |  |  |  |  | 2691|    192|    ((unsigned int)(*((buf) + 1)))))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1737|    192|   }
 1738|       |
 1739|    301|   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|    301|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    301|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    301|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (1739:13): [True: 183, False: 118]
  ------------------
 1740|    183|   {
 1741|    183|      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)
  ------------------
  |  |  643|    183|#define PNG_HAVE_PLTE  0x02
  ------------------
  |  Branch (1741:11): [True: 66, False: 117]
  ------------------
 1742|     66|      {
 1743|     66|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     66|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1744|     66|         png_chunk_benign_error(png_ptr, "out of place");
  ------------------
  |  |  238|     66|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1745|     66|         return handled_error;
 1746|     66|      }
 1747|       |
 1748|    117|      if (length > (unsigned int) png_ptr->num_palette ||
  ------------------
  |  Branch (1748:11): [True: 10, False: 107]
  ------------------
 1749|    117|         length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||
  ------------------
  |  |  723|    224|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  |  Branch (1749:10): [True: 0, False: 107]
  ------------------
 1750|    117|         length == 0)
  ------------------
  |  Branch (1750:10): [True: 1, False: 106]
  ------------------
 1751|     11|      {
 1752|     11|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|     11|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1753|     11|         png_chunk_benign_error(png_ptr, "invalid");
  ------------------
  |  |  238|     11|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1754|     11|         return handled_error;
 1755|     11|      }
 1756|       |
 1757|    106|      png_crc_read(png_ptr, readbuf, length);
  ------------------
  |  |   24|    106|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 1758|    106|      png_ptr->num_trans = (png_uint_16)length;
 1759|    106|   }
 1760|       |
 1761|    118|   else
 1762|    118|   {
 1763|    118|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|    118|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 1764|    118|      png_chunk_benign_error(png_ptr, "invalid with alpha channel");
  ------------------
  |  |  238|    118|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 1765|    118|      return handled_error;
 1766|    118|   }
 1767|       |
 1768|    635|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|    635|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (1768:8): [True: 41, False: 594]
  ------------------
 1769|     41|   {
 1770|     41|      png_ptr->num_trans = 0;
 1771|     41|      return handled_error;
 1772|     41|   }
 1773|       |
 1774|       |   /* TODO: this is a horrible side effect in the palette case because the
 1775|       |    * png_struct ends up with a pointer to the tRNS buffer owned by the
 1776|       |    * png_info.  Fix this.
 1777|       |    */
 1778|    594|   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
  ------------------
  |  |  439|    594|#define png_set_tRNS OSS_FUZZ_png_set_tRNS
  ------------------
 1779|    594|       &(png_ptr->trans_color));
 1780|    594|   return handled_ok;
 1781|    635|}
pngrutil.c:png_handle_zTXt:
 2464|  1.81k|{
 2465|  1.81k|   png_const_charp errmsg = NULL;
 2466|  1.81k|   png_bytep       buffer;
 2467|  1.81k|   png_uint_32     keyword_length;
 2468|       |
 2469|  1.81k|   png_debug(1, "in png_handle_zTXt");
  ------------------
  |  |  148|  1.81k|#  define png_debug(l, m) ((void)0)
  ------------------
 2470|       |
 2471|  1.81k|#ifdef PNG_USER_LIMITS_SUPPORTED
 2472|  1.81k|   if (png_ptr->user_chunk_cache_max != 0)
  ------------------
  |  Branch (2472:8): [True: 1.81k, False: 0]
  ------------------
 2473|  1.81k|   {
 2474|  1.81k|      if (png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2474:11): [True: 0, False: 1.81k]
  ------------------
 2475|      0|      {
 2476|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2477|      0|         return handled_error;
 2478|      0|      }
 2479|       |
 2480|  1.81k|      if (--png_ptr->user_chunk_cache_max == 1)
  ------------------
  |  Branch (2480:11): [True: 0, False: 1.81k]
  ------------------
 2481|      0|      {
 2482|      0|         png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2483|      0|         png_chunk_benign_error(png_ptr, "no space in chunk cache");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2484|      0|         return handled_error;
 2485|      0|      }
 2486|  1.81k|   }
 2487|  1.81k|#endif
 2488|       |
 2489|       |   /* TODO: should not be necessary. */
 2490|  1.81k|   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
  ------------------
  |  |  618|  1.81k|#define PNG_HAVE_IDAT               0x04U
  ------------------
  |  Branch (2490:8): [True: 235, False: 1.57k]
  ------------------
 2491|    235|      png_ptr->mode |= PNG_AFTER_IDAT;
  ------------------
  |  |  644|    235|#define PNG_AFTER_IDAT 0x08
  ------------------
 2492|       |
 2493|       |   /* Note, "length" is sufficient here; we won't be adding
 2494|       |    * a null terminator later.  The limit check in png_handle_chunk should be
 2495|       |    * sufficient.
 2496|       |    */
 2497|  1.81k|   buffer = png_read_buffer(png_ptr, length);
 2498|       |
 2499|  1.81k|   if (buffer == NULL)
  ------------------
  |  Branch (2499:8): [True: 0, False: 1.81k]
  ------------------
 2500|      0|   {
 2501|      0|      png_crc_finish(png_ptr, length);
  ------------------
  |  |   25|      0|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
 2502|      0|      png_chunk_benign_error(png_ptr, "out of memory");
  ------------------
  |  |  238|      0|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2503|      0|      return handled_error;
 2504|      0|   }
 2505|       |
 2506|  1.81k|   png_crc_read(png_ptr, buffer, length);
  ------------------
  |  |   24|  1.81k|#define png_crc_read OSS_FUZZ_png_crc_read
  ------------------
 2507|       |
 2508|  1.81k|   if (png_crc_finish(png_ptr, 0) != 0)
  ------------------
  |  |   25|  1.81k|#define png_crc_finish OSS_FUZZ_png_crc_finish
  ------------------
  |  Branch (2508:8): [True: 204, False: 1.60k]
  ------------------
 2509|    204|      return handled_error;
 2510|       |
 2511|       |   /* TODO: also check that the keyword contents match the spec! */
 2512|  1.60k|   for (keyword_length = 0;
 2513|  44.5k|      keyword_length < length && buffer[keyword_length] != 0;
  ------------------
  |  Branch (2513:7): [True: 43.9k, False: 612]
  |  Branch (2513:34): [True: 42.9k, False: 996]
  ------------------
 2514|  42.9k|      ++keyword_length)
 2515|  42.9k|      /* Empty loop to find end of name */ ;
 2516|       |
 2517|  1.60k|   if (keyword_length > 79 || keyword_length < 1)
  ------------------
  |  Branch (2517:8): [True: 18, False: 1.59k]
  |  Branch (2517:31): [True: 74, False: 1.51k]
  ------------------
 2518|     77|      errmsg = "bad keyword";
 2519|       |
 2520|       |   /* zTXt must have some LZ data after the keyword, although it may expand to
 2521|       |    * zero bytes; we need a '\0' at the end of the keyword, the compression type
 2522|       |    * then the LZ data:
 2523|       |    */
 2524|  1.53k|   else if (keyword_length + 3 > length)
  ------------------
  |  Branch (2524:13): [True: 595, False: 936]
  ------------------
 2525|    595|      errmsg = "truncated";
 2526|       |
 2527|    936|   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
  ------------------
  |  |  676|    936|#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
  ------------------
  |  Branch (2527:13): [True: 47, False: 889]
  ------------------
 2528|     47|      errmsg = "unknown compression type";
 2529|       |
 2530|    889|   else
 2531|    889|   {
 2532|    889|      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;
  ------------------
  |  |  649|    889|#define PNG_SIZE_MAX ((size_t)(-1))
  ------------------
 2533|       |
 2534|       |      /* TODO: at present png_decompress_chunk imposes a single application
 2535|       |       * level memory limit, this should be split to different values for iCCP
 2536|       |       * and text chunks.
 2537|       |       */
 2538|    889|      if (png_decompress_chunk(png_ptr, length, keyword_length+2,
  ------------------
  |  Branch (2538:11): [True: 14, False: 875]
  ------------------
 2539|    889|          &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
 2540|     14|      {
 2541|     14|         png_text text;
 2542|       |
 2543|     14|         if (png_ptr->read_buffer == NULL)
  ------------------
  |  Branch (2543:14): [True: 0, False: 14]
  ------------------
 2544|      0|           errmsg="Read failure in png_handle_zTXt";
 2545|     14|         else
 2546|     14|         {
 2547|       |            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk
 2548|       |             * except for the extra compression type byte and the fact that
 2549|       |             * it isn't necessarily '\0' terminated.
 2550|       |             */
 2551|     14|            buffer = png_ptr->read_buffer;
 2552|     14|            buffer[uncompressed_length+(keyword_length+2)] = 0;
 2553|       |
 2554|     14|            text.compression = PNG_TEXT_COMPRESSION_zTXt;
  ------------------
  |  |  587|     14|#define PNG_TEXT_COMPRESSION_zTXt     0
  ------------------
 2555|     14|            text.key = (png_charp)buffer;
 2556|     14|            text.text = (png_charp)(buffer + keyword_length+2);
 2557|     14|            text.text_length = uncompressed_length;
 2558|     14|            text.itxt_length = 0;
 2559|     14|            text.lang = NULL;
 2560|     14|            text.lang_key = NULL;
 2561|       |
 2562|     14|            if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)
  ------------------
  |  |   31|     14|#define png_set_text_2 OSS_FUZZ_png_set_text_2
  ------------------
  |  Branch (2562:17): [True: 14, False: 0]
  ------------------
 2563|     14|               return handled_ok;
 2564|       |
 2565|      0|            errmsg = "out of memory";
 2566|      0|         }
 2567|     14|      }
 2568|       |
 2569|    875|      else
 2570|    875|         errmsg = png_ptr->zstream.msg;
 2571|    889|   }
 2572|       |
 2573|  1.59k|   png_chunk_benign_error(png_ptr, errmsg);
  ------------------
  |  |  238|  1.59k|#define png_chunk_benign_error OSS_FUZZ_png_chunk_benign_error
  ------------------
 2574|  1.59k|   return handled_error;
 2575|  1.60k|}
pngrutil.c:png_init_filter_functions:
 4151|    829|{
 4152|    829|   unsigned int bpp = (pp->pixel_depth + 7) >> 3;
 4153|       |
 4154|    829|   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;
  ------------------
  |  | 1490|    829|#define PNG_FILTER_VALUE_SUB   1
  ------------------
 4155|    829|   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;
  ------------------
  |  | 1491|    829|#define PNG_FILTER_VALUE_UP    2
  ------------------
 4156|    829|   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;
  ------------------
  |  | 1492|    829|#define PNG_FILTER_VALUE_AVG   3
  ------------------
 4157|    829|   if (bpp == 1)
  ------------------
  |  Branch (4157:8): [True: 253, False: 576]
  ------------------
 4158|    253|      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
  ------------------
  |  | 1493|    253|#define PNG_FILTER_VALUE_PAETH 4
  ------------------
 4159|    253|         png_read_filter_row_paeth_1byte_pixel;
 4160|    576|   else
 4161|    576|      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
  ------------------
  |  | 1493|    576|#define PNG_FILTER_VALUE_PAETH 4
  ------------------
 4162|    576|         png_read_filter_row_paeth_multibyte_pixel;
 4163|       |
 4164|       |#ifdef PNG_FILTER_OPTIMIZATIONS
 4165|       |   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
 4166|       |    * call to install hardware optimizations for the above functions; simply
 4167|       |    * replace whatever elements of the pp->read_filter[] array with a hardware
 4168|       |    * specific (or, for that matter, generic) optimization.
 4169|       |    *
 4170|       |    * To see an example of this examine what configure.ac does when
 4171|       |    * --enable-arm-neon is specified on the command line.
 4172|       |    */
 4173|       |   PNG_FILTER_OPTIMIZATIONS(pp, bpp);
 4174|       |#endif
 4175|    829|}
pngrutil.c:png_read_filter_row_sub:
 3980|  48.5k|{
 3981|  48.5k|   size_t i;
 3982|  48.5k|   size_t istop = row_info->rowbytes;
 3983|  48.5k|   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
 3984|  48.5k|   png_bytep rp = row + bpp;
 3985|       |
 3986|  48.5k|   PNG_UNUSED(prev_row)
  ------------------
  |  |  455|  48.5k|#  define PNG_UNUSED(param) (void)param;
  ------------------
 3987|       |
 3988|  1.63M|   for (i = bpp; i < istop; i++)
  ------------------
  |  Branch (3988:18): [True: 1.58M, False: 48.5k]
  ------------------
 3989|  1.58M|   {
 3990|  1.58M|      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
 3991|  1.58M|      rp++;
 3992|  1.58M|   }
 3993|  48.5k|}
pngrutil.c:png_read_filter_row_up:
 3998|  55.7k|{
 3999|  55.7k|   size_t i;
 4000|  55.7k|   size_t istop = row_info->rowbytes;
 4001|  55.7k|   png_bytep rp = row;
 4002|  55.7k|   png_const_bytep pp = prev_row;
 4003|       |
 4004|  27.8M|   for (i = 0; i < istop; i++)
  ------------------
  |  Branch (4004:16): [True: 27.8M, False: 55.7k]
  ------------------
 4005|  27.8M|   {
 4006|  27.8M|      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
 4007|  27.8M|      rp++;
 4008|  27.8M|   }
 4009|  55.7k|}
pngrutil.c:png_read_filter_row_avg:
 4014|  4.20k|{
 4015|  4.20k|   size_t i;
 4016|  4.20k|   png_bytep rp = row;
 4017|  4.20k|   png_const_bytep pp = prev_row;
 4018|  4.20k|   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
 4019|  4.20k|   size_t istop = row_info->rowbytes - bpp;
 4020|       |
 4021|  19.7k|   for (i = 0; i < bpp; i++)
  ------------------
  |  Branch (4021:16): [True: 15.5k, False: 4.20k]
  ------------------
 4022|  15.5k|   {
 4023|  15.5k|      *rp = (png_byte)(((int)(*rp) +
 4024|  15.5k|         ((int)(*pp++) / 2 )) & 0xff);
 4025|       |
 4026|  15.5k|      rp++;
 4027|  15.5k|   }
 4028|       |
 4029|   600k|   for (i = 0; i < istop; i++)
  ------------------
  |  Branch (4029:16): [True: 596k, False: 4.20k]
  ------------------
 4030|   596k|   {
 4031|   596k|      *rp = (png_byte)(((int)(*rp) +
 4032|   596k|         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
 4033|       |
 4034|   596k|      rp++;
 4035|   596k|   }
 4036|  4.20k|}
pngrutil.c:png_read_filter_row_paeth_1byte_pixel:
 4041|  2.59k|{
 4042|  2.59k|   png_bytep rp_end = row + row_info->rowbytes;
 4043|  2.59k|   int a, c;
 4044|       |
 4045|       |   /* First pixel/byte */
 4046|  2.59k|   c = *prev_row++;
 4047|  2.59k|   a = *row + c;
 4048|  2.59k|   *row++ = (png_byte)a;
 4049|       |
 4050|       |   /* Remainder */
 4051|  48.8k|   while (row < rp_end)
  ------------------
  |  Branch (4051:11): [True: 46.2k, False: 2.59k]
  ------------------
 4052|  46.2k|   {
 4053|  46.2k|      int b, pa, pb, pc, p;
 4054|       |
 4055|  46.2k|      a &= 0xff; /* From previous iteration or start */
 4056|  46.2k|      b = *prev_row++;
 4057|       |
 4058|  46.2k|      p = b - c;
 4059|  46.2k|      pc = a - c;
 4060|       |
 4061|       |#ifdef PNG_USE_ABS
 4062|       |      pa = abs(p);
 4063|       |      pb = abs(pc);
 4064|       |      pc = abs(p + pc);
 4065|       |#else
 4066|  46.2k|      pa = p < 0 ? -p : p;
  ------------------
  |  Branch (4066:12): [True: 8.73k, False: 37.4k]
  ------------------
 4067|  46.2k|      pb = pc < 0 ? -pc : pc;
  ------------------
  |  Branch (4067:12): [True: 5.88k, False: 40.3k]
  ------------------
 4068|  46.2k|      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
  ------------------
  |  Branch (4068:12): [True: 8.06k, False: 38.1k]
  ------------------
 4069|  46.2k|#endif
 4070|       |
 4071|       |      /* Find the best predictor, the least of pa, pb, pc favoring the earlier
 4072|       |       * ones in the case of a tie.
 4073|       |       */
 4074|  46.2k|      if (pb < pa)
  ------------------
  |  Branch (4074:11): [True: 7.89k, False: 38.3k]
  ------------------
 4075|  7.89k|      {
 4076|  7.89k|         pa = pb; a = b;
 4077|  7.89k|      }
 4078|  46.2k|      if (pc < pa) a = c;
  ------------------
  |  Branch (4078:11): [True: 434, False: 45.7k]
  ------------------
 4079|       |
 4080|       |      /* Calculate the current pixel in a, and move the previous row pixel to c
 4081|       |       * for the next time round the loop
 4082|       |       */
 4083|  46.2k|      c = b;
 4084|  46.2k|      a += *row;
 4085|  46.2k|      *row++ = (png_byte)a;
 4086|  46.2k|   }
 4087|  2.59k|}
pngrutil.c:png_read_filter_row_paeth_multibyte_pixel:
 4092|  17.5k|{
 4093|  17.5k|   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
 4094|  17.5k|   png_bytep rp_end = row + bpp;
 4095|       |
 4096|       |   /* Process the first pixel in the row completely (this is the same as 'up'
 4097|       |    * because there is only one candidate predictor for the first row).
 4098|       |    */
 4099|  85.7k|   while (row < rp_end)
  ------------------
  |  Branch (4099:11): [True: 68.1k, False: 17.5k]
  ------------------
 4100|  68.1k|   {
 4101|  68.1k|      int a = *row + *prev_row++;
 4102|  68.1k|      *row++ = (png_byte)a;
 4103|  68.1k|   }
 4104|       |
 4105|       |   /* Remainder */
 4106|  17.5k|   rp_end = rp_end + (row_info->rowbytes - bpp);
 4107|       |
 4108|  4.00M|   while (row < rp_end)
  ------------------
  |  Branch (4108:11): [True: 3.98M, False: 17.5k]
  ------------------
 4109|  3.98M|   {
 4110|  3.98M|      int a, b, c, pa, pb, pc, p;
 4111|       |
 4112|  3.98M|      c = *(prev_row - bpp);
 4113|  3.98M|      a = *(row - bpp);
 4114|  3.98M|      b = *prev_row++;
 4115|       |
 4116|  3.98M|      p = b - c;
 4117|  3.98M|      pc = a - c;
 4118|       |
 4119|       |#ifdef PNG_USE_ABS
 4120|       |      pa = abs(p);
 4121|       |      pb = abs(pc);
 4122|       |      pc = abs(p + pc);
 4123|       |#else
 4124|  3.98M|      pa = p < 0 ? -p : p;
  ------------------
  |  Branch (4124:12): [True: 455k, False: 3.53M]
  ------------------
 4125|  3.98M|      pb = pc < 0 ? -pc : pc;
  ------------------
  |  Branch (4125:12): [True: 156k, False: 3.83M]
  ------------------
 4126|  3.98M|      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
  ------------------
  |  Branch (4126:12): [True: 331k, False: 3.65M]
  ------------------
 4127|  3.98M|#endif
 4128|       |
 4129|  3.98M|      if (pb < pa)
  ------------------
  |  Branch (4129:11): [True: 861k, False: 3.12M]
  ------------------
 4130|   861k|      {
 4131|   861k|         pa = pb; a = b;
 4132|   861k|      }
 4133|  3.98M|      if (pc < pa) a = c;
  ------------------
  |  Branch (4133:11): [True: 69.1k, False: 3.91M]
  ------------------
 4134|       |
 4135|  3.98M|      a += *row;
 4136|  3.98M|      *row++ = (png_byte)a;
 4137|  3.98M|   }
 4138|  17.5k|}
pngrutil.c:png_read_buffer:
  377|  15.2k|{
  378|  15.2k|   png_bytep buffer = png_ptr->read_buffer;
  379|       |
  380|  15.2k|   if (new_size > png_chunk_max(png_ptr)) return NULL;
  ------------------
  |  | 1097|  15.2k|#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)
  ------------------
  |  Branch (380:8): [True: 5, False: 15.2k]
  ------------------
  381|       |
  382|  15.2k|   if (buffer != NULL && new_size > png_ptr->read_buffer_size)
  ------------------
  |  Branch (382:8): [True: 12.2k, False: 2.98k]
  |  Branch (382:26): [True: 732, False: 11.5k]
  ------------------
  383|    732|   {
  384|    732|      png_ptr->read_buffer = NULL;
  385|    732|      png_ptr->read_buffer_size = 0;
  386|    732|      png_free(png_ptr, buffer);
  ------------------
  |  |  253|    732|#define png_free OSS_FUZZ_png_free
  ------------------
  387|    732|      buffer = NULL;
  388|    732|   }
  389|       |
  390|  15.2k|   if (buffer == NULL)
  ------------------
  |  Branch (390:8): [True: 3.71k, False: 11.5k]
  ------------------
  391|  3.71k|   {
  392|  3.71k|      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));
  ------------------
  |  |  511|  3.71k|#  define png_voidcast(type, value) (value)
  ------------------
  393|       |
  394|  3.71k|      if (buffer != NULL)
  ------------------
  |  Branch (394:11): [True: 3.71k, False: 0]
  ------------------
  395|  3.71k|      {
  396|  3.71k|#        ifndef PNG_NO_MEMZERO /* for detecting UIM bugs **only** */
  397|  3.71k|            memset(buffer, 0, new_size); /* just in case */
  398|  3.71k|#        endif
  399|  3.71k|         png_ptr->read_buffer = buffer;
  400|  3.71k|         png_ptr->read_buffer_size = new_size;
  401|  3.71k|      }
  402|  3.71k|   }
  403|       |
  404|  15.2k|   return buffer;
  405|  15.2k|}
pngrutil.c:png_inflate_claim:
  415|  4.32k|{
  416|  4.32k|   if (png_ptr->zowner != 0)
  ------------------
  |  Branch (416:8): [True: 0, False: 4.32k]
  ------------------
  417|      0|   {
  418|      0|      char msg[64];
  419|       |
  420|      0|      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);
  ------------------
  |  |  907|      0|   (void)(((char*)(s))[0]=(char)(((c)>>24) & 0xff), \
  |  |  908|      0|   ((char*)(s))[1]=(char)(((c)>>16) & 0xff),\
  |  |  909|      0|   ((char*)(s))[2]=(char)(((c)>>8) & 0xff), \
  |  |  910|      0|   ((char*)(s))[3]=(char)((c & 0xff)))
  ------------------
  421|       |      /* So the message that results is "<chunk> using zstream"; this is an
  422|       |       * internal error, but is very useful for debugging.  i18n requirements
  423|       |       * are minimal.
  424|       |       */
  425|      0|      (void)png_safecat(msg, (sizeof msg), 4, " using zstream");
  ------------------
  |  |   75|      0|#define png_safecat OSS_FUZZ_png_safecat
  ------------------
  426|       |#if PNG_RELEASE_BUILD
  427|       |      png_chunk_warning(png_ptr, msg);
  428|       |      png_ptr->zowner = 0;
  429|       |#else
  430|      0|      png_chunk_error(png_ptr, msg);
  ------------------
  |  |  239|      0|#define png_chunk_error OSS_FUZZ_png_chunk_error
  ------------------
  431|      0|#endif
  432|      0|   }
  433|       |
  434|       |   /* Implementation note: unlike 'png_deflate_claim' this internal function
  435|       |    * does not take the size of the data as an argument.  Some efficiency could
  436|       |    * be gained by using this when it is known *if* the zlib stream itself does
  437|       |    * not record the number; however, this is an illusion: the original writer
  438|       |    * of the PNG may have selected a lower window size, and we really must
  439|       |    * follow that because, for systems with with limited capabilities, we
  440|       |    * would otherwise reject the application's attempts to use a smaller window
  441|       |    * size (zlib doesn't have an interface to say "this or lower"!).
  442|       |    *
  443|       |    * inflateReset2 was added to zlib 1.2.4; before this the window could not be
  444|       |    * reset, therefore it is necessary to always allocate the maximum window
  445|       |    * size with earlier zlibs just in case later compressed chunks need it.
  446|       |    */
  447|  4.32k|   {
  448|  4.32k|      int ret; /* zlib return code */
  449|  4.32k|#if ZLIB_VERNUM >= 0x1240
  450|  4.32k|      int window_bits = 0;
  451|       |
  452|  4.32k|# if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)
  453|  4.32k|      if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==
  ------------------
  |  | 3309|  4.32k|#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
  ------------------
  |  Branch (453:11): [True: 0, False: 4.32k]
  ------------------
  454|  4.32k|          PNG_OPTION_ON)
  ------------------
  |  | 3331|  4.32k|#define PNG_OPTION_ON      3
  ------------------
  455|      0|      {
  456|      0|         window_bits = 15;
  457|      0|         png_ptr->zstream_start = 0; /* fixed window size */
  458|      0|      }
  459|       |
  460|  4.32k|      else
  461|  4.32k|      {
  462|  4.32k|         png_ptr->zstream_start = 1;
  463|  4.32k|      }
  464|  4.32k|# endif
  465|       |
  466|  4.32k|#endif /* ZLIB_VERNUM >= 0x1240 */
  467|       |
  468|       |      /* Set this for safety, just in case the previous owner left pointers to
  469|       |       * memory allocations.
  470|       |       */
  471|  4.32k|      png_ptr->zstream.next_in = NULL;
  472|  4.32k|      png_ptr->zstream.avail_in = 0;
  473|  4.32k|      png_ptr->zstream.next_out = NULL;
  474|  4.32k|      png_ptr->zstream.avail_out = 0;
  475|       |
  476|  4.32k|      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
  ------------------
  |  |  672|  4.32k|#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002U /* Added to libpng-1.6.0 */
  ------------------
  |  Branch (476:11): [True: 2.52k, False: 1.80k]
  ------------------
  477|  2.52k|      {
  478|  2.52k|#if ZLIB_VERNUM >= 0x1240
  479|  2.52k|         ret = inflateReset2(&png_ptr->zstream, window_bits);
  480|       |#else
  481|       |         ret = inflateReset(&png_ptr->zstream);
  482|       |#endif
  483|  2.52k|      }
  484|       |
  485|  1.80k|      else
  486|  1.80k|      {
  487|  1.80k|#if ZLIB_VERNUM >= 0x1240
  488|  1.80k|         ret = inflateInit2(&png_ptr->zstream, window_bits);
  489|       |#else
  490|       |         ret = inflateInit(&png_ptr->zstream);
  491|       |#endif
  492|       |
  493|  1.80k|         if (ret == Z_OK)
  ------------------
  |  Branch (493:14): [True: 1.80k, False: 0]
  ------------------
  494|  1.80k|            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
  ------------------
  |  |  672|  1.80k|#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002U /* Added to libpng-1.6.0 */
  ------------------
  495|  1.80k|      }
  496|       |
  497|       |#ifdef PNG_DISABLE_ADLER32_CHECK_SUPPORTED
  498|       |      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)
  499|       |         /* Turn off validation of the ADLER32 checksum in IDAT chunks */
  500|       |         ret = inflateValidate(&png_ptr->zstream, 0);
  501|       |#endif
  502|       |
  503|  4.32k|      if (ret == Z_OK)
  ------------------
  |  Branch (503:11): [True: 4.32k, False: 0]
  ------------------
  504|  4.32k|         png_ptr->zowner = owner;
  505|       |
  506|      0|      else
  507|      0|         png_zstream_error(png_ptr, ret);
  ------------------
  |  |    4|      0|#define png_zstream_error OSS_FUZZ_png_zstream_error
  ------------------
  508|       |
  509|  4.32k|      return ret;
  510|  4.32k|   }
  511|       |
  512|       |#ifdef window_bits
  513|       |# undef window_bits
  514|       |#endif
  515|  4.32k|}

OSS_FUZZ_png_set_bKGD:
   26|    278|{
   27|    278|   png_debug1(1, "in %s storage function", "bKGD");
  ------------------
  |  |  151|    278|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
   28|       |
   29|    278|   if (png_ptr == NULL || info_ptr == NULL || background == NULL)
  ------------------
  |  Branch (29:8): [True: 0, False: 278]
  |  Branch (29:27): [True: 0, False: 278]
  |  Branch (29:47): [True: 0, False: 278]
  ------------------
   30|      0|      return;
   31|       |
   32|    278|   info_ptr->background = *background;
   33|    278|   info_ptr->valid |= PNG_INFO_bKGD;
  ------------------
  |  |  735|    278|#define PNG_INFO_bKGD 0x0020U
  ------------------
   34|    278|}
OSS_FUZZ_png_set_cHRM_fixed:
   43|    502|{
   44|    502|   png_debug1(1, "in %s storage function", "cHRM fixed");
  ------------------
  |  |  151|    502|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
   45|       |
   46|    502|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (46:8): [True: 0, False: 502]
  |  Branch (46:27): [True: 0, False: 502]
  ------------------
   47|      0|      return;
   48|       |
   49|    502|   info_ptr->cHRM.redx = red_x;
   50|    502|   info_ptr->cHRM.redy = red_y;
   51|    502|   info_ptr->cHRM.greenx = green_x;
   52|    502|   info_ptr->cHRM.greeny = green_y;
   53|    502|   info_ptr->cHRM.bluex = blue_x;
   54|    502|   info_ptr->cHRM.bluey = blue_y;
   55|    502|   info_ptr->cHRM.whitex = white_x;
   56|    502|   info_ptr->cHRM.whitey = white_y;
   57|       |
   58|    502|   info_ptr->valid |= PNG_INFO_cHRM;
  ------------------
  |  |  732|    502|#define PNG_INFO_cHRM 0x0004U
  ------------------
   59|    502|}
OSS_FUZZ_png_set_cICP:
  139|    234|{
  140|    234|   png_debug1(1, "in %s storage function", "cICP");
  ------------------
  |  |  151|    234|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  141|       |
  142|    234|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (142:8): [True: 0, False: 234]
  |  Branch (142:27): [True: 0, False: 234]
  ------------------
  143|      0|      return;
  144|       |
  145|    234|   info_ptr->cicp_colour_primaries = colour_primaries;
  146|    234|   info_ptr->cicp_transfer_function = transfer_function;
  147|    234|   info_ptr->cicp_matrix_coefficients = matrix_coefficients;
  148|    234|   info_ptr->cicp_video_full_range_flag = video_full_range_flag;
  149|       |
  150|    234|   if (info_ptr->cicp_matrix_coefficients != 0)
  ------------------
  |  Branch (150:8): [True: 36, False: 198]
  ------------------
  151|     36|   {
  152|     36|      png_warning(png_ptr, "Invalid cICP matrix coefficients");
  ------------------
  |  |  450|     36|#define png_warning OSS_FUZZ_png_warning
  ------------------
  153|     36|      return;
  154|     36|   }
  155|       |
  156|    198|   info_ptr->valid |= PNG_INFO_cICP;
  ------------------
  |  |  747|    198|#define PNG_INFO_cICP 0x20000U /* PNGv3: 1.6.45 */
  ------------------
  157|    198|}
OSS_FUZZ_png_set_cLLI_fixed:
  167|    217|{
  168|    217|   png_debug1(1, "in %s storage function", "cLLI");
  ------------------
  |  |  151|    217|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  169|       |
  170|    217|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (170:8): [True: 0, False: 217]
  |  Branch (170:27): [True: 0, False: 217]
  ------------------
  171|      0|      return;
  172|       |
  173|       |   /* Check the light level range: */
  174|    217|   if (maxCLL > 0x7FFFFFFFU || maxFALL > 0x7FFFFFFFU)
  ------------------
  |  Branch (174:8): [True: 3, False: 214]
  |  Branch (174:32): [True: 1, False: 213]
  ------------------
  175|      4|   {
  176|       |      /* The limit is 200kcd/m2; somewhat bright but not inconceivable because
  177|       |       * human vision is said to run up to 100Mcd/m2.  The sun is about 2Gcd/m2.
  178|       |       *
  179|       |       * The reference sRGB monitor is 80cd/m2 and the limit of PQ encoding is
  180|       |       * 2kcd/m2.
  181|       |       */
  182|      4|      png_chunk_report(png_ptr, "cLLI light level exceeds PNG limit",
  ------------------
  |  |   83|      4|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  183|      4|            PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      4|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  184|      4|      return;
  185|      4|   }
  186|       |
  187|    213|   info_ptr->maxCLL = maxCLL;
  188|    213|   info_ptr->maxFALL = maxFALL;
  189|    213|   info_ptr->valid |= PNG_INFO_cLLI;
  ------------------
  |  |  748|    213|#define PNG_INFO_cLLI 0x40000U /* PNGv3: 1.6.45 */
  ------------------
  190|    213|}
OSS_FUZZ_png_set_mDCV_fixed:
  232|    215|{
  233|    215|   png_uint_16 rx, ry, gx, gy, bx, by, wx, wy;
  234|    215|   int error;
  235|       |
  236|    215|   png_debug1(1, "in %s storage function", "mDCV");
  ------------------
  |  |  151|    215|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  237|       |
  238|    215|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (238:8): [True: 0, False: 215]
  |  Branch (238:27): [True: 0, False: 215]
  ------------------
  239|      0|      return;
  240|       |
  241|       |   /* Check the input values to ensure they are in the expected range: */
  242|    215|   error = 0;
  243|    215|   rx = png_ITU_fixed_16(&error, red_x);
  244|    215|   ry = png_ITU_fixed_16(&error, red_y);
  245|    215|   gx = png_ITU_fixed_16(&error, green_x);
  246|    215|   gy = png_ITU_fixed_16(&error, green_y);
  247|    215|   bx = png_ITU_fixed_16(&error, blue_x);
  248|    215|   by = png_ITU_fixed_16(&error, blue_y);
  249|    215|   wx = png_ITU_fixed_16(&error, white_x);
  250|    215|   wy = png_ITU_fixed_16(&error, white_y);
  251|       |
  252|    215|   if (error)
  ------------------
  |  Branch (252:8): [True: 0, False: 215]
  ------------------
  253|      0|   {
  254|      0|      png_chunk_report(png_ptr,
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  255|      0|         "mDCV chromaticities outside representable range",
  256|      0|         PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  257|      0|      return;
  258|      0|   }
  259|       |
  260|       |   /* Check the light level range: */
  261|    215|   if (maxDL > 0x7FFFFFFFU || minDL > 0x7FFFFFFFU)
  ------------------
  |  Branch (261:8): [True: 2, False: 213]
  |  Branch (261:31): [True: 4, False: 209]
  ------------------
  262|      6|   {
  263|       |      /* The limit is 200kcd/m2; somewhat bright but not inconceivable because
  264|       |       * human vision is said to run up to 100Mcd/m2.  The sun is about 2Gcd/m2.
  265|       |       *
  266|       |       * The reference sRGB monitor is 80cd/m2 and the limit of PQ encoding is
  267|       |       * 2kcd/m2.
  268|       |       */
  269|      6|      png_chunk_report(png_ptr, "mDCV display light level exceeds PNG limit",
  ------------------
  |  |   83|      6|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  270|      6|            PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      6|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  271|      6|      return;
  272|      6|   }
  273|       |
  274|       |   /* All values are safe, the settings are accepted.
  275|       |    *
  276|       |    * IMPLEMENTATION NOTE: in practice the values can be checked and assigned
  277|       |    * but the result is confusing if a writing app calls png_set_mDCV more than
  278|       |    * once, the second time with an invalid value.  This approach is more
  279|       |    * obviously correct at the cost of typing and a very slight machine
  280|       |    * overhead.
  281|       |    */
  282|    209|   info_ptr->mastering_red_x = rx;
  283|    209|   info_ptr->mastering_red_y = ry;
  284|    209|   info_ptr->mastering_green_x = gx;
  285|    209|   info_ptr->mastering_green_y = gy;
  286|    209|   info_ptr->mastering_blue_x = bx;
  287|    209|   info_ptr->mastering_blue_y = by;
  288|    209|   info_ptr->mastering_white_x = wx;
  289|    209|   info_ptr->mastering_white_y = wy;
  290|    209|   info_ptr->mastering_maxDL = maxDL;
  291|    209|   info_ptr->mastering_minDL = minDL;
  292|    209|   info_ptr->valid |= PNG_INFO_mDCV;
  ------------------
  |  |  749|    209|#define PNG_INFO_mDCV 0x80000U /* PNGv3: 1.6.45 */
  ------------------
  293|    209|}
OSS_FUZZ_png_set_eXIf_1:
  330|     16|{
  331|     16|   png_bytep new_exif;
  332|       |
  333|     16|   png_debug1(1, "in %s storage function", "eXIf");
  ------------------
  |  |  151|     16|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  334|       |
  335|     16|   if (png_ptr == NULL || info_ptr == NULL ||
  ------------------
  |  Branch (335:8): [True: 0, False: 16]
  |  Branch (335:27): [True: 0, False: 16]
  ------------------
  336|     16|       (png_ptr->mode & PNG_WROTE_eXIf) != 0)
  ------------------
  |  |  630|     16|#define PNG_WROTE_eXIf            0x4000U
  ------------------
  |  Branch (336:8): [True: 0, False: 16]
  ------------------
  337|      0|      return;
  338|       |
  339|     16|   new_exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr, num_exif));
  ------------------
  |  |  511|     16|#  define png_voidcast(type, value) (value)
  ------------------
  340|       |
  341|     16|   if (new_exif == NULL)
  ------------------
  |  Branch (341:8): [True: 0, False: 16]
  ------------------
  342|      0|   {
  343|      0|      png_warning(png_ptr, "Insufficient memory for eXIf chunk data");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  344|      0|      return;
  345|      0|   }
  346|       |
  347|     16|   memcpy(new_exif, exif, (size_t)num_exif);
  348|       |
  349|     16|   png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);
  ------------------
  |  |  254|     16|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
                 png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);
  ------------------
  |  | 1771|     16|#define PNG_FREE_EXIF 0x8000U /* Added at libpng-1.6.31 */
  ------------------
  350|       |
  351|     16|   info_ptr->num_exif = num_exif;
  352|     16|   info_ptr->exif = new_exif;
  353|     16|   info_ptr->free_me |= PNG_FREE_EXIF;
  ------------------
  |  | 1771|     16|#define PNG_FREE_EXIF 0x8000U /* Added at libpng-1.6.31 */
  ------------------
  354|     16|   info_ptr->valid |= PNG_INFO_eXIf;
  ------------------
  |  |  746|     16|#define PNG_INFO_eXIf 0x10000U /* GR-P, 1.6.31 */
  ------------------
  355|     16|}
OSS_FUZZ_png_set_gAMA_fixed:
  362|    803|{
  363|    803|   png_debug1(1, "in %s storage function", "gAMA");
  ------------------
  |  |  151|    803|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  364|       |
  365|    803|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (365:8): [True: 0, False: 803]
  |  Branch (365:27): [True: 0, False: 803]
  ------------------
  366|      0|      return;
  367|       |
  368|    803|   info_ptr->gamma = file_gamma;
  369|    803|   info_ptr->valid |= PNG_INFO_gAMA;
  ------------------
  |  |  730|    803|#define PNG_INFO_gAMA 0x0001U
  ------------------
  370|    803|}
OSS_FUZZ_png_set_hIST:
  386|      1|{
  387|      1|   int i;
  388|       |
  389|      1|   png_debug1(1, "in %s storage function", "hIST");
  ------------------
  |  |  151|      1|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  390|       |
  391|      1|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (391:8): [True: 0, False: 1]
  |  Branch (391:27): [True: 0, False: 1]
  ------------------
  392|      0|      return;
  393|       |
  394|      1|   if (info_ptr->num_palette == 0 || info_ptr->num_palette
  ------------------
  |  Branch (394:8): [True: 1, False: 0]
  |  Branch (394:38): [True: 0, False: 0]
  ------------------
  395|      0|       > PNG_MAX_PALETTE_LENGTH)
  ------------------
  |  |  723|      0|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  396|      1|   {
  397|      1|      png_warning(png_ptr,
  ------------------
  |  |  450|      1|#define png_warning OSS_FUZZ_png_warning
  ------------------
  398|      1|          "Invalid palette size, hIST allocation skipped");
  399|       |
  400|      1|      return;
  401|      1|   }
  402|       |
  403|      0|   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
  ------------------
  |  |  254|      0|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
                 png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
  ------------------
  |  | 1758|      0|#define PNG_FREE_HIST 0x0008U
  ------------------
  404|       |
  405|       |   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
  406|       |    * version 1.2.1
  407|       |    */
  408|      0|   info_ptr->hist = png_voidcast(png_uint_16p, png_malloc_warn(png_ptr,
  ------------------
  |  |  511|      0|#  define png_voidcast(type, value) (value)
  ------------------
  409|      0|       PNG_MAX_PALETTE_LENGTH * (sizeof (png_uint_16))));
  410|       |
  411|      0|   if (info_ptr->hist == NULL)
  ------------------
  |  Branch (411:8): [True: 0, False: 0]
  ------------------
  412|      0|   {
  413|      0|      png_warning(png_ptr, "Insufficient memory for hIST chunk data");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  414|      0|      return;
  415|      0|   }
  416|       |
  417|      0|   for (i = 0; i < info_ptr->num_palette; i++)
  ------------------
  |  Branch (417:16): [True: 0, False: 0]
  ------------------
  418|      0|      info_ptr->hist[i] = hist[i];
  419|       |
  420|      0|   info_ptr->free_me |= PNG_FREE_HIST;
  ------------------
  |  | 1758|      0|#define PNG_FREE_HIST 0x0008U
  ------------------
  421|      0|   info_ptr->valid |= PNG_INFO_hIST;
  ------------------
  |  |  736|      0|#define PNG_INFO_hIST 0x0040U
  ------------------
  422|      0|}
OSS_FUZZ_png_set_IHDR:
  430|  2.56k|{
  431|  2.56k|   png_debug1(1, "in %s storage function", "IHDR");
  ------------------
  |  |  151|  2.56k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  432|       |
  433|  2.56k|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (433:8): [True: 0, False: 2.56k]
  |  Branch (433:27): [True: 0, False: 2.56k]
  ------------------
  434|      0|      return;
  435|       |
  436|  2.56k|   info_ptr->width = width;
  437|  2.56k|   info_ptr->height = height;
  438|  2.56k|   info_ptr->bit_depth = (png_byte)bit_depth;
  439|  2.56k|   info_ptr->color_type = (png_byte)color_type;
  440|  2.56k|   info_ptr->compression_type = (png_byte)compression_type;
  441|  2.56k|   info_ptr->filter_type = (png_byte)filter_type;
  442|  2.56k|   info_ptr->interlace_type = (png_byte)interlace_type;
  443|       |
  444|  2.56k|   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
  ------------------
  |  |   72|  2.56k|#define png_check_IHDR OSS_FUZZ_png_check_IHDR
  ------------------
  445|  2.56k|       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
  446|  2.56k|       info_ptr->compression_type, info_ptr->filter_type);
  447|       |
  448|  2.56k|   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|  2.56k|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|  2.56k|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|  2.56k|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (448:8): [True: 472, False: 2.09k]
  ------------------
  449|    472|      info_ptr->channels = 1;
  450|       |
  451|  2.09k|   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
  ------------------
  |  |  662|  2.09k|#define PNG_COLOR_MASK_COLOR      2
  ------------------
  |  Branch (451:13): [True: 865, False: 1.22k]
  ------------------
  452|    865|      info_ptr->channels = 3;
  453|       |
  454|  1.22k|   else
  455|  1.22k|      info_ptr->channels = 1;
  456|       |
  457|  2.56k|   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
  ------------------
  |  |  663|  2.56k|#define PNG_COLOR_MASK_ALPHA      4
  ------------------
  |  Branch (457:8): [True: 608, False: 1.95k]
  ------------------
  458|    608|      info_ptr->channels++;
  459|       |
  460|  2.56k|   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
  461|       |
  462|  2.56k|   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
  ------------------
  |  |  731|  2.56k|    ((pixel_bits) >= 8 ? \
  |  |  ------------------
  |  |  |  Branch (731:6): [True: 1.23k, False: 1.33k]
  |  |  ------------------
  |  |  732|  2.56k|    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
  |  |  733|  2.56k|    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
  ------------------
  463|  2.56k|}
OSS_FUZZ_png_set_oFFs:
  469|    251|{
  470|    251|   png_debug1(1, "in %s storage function", "oFFs");
  ------------------
  |  |  151|    251|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  471|       |
  472|    251|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (472:8): [True: 0, False: 251]
  |  Branch (472:27): [True: 0, False: 251]
  ------------------
  473|      0|      return;
  474|       |
  475|    251|   info_ptr->x_offset = offset_x;
  476|    251|   info_ptr->y_offset = offset_y;
  477|    251|   info_ptr->offset_unit_type = (png_byte)unit_type;
  478|    251|   info_ptr->valid |= PNG_INFO_oFFs;
  ------------------
  |  |  738|    251|#define PNG_INFO_oFFs 0x0100U
  ------------------
  479|    251|}
OSS_FUZZ_png_set_pCAL:
  487|    226|{
  488|    226|   size_t length;
  489|    226|   int i;
  490|       |
  491|    226|   png_debug1(1, "in %s storage function", "pCAL");
  ------------------
  |  |  151|    226|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  492|       |
  493|    226|   if (png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL
  ------------------
  |  Branch (493:8): [True: 0, False: 226]
  |  Branch (493:27): [True: 0, False: 226]
  |  Branch (493:47): [True: 0, False: 226]
  |  Branch (493:66): [True: 0, False: 226]
  ------------------
  494|    226|       || (nparams > 0 && params == NULL))
  ------------------
  |  Branch (494:12): [True: 185, False: 41]
  |  Branch (494:27): [True: 0, False: 185]
  ------------------
  495|      0|      return;
  496|       |
  497|    226|   length = strlen(purpose) + 1;
  498|    226|   png_debug1(3, "allocating purpose for info (%lu bytes)",
  ------------------
  |  |  151|    226|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  499|    226|       (unsigned long)length);
  500|       |
  501|       |   /* TODO: validate format of calibration name and unit name */
  502|       |
  503|       |   /* Check that the type matches the specification. */
  504|    226|   if (type < 0 || type > 3)
  ------------------
  |  Branch (504:8): [True: 0, False: 226]
  |  Branch (504:20): [True: 42, False: 184]
  ------------------
  505|     42|   {
  506|     42|      png_chunk_report(png_ptr, "Invalid pCAL equation type",
  ------------------
  |  |   83|     42|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  507|     42|            PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|     42|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  508|     42|      return;
  509|     42|   }
  510|       |
  511|    184|   if (nparams < 0 || nparams > 255)
  ------------------
  |  Branch (511:8): [True: 0, False: 184]
  |  Branch (511:23): [True: 0, False: 184]
  ------------------
  512|      0|   {
  513|      0|      png_chunk_report(png_ptr, "Invalid pCAL parameter count",
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  514|      0|            PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  515|      0|      return;
  516|      0|   }
  517|       |
  518|       |   /* Validate params[nparams] */
  519|    318|   for (i=0; i<nparams; ++i)
  ------------------
  |  Branch (519:14): [True: 260, False: 58]
  ------------------
  520|    260|   {
  521|    260|      if (params[i] == NULL ||
  ------------------
  |  Branch (521:11): [True: 0, False: 260]
  ------------------
  522|    260|          !png_check_fp_string(params[i], strlen(params[i])))
  ------------------
  |  |   87|    260|#define png_check_fp_string OSS_FUZZ_png_check_fp_string
  ------------------
  |  Branch (522:11): [True: 126, False: 134]
  ------------------
  523|    126|      {
  524|    126|         png_chunk_report(png_ptr, "Invalid format for pCAL parameter",
  ------------------
  |  |   83|    126|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  525|    126|               PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|    126|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  526|    126|         return;
  527|    126|      }
  528|    260|   }
  529|       |
  530|     58|   info_ptr->pcal_purpose = png_voidcast(png_charp,
  ------------------
  |  |  511|     58|#  define png_voidcast(type, value) (value)
  ------------------
  531|     58|       png_malloc_warn(png_ptr, length));
  532|       |
  533|     58|   if (info_ptr->pcal_purpose == NULL)
  ------------------
  |  Branch (533:8): [True: 0, False: 58]
  ------------------
  534|      0|   {
  535|      0|      png_chunk_report(png_ptr, "Insufficient memory for pCAL purpose",
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  536|      0|            PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  537|      0|      return;
  538|      0|   }
  539|       |
  540|     58|   memcpy(info_ptr->pcal_purpose, purpose, length);
  541|       |
  542|     58|   info_ptr->free_me |= PNG_FREE_PCAL;
  ------------------
  |  | 1762|     58|#define PNG_FREE_PCAL 0x0080U
  ------------------
  543|       |
  544|     58|   png_debug(3, "storing X0, X1, type, and nparams in info");
  ------------------
  |  |  148|     58|#  define png_debug(l, m) ((void)0)
  ------------------
  545|     58|   info_ptr->pcal_X0 = X0;
  546|     58|   info_ptr->pcal_X1 = X1;
  547|     58|   info_ptr->pcal_type = (png_byte)type;
  548|     58|   info_ptr->pcal_nparams = (png_byte)nparams;
  549|       |
  550|     58|   length = strlen(units) + 1;
  551|     58|   png_debug1(3, "allocating units for info (%lu bytes)",
  ------------------
  |  |  151|     58|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  552|     58|       (unsigned long)length);
  553|       |
  554|     58|   info_ptr->pcal_units = png_voidcast(png_charp,
  ------------------
  |  |  511|     58|#  define png_voidcast(type, value) (value)
  ------------------
  555|     58|       png_malloc_warn(png_ptr, length));
  556|       |
  557|     58|   if (info_ptr->pcal_units == NULL)
  ------------------
  |  Branch (557:8): [True: 0, False: 58]
  ------------------
  558|      0|   {
  559|      0|      png_warning(png_ptr, "Insufficient memory for pCAL units");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  560|      0|      return;
  561|      0|   }
  562|       |
  563|     58|   memcpy(info_ptr->pcal_units, units, length);
  564|       |
  565|     58|   info_ptr->pcal_params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
  ------------------
  |  |  511|     58|#  define png_voidcast(type, value) (value)
  ------------------
  566|     58|       (size_t)(((unsigned int)nparams + 1) * (sizeof (png_charp)))));
  567|       |
  568|     58|   if (info_ptr->pcal_params == NULL)
  ------------------
  |  Branch (568:8): [True: 0, False: 58]
  ------------------
  569|      0|   {
  570|      0|      png_warning(png_ptr, "Insufficient memory for pCAL params");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  571|      0|      return;
  572|      0|   }
  573|       |
  574|     58|   memset(info_ptr->pcal_params, 0, ((unsigned int)nparams + 1) *
  575|     58|       (sizeof (png_charp)));
  576|       |
  577|    174|   for (i = 0; i < nparams; i++)
  ------------------
  |  Branch (577:16): [True: 116, False: 58]
  ------------------
  578|    116|   {
  579|    116|      length = strlen(params[i]) + 1;
  580|    116|      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
  ------------------
  |  |  154|    116|#  define png_debug2(l, m, p1, p2) ((void)0)
  ------------------
  581|    116|          (unsigned long)length);
  582|       |
  583|    116|      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);
  ------------------
  |  |  349|    116|#define png_malloc_warn OSS_FUZZ_png_malloc_warn
  ------------------
  584|       |
  585|    116|      if (info_ptr->pcal_params[i] == NULL)
  ------------------
  |  Branch (585:11): [True: 0, False: 116]
  ------------------
  586|      0|      {
  587|      0|         png_warning(png_ptr, "Insufficient memory for pCAL parameter");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  588|      0|         return;
  589|      0|      }
  590|       |
  591|    116|      memcpy(info_ptr->pcal_params[i], params[i], length);
  592|    116|   }
  593|       |
  594|     58|   info_ptr->valid |= PNG_INFO_pCAL;
  ------------------
  |  |  740|     58|#define PNG_INFO_pCAL 0x0400U
  ------------------
  595|     58|}
OSS_FUZZ_png_set_sCAL_s:
  602|    111|{
  603|    111|   size_t lengthw = 0, lengthh = 0;
  604|       |
  605|    111|   png_debug1(1, "in %s storage function", "sCAL");
  ------------------
  |  |  151|    111|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  606|       |
  607|    111|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (607:8): [True: 0, False: 111]
  |  Branch (607:27): [True: 0, False: 111]
  ------------------
  608|      0|      return;
  609|       |
  610|       |   /* Double check the unit (should never get here with an invalid
  611|       |    * unit unless this is an API call.)
  612|       |    */
  613|    111|   if (unit != 1 && unit != 2)
  ------------------
  |  Branch (613:8): [True: 1, False: 110]
  |  Branch (613:21): [True: 0, False: 1]
  ------------------
  614|      0|      png_error(png_ptr, "Invalid sCAL unit");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  615|       |
  616|    111|   if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||
  ------------------
  |  Branch (616:8): [True: 0, False: 111]
  |  Branch (616:26): [True: 0, False: 111]
  ------------------
  617|    111|       swidth[0] == 45 /* '-' */ || !png_check_fp_string(swidth, lengthw))
  ------------------
  |  |   87|    111|#define png_check_fp_string OSS_FUZZ_png_check_fp_string
  ------------------
  |  Branch (617:8): [True: 0, False: 111]
  |  Branch (617:37): [True: 0, False: 111]
  ------------------
  618|      0|      png_error(png_ptr, "Invalid sCAL width");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  619|       |
  620|    111|   if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||
  ------------------
  |  Branch (620:8): [True: 0, False: 111]
  |  Branch (620:27): [True: 0, False: 111]
  ------------------
  621|    111|       sheight[0] == 45 /* '-' */ || !png_check_fp_string(sheight, lengthh))
  ------------------
  |  |   87|    111|#define png_check_fp_string OSS_FUZZ_png_check_fp_string
  ------------------
  |  Branch (621:8): [True: 0, False: 111]
  |  Branch (621:38): [True: 0, False: 111]
  ------------------
  622|      0|      png_error(png_ptr, "Invalid sCAL height");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  623|       |
  624|    111|   info_ptr->scal_unit = (png_byte)unit;
  625|       |
  626|    111|   ++lengthw;
  627|       |
  628|    111|   png_debug1(3, "allocating unit for info (%u bytes)", (unsigned int)lengthw);
  ------------------
  |  |  151|    111|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  629|       |
  630|    111|   info_ptr->scal_s_width = png_voidcast(png_charp,
  ------------------
  |  |  511|    111|#  define png_voidcast(type, value) (value)
  ------------------
  631|    111|       png_malloc_warn(png_ptr, lengthw));
  632|       |
  633|    111|   if (info_ptr->scal_s_width == NULL)
  ------------------
  |  Branch (633:8): [True: 0, False: 111]
  ------------------
  634|      0|   {
  635|      0|      png_warning(png_ptr, "Memory allocation failed while processing sCAL");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  636|       |
  637|      0|      return;
  638|      0|   }
  639|       |
  640|    111|   memcpy(info_ptr->scal_s_width, swidth, lengthw);
  641|       |
  642|    111|   ++lengthh;
  643|       |
  644|    111|   png_debug1(3, "allocating unit for info (%u bytes)", (unsigned int)lengthh);
  ------------------
  |  |  151|    111|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  645|       |
  646|    111|   info_ptr->scal_s_height = png_voidcast(png_charp,
  ------------------
  |  |  511|    111|#  define png_voidcast(type, value) (value)
  ------------------
  647|    111|       png_malloc_warn(png_ptr, lengthh));
  648|       |
  649|    111|   if (info_ptr->scal_s_height == NULL)
  ------------------
  |  Branch (649:8): [True: 0, False: 111]
  ------------------
  650|      0|   {
  651|      0|      png_free(png_ptr, info_ptr->scal_s_width);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
  652|      0|      info_ptr->scal_s_width = NULL;
  653|       |
  654|      0|      png_warning(png_ptr, "Memory allocation failed while processing sCAL");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  655|      0|      return;
  656|      0|   }
  657|       |
  658|    111|   memcpy(info_ptr->scal_s_height, sheight, lengthh);
  659|       |
  660|    111|   info_ptr->free_me |= PNG_FREE_SCAL;
  ------------------
  |  | 1763|    111|#define PNG_FREE_SCAL 0x0100U
  ------------------
  661|    111|   info_ptr->valid |= PNG_INFO_sCAL;
  ------------------
  |  |  744|    111|#define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
  ------------------
  662|    111|}
OSS_FUZZ_png_set_pHYs:
  727|     81|{
  728|     81|   png_debug1(1, "in %s storage function", "pHYs");
  ------------------
  |  |  151|     81|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  729|       |
  730|     81|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (730:8): [True: 0, False: 81]
  |  Branch (730:27): [True: 0, False: 81]
  ------------------
  731|      0|      return;
  732|       |
  733|     81|   info_ptr->x_pixels_per_unit = res_x;
  734|     81|   info_ptr->y_pixels_per_unit = res_y;
  735|     81|   info_ptr->phys_unit_type = (png_byte)unit_type;
  736|     81|   info_ptr->valid |= PNG_INFO_pHYs;
  ------------------
  |  |  737|     81|#define PNG_INFO_pHYs 0x0080U
  ------------------
  737|     81|}
OSS_FUZZ_png_set_PLTE:
  743|    358|{
  744|       |
  745|    358|   png_uint_32 max_palette_length;
  746|       |
  747|    358|   png_debug1(1, "in %s storage function", "PLTE");
  ------------------
  |  |  151|    358|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  748|       |
  749|    358|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (749:8): [True: 0, False: 358]
  |  Branch (749:27): [True: 0, False: 358]
  ------------------
  750|      0|      return;
  751|       |
  752|    358|   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
  ------------------
  |  |  667|    358|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|    358|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|    358|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (752:25): [True: 347, False: 11]
  ------------------
  753|    347|      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;
  ------------------
  |  |  723|    369|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  754|       |
  755|    358|   if (num_palette < 0 || num_palette > (int) max_palette_length)
  ------------------
  |  Branch (755:8): [True: 0, False: 358]
  |  Branch (755:27): [True: 0, False: 358]
  ------------------
  756|      0|   {
  757|      0|      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
  ------------------
  |  |  667|      0|#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  662|      0|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  |  |               #define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
  |  |  ------------------
  |  |  |  |  661|      0|#define PNG_COLOR_MASK_PALETTE    1
  |  |  ------------------
  ------------------
  |  Branch (757:11): [True: 0, False: 0]
  ------------------
  758|      0|         png_error(png_ptr, "Invalid palette length");
  ------------------
  |  |  252|      0|#define png_error OSS_FUZZ_png_error
  ------------------
  759|       |
  760|      0|      else
  761|      0|      {
  762|      0|         png_warning(png_ptr, "Invalid palette length");
  ------------------
  |  |  450|      0|#define png_warning OSS_FUZZ_png_warning
  ------------------
  763|       |
  764|      0|         return;
  765|      0|      }
  766|      0|   }
  767|       |
  768|    358|   if ((num_palette > 0 && palette == NULL) ||
  ------------------
  |  Branch (768:9): [True: 357, False: 1]
  |  Branch (768:28): [True: 0, False: 357]
  ------------------
  769|    358|      (num_palette == 0
  ------------------
  |  Branch (769:8): [True: 1, False: 357]
  ------------------
  770|    358|#        ifdef PNG_MNG_FEATURES_SUPPORTED
  771|    358|            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0
  ------------------
  |  |  870|      1|#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
  ------------------
  |  Branch (771:16): [True: 1, False: 0]
  ------------------
  772|    358|#        endif
  773|    358|      ))
  774|      1|   {
  775|      1|      png_error(png_ptr, "Invalid palette");
  ------------------
  |  |  252|      2|#define png_error OSS_FUZZ_png_error
  ------------------
  776|      1|   }
  777|       |
  778|       |   /* It may not actually be necessary to set png_ptr->palette here;
  779|       |    * we do it for backward compatibility with the way the png_handle_tRNS
  780|       |    * function used to do the allocation.
  781|       |    *
  782|       |    * 1.6.0: the above statement appears to be incorrect; something has to set
  783|       |    * the palette inside png_struct on read.
  784|       |    */
  785|    357|   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);
  ------------------
  |  |  254|    357|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
                 png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);
  ------------------
  |  | 1768|    357|#define PNG_FREE_PLTE 0x1000U
  ------------------
  786|       |
  787|       |   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
  788|       |    * of num_palette entries, in case of an invalid PNG file or incorrect
  789|       |    * call to png_set_PLTE() with too-large sample values.
  790|       |    */
  791|    357|   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
  ------------------
  |  |  511|    357|#  define png_voidcast(type, value) (value)
  ------------------
  792|    357|       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));
  793|       |
  794|    357|   if (num_palette > 0)
  ------------------
  |  Branch (794:8): [True: 357, False: 0]
  ------------------
  795|    357|      memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
  796|    357|          (sizeof (png_color)));
  797|       |
  798|    357|   info_ptr->palette = png_ptr->palette;
  799|    357|   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;
  800|    357|   info_ptr->free_me |= PNG_FREE_PLTE;
  ------------------
  |  | 1768|    357|#define PNG_FREE_PLTE 0x1000U
  ------------------
  801|    357|   info_ptr->valid |= PNG_INFO_PLTE;
  ------------------
  |  |  733|    357|#define PNG_INFO_PLTE 0x0008U
  ------------------
  802|    357|}
OSS_FUZZ_png_set_sBIT:
  808|    259|{
  809|    259|   png_debug1(1, "in %s storage function", "sBIT");
  ------------------
  |  |  151|    259|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  810|       |
  811|    259|   if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
  ------------------
  |  Branch (811:8): [True: 0, False: 259]
  |  Branch (811:27): [True: 0, False: 259]
  |  Branch (811:47): [True: 0, False: 259]
  ------------------
  812|      0|      return;
  813|       |
  814|    259|   info_ptr->sig_bit = *sig_bit;
  815|    259|   info_ptr->valid |= PNG_INFO_sBIT;
  ------------------
  |  |  731|    259|#define PNG_INFO_sBIT 0x0002U
  ------------------
  816|    259|}
OSS_FUZZ_png_set_sRGB:
  822|    304|{
  823|    304|   png_debug1(1, "in %s storage function", "sRGB");
  ------------------
  |  |  151|    304|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  824|       |
  825|    304|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (825:8): [True: 0, False: 304]
  |  Branch (825:27): [True: 0, False: 304]
  ------------------
  826|      0|      return;
  827|       |
  828|    304|   info_ptr->rendering_intent = srgb_intent;
  829|    304|   info_ptr->valid |= PNG_INFO_sRGB;
  ------------------
  |  |  741|    304|#define PNG_INFO_sRGB 0x0800U  /* GR-P, 0.96a */
  ------------------
  830|    304|}
OSS_FUZZ_png_set_text_2:
  927|  3.33k|{
  928|  3.33k|   int i;
  929|       |
  930|  3.33k|   png_debug1(1, "in text storage function, chunk typeid = 0x%lx",
  ------------------
  |  |  151|  3.33k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  931|  3.33k|      png_ptr == NULL ? 0xabadca11UL : (unsigned long)png_ptr->chunk_name);
  932|       |
  933|  3.33k|   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)
  ------------------
  |  Branch (933:8): [True: 0, False: 3.33k]
  |  Branch (933:27): [True: 0, False: 3.33k]
  |  Branch (933:47): [True: 0, False: 3.33k]
  |  Branch (933:64): [True: 0, False: 3.33k]
  ------------------
  934|      0|      return 0;
  935|       |
  936|       |   /* Make sure we have enough space in the "text" array in info_struct
  937|       |    * to hold all of the incoming text_ptr objects.  This compare can't overflow
  938|       |    * because max_text >= num_text (anyway, subtract of two positive integers
  939|       |    * can't overflow in any case.)
  940|       |    */
  941|  3.33k|   if (num_text > info_ptr->max_text - info_ptr->num_text)
  ------------------
  |  Branch (941:8): [True: 1.00k, False: 2.32k]
  ------------------
  942|  1.00k|   {
  943|  1.00k|      int old_num_text = info_ptr->num_text;
  944|  1.00k|      int max_text;
  945|  1.00k|      png_textp new_text = NULL;
  946|       |
  947|       |      /* Calculate an appropriate max_text, checking for overflow. */
  948|  1.00k|      max_text = old_num_text;
  949|  1.00k|      if (num_text <= INT_MAX - max_text)
  ------------------
  |  Branch (949:11): [True: 1.00k, False: 0]
  ------------------
  950|  1.00k|      {
  951|  1.00k|         max_text += num_text;
  952|       |
  953|       |         /* Round up to a multiple of 8 */
  954|  1.00k|         if (max_text < INT_MAX-8)
  ------------------
  |  Branch (954:14): [True: 1.00k, False: 0]
  ------------------
  955|  1.00k|            max_text = (max_text + 8) & ~0x7;
  956|       |
  957|      0|         else
  958|      0|            max_text = INT_MAX;
  959|       |
  960|       |         /* Now allocate a new array and copy the old members in; this does all
  961|       |          * the overflow checks.
  962|       |          */
  963|  1.00k|         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,
  ------------------
  |  |  511|  1.00k|#  define png_voidcast(type, value) (value)
  ------------------
  964|  1.00k|             info_ptr->text, old_num_text, max_text-old_num_text,
  965|  1.00k|             sizeof *new_text));
  966|  1.00k|      }
  967|       |
  968|  1.00k|      if (new_text == NULL)
  ------------------
  |  Branch (968:11): [True: 0, False: 1.00k]
  ------------------
  969|      0|      {
  970|      0|         png_chunk_report(png_ptr, "too many text chunks",
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  971|      0|             PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
  972|       |
  973|      0|         return 1;
  974|      0|      }
  975|       |
  976|  1.00k|      png_free(png_ptr, info_ptr->text);
  ------------------
  |  |  253|  1.00k|#define png_free OSS_FUZZ_png_free
  ------------------
  977|       |
  978|  1.00k|      info_ptr->text = new_text;
  979|  1.00k|      info_ptr->free_me |= PNG_FREE_TEXT;
  ------------------
  |  | 1770|  1.00k|#define PNG_FREE_TEXT 0x4000U
  ------------------
  980|  1.00k|      info_ptr->max_text = max_text;
  981|       |      /* num_text is adjusted below as the entries are copied in */
  982|       |
  983|  1.00k|      png_debug1(3, "allocated %d entries for info_ptr->text", max_text);
  ------------------
  |  |  151|  1.00k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
  984|  1.00k|   }
  985|       |
  986|  6.66k|   for (i = 0; i < num_text; i++)
  ------------------
  |  Branch (986:16): [True: 3.33k, False: 3.33k]
  ------------------
  987|  3.33k|   {
  988|  3.33k|      size_t text_length, key_len;
  989|  3.33k|      size_t lang_len, lang_key_len;
  990|  3.33k|      png_textp textp = &(info_ptr->text[info_ptr->num_text]);
  991|       |
  992|  3.33k|      if (text_ptr[i].key == NULL)
  ------------------
  |  Branch (992:11): [True: 0, False: 3.33k]
  ------------------
  993|      0|          continue;
  994|       |
  995|  3.33k|      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||
  ------------------
  |  |  586|  6.66k|#define PNG_TEXT_COMPRESSION_NONE    -1
  ------------------
  |  Branch (995:11): [True: 0, False: 3.33k]
  ------------------
  996|  3.33k|          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)
  ------------------
  |  |  590|  3.33k|#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */
  ------------------
  |  Branch (996:11): [True: 0, False: 3.33k]
  ------------------
  997|      0|      {
  998|      0|         png_chunk_report(png_ptr, "text compression mode is out of range",
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
  999|      0|             PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
 1000|      0|         continue;
 1001|      0|      }
 1002|       |
 1003|  3.33k|      key_len = strlen(text_ptr[i].key);
 1004|       |
 1005|  3.33k|      if (text_ptr[i].compression <= 0)
  ------------------
  |  Branch (1005:11): [True: 2.40k, False: 923]
  ------------------
 1006|  2.40k|      {
 1007|  2.40k|         lang_len = 0;
 1008|  2.40k|         lang_key_len = 0;
 1009|  2.40k|      }
 1010|       |
 1011|    923|      else
 1012|    923|#  ifdef PNG_iTXt_SUPPORTED
 1013|    923|      {
 1014|       |         /* Set iTXt data */
 1015|       |
 1016|    923|         if (text_ptr[i].lang != NULL)
  ------------------
  |  Branch (1016:14): [True: 923, False: 0]
  ------------------
 1017|    923|            lang_len = strlen(text_ptr[i].lang);
 1018|       |
 1019|      0|         else
 1020|      0|            lang_len = 0;
 1021|       |
 1022|    923|         if (text_ptr[i].lang_key != NULL)
  ------------------
  |  Branch (1022:14): [True: 923, False: 0]
  ------------------
 1023|    923|            lang_key_len = strlen(text_ptr[i].lang_key);
 1024|       |
 1025|      0|         else
 1026|      0|            lang_key_len = 0;
 1027|    923|      }
 1028|       |#  else /* iTXt */
 1029|       |      {
 1030|       |         png_chunk_report(png_ptr, "iTXt chunk not supported",
 1031|       |             PNG_CHUNK_WRITE_ERROR);
 1032|       |         continue;
 1033|       |      }
 1034|       |#  endif
 1035|       |
 1036|  3.33k|      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
  ------------------
  |  Branch (1036:11): [True: 0, False: 3.33k]
  |  Branch (1036:39): [True: 940, False: 2.39k]
  ------------------
 1037|    940|      {
 1038|    940|         text_length = 0;
 1039|    940|#  ifdef PNG_iTXt_SUPPORTED
 1040|    940|         if (text_ptr[i].compression > 0)
  ------------------
  |  Branch (1040:14): [True: 435, False: 505]
  ------------------
 1041|    435|            textp->compression = PNG_ITXT_COMPRESSION_NONE;
  ------------------
  |  |  588|    435|#define PNG_ITXT_COMPRESSION_NONE     1
  ------------------
 1042|       |
 1043|    505|         else
 1044|    505|#  endif
 1045|    505|            textp->compression = PNG_TEXT_COMPRESSION_NONE;
  ------------------
  |  |  586|    505|#define PNG_TEXT_COMPRESSION_NONE    -1
  ------------------
 1046|    940|      }
 1047|       |
 1048|  2.39k|      else
 1049|  2.39k|      {
 1050|  2.39k|         text_length = strlen(text_ptr[i].text);
 1051|  2.39k|         textp->compression = text_ptr[i].compression;
 1052|  2.39k|      }
 1053|       |
 1054|  3.33k|      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,
  ------------------
  |  |  511|  3.33k|#  define png_voidcast(type, value) (value)
  ------------------
 1055|  3.33k|          key_len + text_length + lang_len + lang_key_len + 4));
 1056|       |
 1057|  3.33k|      if (textp->key == NULL)
  ------------------
  |  Branch (1057:11): [True: 0, False: 3.33k]
  ------------------
 1058|      0|      {
 1059|      0|         png_chunk_report(png_ptr, "text chunk: out of memory",
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
 1060|      0|             PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
 1061|       |
 1062|      0|         return 1;
 1063|      0|      }
 1064|       |
 1065|  3.33k|      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
  ------------------
  |  |  154|  3.33k|#  define png_debug2(l, m, p1, p2) ((void)0)
  ------------------
 1066|  3.33k|          (unsigned long)(png_uint_32)
 1067|  3.33k|          (key_len + lang_len + lang_key_len + text_length + 4),
 1068|  3.33k|          textp->key);
 1069|       |
 1070|  3.33k|      memcpy(textp->key, text_ptr[i].key, key_len);
 1071|  3.33k|      *(textp->key + key_len) = '\0';
 1072|       |
 1073|  3.33k|      if (text_ptr[i].compression > 0)
  ------------------
  |  Branch (1073:11): [True: 923, False: 2.40k]
  ------------------
 1074|    923|      {
 1075|    923|         textp->lang = textp->key + key_len + 1;
 1076|    923|         memcpy(textp->lang, text_ptr[i].lang, lang_len);
 1077|    923|         *(textp->lang + lang_len) = '\0';
 1078|    923|         textp->lang_key = textp->lang + lang_len + 1;
 1079|    923|         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
 1080|    923|         *(textp->lang_key + lang_key_len) = '\0';
 1081|    923|         textp->text = textp->lang_key + lang_key_len + 1;
 1082|    923|      }
 1083|       |
 1084|  2.40k|      else
 1085|  2.40k|      {
 1086|  2.40k|         textp->lang=NULL;
 1087|  2.40k|         textp->lang_key=NULL;
 1088|  2.40k|         textp->text = textp->key + key_len + 1;
 1089|  2.40k|      }
 1090|       |
 1091|  3.33k|      if (text_length != 0)
  ------------------
  |  Branch (1091:11): [True: 2.39k, False: 940]
  ------------------
 1092|  2.39k|         memcpy(textp->text, text_ptr[i].text, text_length);
 1093|       |
 1094|  3.33k|      *(textp->text + text_length) = '\0';
 1095|       |
 1096|  3.33k|#  ifdef PNG_iTXt_SUPPORTED
 1097|  3.33k|      if (textp->compression > 0)
  ------------------
  |  Branch (1097:11): [True: 923, False: 2.40k]
  ------------------
 1098|    923|      {
 1099|    923|         textp->text_length = 0;
 1100|    923|         textp->itxt_length = text_length;
 1101|    923|      }
 1102|       |
 1103|  2.40k|      else
 1104|  2.40k|#  endif
 1105|  2.40k|      {
 1106|  2.40k|         textp->text_length = text_length;
 1107|  2.40k|         textp->itxt_length = 0;
 1108|  2.40k|      }
 1109|       |
 1110|  3.33k|      info_ptr->num_text++;
 1111|  3.33k|      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
  ------------------
  |  |  151|  3.33k|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 1112|  3.33k|   }
 1113|       |
 1114|  3.33k|   return 0;
 1115|  3.33k|}
OSS_FUZZ_png_set_tIME:
 1122|     88|{
 1123|     88|   png_debug1(1, "in %s storage function", "tIME");
  ------------------
  |  |  151|     88|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 1124|       |
 1125|     88|   if (png_ptr == NULL || info_ptr == NULL || mod_time == NULL ||
  ------------------
  |  Branch (1125:8): [True: 0, False: 88]
  |  Branch (1125:27): [True: 0, False: 88]
  |  Branch (1125:47): [True: 0, False: 88]
  ------------------
 1126|     88|       (png_ptr->mode & PNG_WROTE_tIME) != 0)
  ------------------
  |  |  625|     88|#define PNG_WROTE_tIME             0x200U
  ------------------
  |  Branch (1126:8): [True: 0, False: 88]
  ------------------
 1127|      0|      return;
 1128|       |
 1129|     88|   if (mod_time->month == 0   || mod_time->month > 12  ||
  ------------------
  |  Branch (1129:8): [True: 1, False: 87]
  |  Branch (1129:34): [True: 4, False: 83]
  ------------------
 1130|     88|       mod_time->day   == 0   || mod_time->day   > 31  ||
  ------------------
  |  Branch (1130:8): [True: 1, False: 82]
  |  Branch (1130:34): [True: 1, False: 81]
  ------------------
 1131|     88|       mod_time->hour  > 23   || mod_time->minute > 59 ||
  ------------------
  |  Branch (1131:8): [True: 1, False: 80]
  |  Branch (1131:34): [True: 1, False: 79]
  ------------------
 1132|     88|       mod_time->second > 60)
  ------------------
  |  Branch (1132:8): [True: 1, False: 78]
  ------------------
 1133|     10|   {
 1134|     10|      png_warning(png_ptr, "Ignoring invalid time value");
  ------------------
  |  |  450|     10|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1135|       |
 1136|     10|      return;
 1137|     10|   }
 1138|       |
 1139|     78|   info_ptr->mod_time = *mod_time;
 1140|     78|   info_ptr->valid |= PNG_INFO_tIME;
  ------------------
  |  |  739|     78|#define PNG_INFO_tIME 0x0200U
  ------------------
 1141|     78|}
OSS_FUZZ_png_set_tRNS:
 1148|    594|{
 1149|    594|   png_debug1(1, "in %s storage function", "tRNS");
  ------------------
  |  |  151|    594|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 1150|       |
 1151|    594|   if (png_ptr == NULL || info_ptr == NULL)
  ------------------
  |  Branch (1151:8): [True: 0, False: 594]
  |  Branch (1151:27): [True: 0, False: 594]
  ------------------
 1152|       |
 1153|      0|      return;
 1154|       |
 1155|    594|   if (trans_alpha != NULL)
  ------------------
  |  Branch (1155:8): [True: 594, False: 0]
  ------------------
 1156|    594|   {
 1157|       |       /* It may not actually be necessary to set png_ptr->trans_alpha here;
 1158|       |        * we do it for backward compatibility with the way the png_handle_tRNS
 1159|       |        * function used to do the allocation.
 1160|       |        *
 1161|       |        * 1.6.0: The above statement is incorrect; png_handle_tRNS effectively
 1162|       |        * relies on png_set_tRNS storing the information in png_struct
 1163|       |        * (otherwise it won't be there for the code in pngrtran.c).
 1164|       |        */
 1165|       |
 1166|    594|       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
  ------------------
  |  |  254|    594|#define png_free_data OSS_FUZZ_png_free_data
  ------------------
                     png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
  ------------------
  |  | 1769|    594|#define PNG_FREE_TRNS 0x2000U
  ------------------
 1167|       |
 1168|    594|       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
  ------------------
  |  |  723|    594|#define PNG_MAX_PALETTE_LENGTH    256
  ------------------
  |  Branch (1168:12): [True: 594, False: 0]
  |  Branch (1168:29): [True: 594, False: 0]
  ------------------
 1169|    594|       {
 1170|       |         /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
 1171|    594|          info_ptr->trans_alpha = png_voidcast(png_bytep,
  ------------------
  |  |  511|    594|#  define png_voidcast(type, value) (value)
  ------------------
 1172|    594|              png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));
 1173|    594|          memcpy(info_ptr->trans_alpha, trans_alpha, (size_t)num_trans);
 1174|       |
 1175|    594|          info_ptr->free_me |= PNG_FREE_TRNS;
  ------------------
  |  | 1769|    594|#define PNG_FREE_TRNS 0x2000U
  ------------------
 1176|    594|          info_ptr->valid |= PNG_INFO_tRNS;
  ------------------
  |  |  734|    594|#define PNG_INFO_tRNS 0x0010U
  ------------------
 1177|    594|       }
 1178|    594|       png_ptr->trans_alpha = info_ptr->trans_alpha;
 1179|    594|   }
 1180|       |
 1181|    594|   if (trans_color != NULL)
  ------------------
  |  Branch (1181:8): [True: 594, False: 0]
  ------------------
 1182|    594|   {
 1183|    594|#ifdef PNG_WARNINGS_SUPPORTED
 1184|    594|      if (info_ptr->bit_depth < 16)
  ------------------
  |  Branch (1184:11): [True: 483, False: 111]
  ------------------
 1185|    483|      {
 1186|    483|         int sample_max = (1 << info_ptr->bit_depth) - 1;
 1187|       |
 1188|    483|         if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
  ------------------
  |  |  666|    966|#define PNG_COLOR_TYPE_GRAY 0
  ------------------
  |  Branch (1188:15): [True: 266, False: 217]
  ------------------
 1189|    483|             trans_color->gray > sample_max) ||
  ------------------
  |  Branch (1189:14): [True: 7, False: 259]
  ------------------
 1190|    483|             (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
  ------------------
  |  |  668|    952|#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
  |  |  ------------------
  |  |  |  |  662|    476|#define PNG_COLOR_MASK_COLOR      2
  |  |  ------------------
  ------------------
  |  Branch (1190:15): [True: 113, False: 363]
  ------------------
 1191|    476|             (trans_color->red > sample_max ||
  ------------------
  |  Branch (1191:15): [True: 4, False: 109]
  ------------------
 1192|    113|             trans_color->green > sample_max ||
  ------------------
  |  Branch (1192:14): [True: 38, False: 71]
  ------------------
 1193|    113|             trans_color->blue > sample_max)))
  ------------------
  |  Branch (1193:14): [True: 2, False: 69]
  ------------------
 1194|     51|            png_warning(png_ptr,
  ------------------
  |  |  450|     51|#define png_warning OSS_FUZZ_png_warning
  ------------------
 1195|     51|                "tRNS chunk has out-of-range samples for bit_depth");
 1196|    483|      }
 1197|    594|#endif
 1198|       |
 1199|    594|      info_ptr->trans_color = *trans_color;
 1200|       |
 1201|    594|      if (num_trans == 0)
  ------------------
  |  Branch (1201:11): [True: 0, False: 594]
  ------------------
 1202|      0|         num_trans = 1;
 1203|    594|   }
 1204|       |
 1205|    594|   info_ptr->num_trans = (png_uint_16)num_trans;
 1206|       |
 1207|    594|   if (num_trans != 0)
  ------------------
  |  Branch (1207:8): [True: 594, False: 0]
  ------------------
 1208|    594|   {
 1209|    594|      info_ptr->free_me |= PNG_FREE_TRNS;
  ------------------
  |  | 1769|    594|#define PNG_FREE_TRNS 0x2000U
  ------------------
 1210|    594|      info_ptr->valid |= PNG_INFO_tRNS;
  ------------------
  |  |  734|    594|#define PNG_INFO_tRNS 0x0010U
  ------------------
 1211|    594|   }
 1212|    594|}
OSS_FUZZ_png_set_sPLT:
 1227|    660|{
 1228|    660|   png_sPLT_tp np;
 1229|       |
 1230|    660|   png_debug1(1, "in %s storage function", "sPLT");
  ------------------
  |  |  151|    660|#  define png_debug1(l, m, p1) ((void)0)
  ------------------
 1231|       |
 1232|    660|   if (png_ptr == NULL || info_ptr == NULL || nentries <= 0 || entries == NULL)
  ------------------
  |  Branch (1232:8): [True: 0, False: 660]
  |  Branch (1232:27): [True: 0, False: 660]
  |  Branch (1232:47): [True: 0, False: 660]
  |  Branch (1232:64): [True: 0, False: 660]
  ------------------
 1233|      0|      return;
 1234|       |
 1235|       |   /* Use the internal realloc function, which checks for all the possible
 1236|       |    * overflows.  Notice that the parameters are (int) and (size_t)
 1237|       |    */
 1238|    660|   np = png_voidcast(png_sPLT_tp,png_realloc_array(png_ptr,
  ------------------
  |  |  511|    660|#  define png_voidcast(type, value) (value)
  ------------------
 1239|    660|       info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries,
 1240|    660|       sizeof *np));
 1241|       |
 1242|    660|   if (np == NULL)
  ------------------
  |  Branch (1242:8): [True: 0, False: 660]
  ------------------
 1243|      0|   {
 1244|       |      /* Out of memory or too many chunks */
 1245|      0|      png_chunk_report(png_ptr, "too many sPLT chunks", PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
                    png_chunk_report(png_ptr, "too many sPLT chunks", PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
 1246|      0|      return;
 1247|      0|   }
 1248|       |
 1249|    660|   png_free(png_ptr, info_ptr->splt_palettes);
  ------------------
  |  |  253|    660|#define png_free OSS_FUZZ_png_free
  ------------------
 1250|       |
 1251|    660|   info_ptr->splt_palettes = np;
 1252|    660|   info_ptr->free_me |= PNG_FREE_SPLT;
  ------------------
  |  | 1760|    660|#define PNG_FREE_SPLT 0x0020U
  ------------------
 1253|       |
 1254|    660|   np += info_ptr->splt_palettes_num;
 1255|       |
 1256|    660|   do
 1257|    660|   {
 1258|    660|      size_t length;
 1259|       |
 1260|       |      /* Skip invalid input entries */
 1261|    660|      if (entries->name == NULL || entries->entries == NULL)
  ------------------
  |  Branch (1261:11): [True: 0, False: 660]
  |  Branch (1261:36): [True: 0, False: 660]
  ------------------
 1262|      0|      {
 1263|       |         /* png_handle_sPLT doesn't do this, so this is an app error */
 1264|      0|         png_app_error(png_ptr, "png_set_sPLT: invalid sPLT");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
 1265|       |         /* Just skip the invalid entry */
 1266|      0|         continue;
 1267|      0|      }
 1268|       |
 1269|    660|      np->depth = entries->depth;
 1270|       |
 1271|       |      /* In the event of out-of-memory just return - there's no point keeping
 1272|       |       * on trying to add sPLT chunks.
 1273|       |       */
 1274|    660|      length = strlen(entries->name) + 1;
 1275|    660|      np->name = png_voidcast(png_charp, png_malloc_base(png_ptr, length));
  ------------------
  |  |  511|    660|#  define png_voidcast(type, value) (value)
  ------------------
 1276|       |
 1277|    660|      if (np->name == NULL)
  ------------------
  |  Branch (1277:11): [True: 0, False: 660]
  ------------------
 1278|      0|         break;
 1279|       |
 1280|    660|      memcpy(np->name, entries->name, length);
 1281|       |
 1282|       |      /* IMPORTANT: we have memory now that won't get freed if something else
 1283|       |       * goes wrong; this code must free it.  png_malloc_array produces no
 1284|       |       * warnings; use a png_chunk_report (below) if there is an error.
 1285|       |       */
 1286|    660|      np->entries = png_voidcast(png_sPLT_entryp, png_malloc_array(png_ptr,
  ------------------
  |  |  511|    660|#  define png_voidcast(type, value) (value)
  ------------------
 1287|    660|          entries->nentries, sizeof (png_sPLT_entry)));
 1288|       |
 1289|    660|      if (np->entries == NULL)
  ------------------
  |  Branch (1289:11): [True: 0, False: 660]
  ------------------
 1290|      0|      {
 1291|      0|         png_free(png_ptr, np->name);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 1292|      0|         np->name = NULL;
 1293|      0|         break;
 1294|      0|      }
 1295|       |
 1296|    660|      np->nentries = entries->nentries;
 1297|       |      /* This multiply can't overflow because png_malloc_array has already
 1298|       |       * checked it when doing the allocation.
 1299|       |       */
 1300|    660|      memcpy(np->entries, entries->entries,
 1301|    660|          (unsigned int)entries->nentries * sizeof (png_sPLT_entry));
 1302|       |
 1303|       |      /* Note that 'continue' skips the advance of the out pointer and out
 1304|       |       * count, so an invalid entry is not added.
 1305|       |       */
 1306|    660|      info_ptr->valid |= PNG_INFO_sPLT;
  ------------------
  |  |  743|    660|#define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
  ------------------
 1307|    660|      ++(info_ptr->splt_palettes_num);
 1308|    660|      ++np;
 1309|    660|      ++entries;
 1310|    660|   }
 1311|    660|   while (--nentries);
  ------------------
  |  Branch (1311:11): [True: 0, False: 660]
  ------------------
 1312|       |
 1313|    660|   if (nentries > 0)
  ------------------
  |  Branch (1313:8): [True: 0, False: 660]
  ------------------
 1314|      0|      png_chunk_report(png_ptr, "sPLT out of memory", PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  |   83|      0|#define png_chunk_report OSS_FUZZ_png_chunk_report
  ------------------
                    png_chunk_report(png_ptr, "sPLT out of memory", PNG_CHUNK_WRITE_ERROR);
  ------------------
  |  | 1835|      0|#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
  ------------------
 1315|    660|}
OSS_FUZZ_png_set_keep_unknown_chunks:
 1531|  1.07k|{
 1532|  1.07k|   png_bytep new_list;
 1533|  1.07k|   unsigned int num_chunks, old_num_chunks;
 1534|       |
 1535|  1.07k|   if (png_ptr == NULL)
  ------------------
  |  Branch (1535:8): [True: 0, False: 1.07k]
  ------------------
 1536|      0|      return;
 1537|       |
 1538|  1.07k|   if (keep < 0 || keep >= PNG_HANDLE_CHUNK_LAST)
  ------------------
  |  | 2453|  1.07k|#define PNG_HANDLE_CHUNK_LAST         4
  ------------------
  |  Branch (1538:8): [True: 0, False: 1.07k]
  |  Branch (1538:20): [True: 0, False: 1.07k]
  ------------------
 1539|      0|   {
 1540|      0|      png_app_error(png_ptr, "png_set_keep_unknown_chunks: invalid keep");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
 1541|       |
 1542|      0|      return;
 1543|      0|   }
 1544|       |
 1545|  1.07k|   if (num_chunks_in <= 0)
  ------------------
  |  Branch (1545:8): [True: 537, False: 537]
  ------------------
 1546|    537|   {
 1547|    537|      png_ptr->unknown_default = keep;
 1548|       |
 1549|       |      /* '0' means just set the flags, so stop here */
 1550|    537|      if (num_chunks_in == 0)
  ------------------
  |  Branch (1550:11): [True: 0, False: 537]
  ------------------
 1551|      0|        return;
 1552|    537|   }
 1553|       |
 1554|  1.07k|   if (num_chunks_in < 0)
  ------------------
  |  Branch (1554:8): [True: 537, False: 537]
  ------------------
 1555|    537|   {
 1556|       |      /* Ignore all unknown chunks and all chunks recognized by
 1557|       |       * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND
 1558|       |       */
 1559|    537|      static const png_byte chunks_to_ignore[] = {
 1560|    537|         98,  75,  71,  68, '\0',  /* bKGD */
 1561|    537|         99,  72,  82,  77, '\0',  /* cHRM */
 1562|    537|         99,  73,  67,  80, '\0',  /* cICP */
 1563|    537|         99,  76,  76,  73, '\0',  /* cLLI */
 1564|    537|        101,  88,  73, 102, '\0',  /* eXIf */
 1565|    537|        103,  65,  77,  65, '\0',  /* gAMA */
 1566|    537|        104,  73,  83,  84, '\0',  /* hIST */
 1567|    537|        105,  67,  67,  80, '\0',  /* iCCP */
 1568|    537|        105,  84,  88, 116, '\0',  /* iTXt */
 1569|    537|        109,  68,  67,  86, '\0',  /* mDCV */
 1570|    537|        111,  70,  70, 115, '\0',  /* oFFs */
 1571|    537|        112,  67,  65,  76, '\0',  /* pCAL */
 1572|    537|        112,  72,  89, 115, '\0',  /* pHYs */
 1573|    537|        115,  66,  73,  84, '\0',  /* sBIT */
 1574|    537|        115,  67,  65,  76, '\0',  /* sCAL */
 1575|    537|        115,  80,  76,  84, '\0',  /* sPLT */
 1576|    537|        115,  84,  69,  82, '\0',  /* sTER */
 1577|    537|        115,  82,  71,  66, '\0',  /* sRGB */
 1578|    537|        116,  69,  88, 116, '\0',  /* tEXt */
 1579|    537|        116,  73,  77,  69, '\0',  /* tIME */
 1580|    537|        122,  84,  88, 116, '\0'   /* zTXt */
 1581|    537|      };
 1582|       |
 1583|    537|      chunk_list = chunks_to_ignore;
 1584|    537|      num_chunks = (unsigned int)/*SAFE*/(sizeof chunks_to_ignore)/5U;
 1585|    537|   }
 1586|       |
 1587|    537|   else /* num_chunks_in > 0 */
 1588|    537|   {
 1589|    537|      if (chunk_list == NULL)
  ------------------
  |  Branch (1589:11): [True: 0, False: 537]
  ------------------
 1590|      0|      {
 1591|       |         /* Prior to 1.6.0 this was silently ignored, now it is an app_error
 1592|       |          * which can be switched off.
 1593|       |          */
 1594|      0|         png_app_error(png_ptr, "png_set_keep_unknown_chunks: no chunk list");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
 1595|       |
 1596|      0|         return;
 1597|      0|      }
 1598|       |
 1599|    537|      num_chunks = (unsigned int)num_chunks_in;
 1600|    537|   }
 1601|       |
 1602|  1.07k|   old_num_chunks = png_ptr->num_chunk_list;
 1603|  1.07k|   if (png_ptr->chunk_list == NULL)
  ------------------
  |  Branch (1603:8): [True: 537, False: 537]
  ------------------
 1604|    537|      old_num_chunks = 0;
 1605|       |
 1606|       |   /* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.
 1607|       |    */
 1608|  1.07k|   if (num_chunks + old_num_chunks > UINT_MAX/5)
  ------------------
  |  Branch (1608:8): [True: 0, False: 1.07k]
  ------------------
 1609|      0|   {
 1610|      0|      png_app_error(png_ptr, "png_set_keep_unknown_chunks: too many chunks");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
 1611|       |
 1612|      0|      return;
 1613|      0|   }
 1614|       |
 1615|       |   /* If these chunks are being reset to the default then no more memory is
 1616|       |    * required because add_one_chunk above doesn't extend the list if the 'keep'
 1617|       |    * parameter is the default.
 1618|       |    */
 1619|  1.07k|   if (keep != 0)
  ------------------
  |  Branch (1619:8): [True: 537, False: 537]
  ------------------
 1620|    537|   {
 1621|    537|      new_list = png_voidcast(png_bytep, png_malloc(png_ptr,
  ------------------
  |  |  511|    537|#  define png_voidcast(type, value) (value)
  ------------------
 1622|    537|          5 * (num_chunks + old_num_chunks)));
 1623|       |
 1624|    537|      if (old_num_chunks > 0)
  ------------------
  |  Branch (1624:11): [True: 0, False: 537]
  ------------------
 1625|      0|         memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);
 1626|    537|   }
 1627|       |
 1628|    537|   else if (old_num_chunks > 0)
  ------------------
  |  Branch (1628:13): [True: 537, False: 0]
  ------------------
 1629|    537|      new_list = png_ptr->chunk_list;
 1630|       |
 1631|      0|   else
 1632|      0|      new_list = NULL;
 1633|       |
 1634|       |   /* Add the new chunks together with each one's handling code.  If the chunk
 1635|       |    * already exists the code is updated, otherwise the chunk is added to the
 1636|       |    * end.  (In libpng 1.6.0 order no longer matters because this code enforces
 1637|       |    * the earlier convention that the last setting is the one that is used.)
 1638|       |    */
 1639|  1.07k|   if (new_list != NULL)
  ------------------
  |  Branch (1639:8): [True: 1.07k, False: 0]
  ------------------
 1640|  1.07k|   {
 1641|  1.07k|      png_const_bytep inlist;
 1642|  1.07k|      png_bytep outlist;
 1643|  1.07k|      unsigned int i;
 1644|       |
 1645|  16.1k|      for (i=0; i<num_chunks; ++i)
  ------------------
  |  Branch (1645:17): [True: 15.0k, False: 1.07k]
  ------------------
 1646|  15.0k|      {
 1647|  15.0k|         old_num_chunks = add_one_chunk(new_list, old_num_chunks,
 1648|  15.0k|             chunk_list+5*i, keep);
 1649|  15.0k|      }
 1650|       |
 1651|       |      /* Now remove any spurious 'default' entries. */
 1652|  1.07k|      num_chunks = 0;
 1653|  23.6k|      for (i=0, inlist=outlist=new_list; i<old_num_chunks; ++i, inlist += 5)
  ------------------
  |  Branch (1653:42): [True: 22.5k, False: 1.07k]
  ------------------
 1654|  22.5k|      {
 1655|  22.5k|         if (inlist[4])
  ------------------
  |  Branch (1655:14): [True: 18.7k, False: 3.75k]
  ------------------
 1656|  18.7k|         {
 1657|  18.7k|            if (outlist != inlist)
  ------------------
  |  Branch (1657:17): [True: 7.51k, False: 11.2k]
  ------------------
 1658|  7.51k|               memcpy(outlist, inlist, 5);
 1659|  18.7k|            outlist += 5;
 1660|  18.7k|            ++num_chunks;
 1661|  18.7k|         }
 1662|  22.5k|      }
 1663|       |
 1664|       |      /* This means the application has removed all the specialized handling. */
 1665|  1.07k|      if (num_chunks == 0)
  ------------------
  |  Branch (1665:11): [True: 0, False: 1.07k]
  ------------------
 1666|      0|      {
 1667|      0|         if (png_ptr->chunk_list != new_list)
  ------------------
  |  Branch (1667:14): [True: 0, False: 0]
  ------------------
 1668|      0|            png_free(png_ptr, new_list);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 1669|       |
 1670|      0|         new_list = NULL;
 1671|      0|      }
 1672|  1.07k|   }
 1673|       |
 1674|      0|   else
 1675|      0|      num_chunks = 0;
 1676|       |
 1677|  1.07k|   png_ptr->num_chunk_list = num_chunks;
 1678|       |
 1679|  1.07k|   if (png_ptr->chunk_list != new_list)
  ------------------
  |  Branch (1679:8): [True: 537, False: 537]
  ------------------
 1680|    537|   {
 1681|    537|      if (png_ptr->chunk_list != NULL)
  ------------------
  |  Branch (1681:11): [True: 0, False: 537]
  ------------------
 1682|      0|         png_free(png_ptr, png_ptr->chunk_list);
  ------------------
  |  |  253|      0|#define png_free OSS_FUZZ_png_free
  ------------------
 1683|       |
 1684|    537|      png_ptr->chunk_list = new_list;
 1685|    537|   }
 1686|  1.07k|}
OSS_FUZZ_png_set_benign_errors:
 1856|    548|{
 1857|    548|   png_debug(1, "in png_set_benign_errors");
  ------------------
  |  |  148|    548|#  define png_debug(l, m) ((void)0)
  ------------------
 1858|       |
 1859|       |   /* If allowed is 1, png_benign_error() is treated as a warning.
 1860|       |    *
 1861|       |    * If allowed is 0, png_benign_error() is treated as an error (which
 1862|       |    * is the default behavior if png_set_benign_errors() is not called).
 1863|       |    */
 1864|       |
 1865|    548|   if (allowed != 0)
  ------------------
  |  Branch (1865:8): [True: 548, False: 0]
  ------------------
 1866|    548|      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN |
  ------------------
  |  |  691|    548|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
 1867|    548|         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN;
  ------------------
  |  |  692|    548|#define PNG_FLAG_APP_WARNINGS_WARN      0x200000U /* Added to libpng-1.6.0 */
  ------------------
                       PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN;
  ------------------
  |  |  693|    548|#define PNG_FLAG_APP_ERRORS_WARN        0x400000U /* Added to libpng-1.6.0 */
  ------------------
 1868|       |
 1869|      0|   else
 1870|      0|      png_ptr->flags &= ~(PNG_FLAG_BENIGN_ERRORS_WARN |
  ------------------
  |  |  691|      0|#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
  ------------------
 1871|      0|         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN);
  ------------------
  |  |  692|      0|#define PNG_FLAG_APP_WARNINGS_WARN      0x200000U /* Added to libpng-1.6.0 */
  ------------------
                       PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN);
  ------------------
  |  |  693|      0|#define PNG_FLAG_APP_ERRORS_WARN        0x400000U /* Added to libpng-1.6.0 */
  ------------------
 1872|    548|}
pngset.c:png_ITU_fixed_16:
  207|  1.72k|{
  208|       |   /* Return a safe uint16_t value scaled according to the ITU H273 rules for
  209|       |    * 16-bit display chromaticities.  Functions like the corresponding
  210|       |    * png_fixed() internal function with regard to errors: it's an error on
  211|       |    * write, a chunk_benign_error on read: See the definition of
  212|       |    * png_chunk_report in pngpriv.h.
  213|       |    */
  214|  1.72k|   v /= 2; /* rounds to 0 in C: avoids insignificant arithmetic errors */
  215|  1.72k|   if (v > 65535 || v < 0)
  ------------------
  |  Branch (215:8): [True: 0, False: 1.72k]
  |  Branch (215:21): [True: 0, False: 1.72k]
  ------------------
  216|      0|   {
  217|      0|      *error = 1;
  218|      0|      return 0;
  219|      0|   }
  220|       |
  221|  1.72k|   return (png_uint_16)/*SAFE*/v;
  222|  1.72k|}
pngset.c:add_one_chunk:
 1502|  15.0k|{
 1503|  15.0k|   unsigned int i;
 1504|       |
 1505|       |   /* Utility function: update the 'keep' state of a chunk if it is already in
 1506|       |    * the list, otherwise add it to the list.
 1507|       |    */
 1508|   153k|   for (i=0; i<count; ++i, list += 5)
  ------------------
  |  Branch (1508:14): [True: 141k, False: 11.2k]
  ------------------
 1509|   141k|   {
 1510|   141k|      if (memcmp(list, add, 4) == 0)
  ------------------
  |  Branch (1510:11): [True: 3.75k, False: 138k]
  ------------------
 1511|  3.75k|      {
 1512|  3.75k|         list[4] = (png_byte)keep;
 1513|       |
 1514|  3.75k|         return count;
 1515|  3.75k|      }
 1516|   141k|   }
 1517|       |
 1518|  11.2k|   if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)
  ------------------
  |  | 2449|  11.2k|#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
  ------------------
  |  Branch (1518:8): [True: 11.2k, False: 0]
  ------------------
 1519|  11.2k|   {
 1520|  11.2k|      ++count;
 1521|  11.2k|      memcpy(list, add, 4);
 1522|  11.2k|      list[4] = (png_byte)keep;
 1523|  11.2k|   }
 1524|       |
 1525|  11.2k|   return count;
 1526|  15.0k|}

OSS_FUZZ_png_set_packing:
   50|  1.11k|{
   51|  1.11k|   png_debug(1, "in png_set_packing");
  ------------------
  |  |  148|  1.11k|#  define png_debug(l, m) ((void)0)
  ------------------
   52|       |
   53|  1.11k|   if (png_ptr == NULL)
  ------------------
  |  Branch (53:8): [True: 0, False: 1.11k]
  ------------------
   54|      0|      return;
   55|       |
   56|  1.11k|   if (png_ptr->bit_depth < 8)
  ------------------
  |  Branch (56:8): [True: 544, False: 568]
  ------------------
   57|    544|   {
   58|    544|      png_ptr->transformations |= PNG_PACK;
  ------------------
  |  |  636|    544|#define PNG_PACK                0x0004U
  ------------------
   59|       |#     ifdef PNG_WRITE_SUPPORTED
   60|       |         png_ptr->usr_bit_depth = 8;
   61|       |#     endif
   62|    544|   }
   63|  1.11k|}
OSS_FUZZ_png_set_interlace_handling:
   99|  1.64k|{
  100|  1.64k|   png_debug(1, "in png_set_interlace handling");
  ------------------
  |  |  148|  1.64k|#  define png_debug(l, m) ((void)0)
  ------------------
  101|       |
  102|  1.64k|   if (png_ptr != 0 && png_ptr->interlaced != 0)
  ------------------
  |  Branch (102:8): [True: 1.64k, False: 0]
  |  Branch (102:24): [True: 474, False: 1.17k]
  ------------------
  103|    474|   {
  104|    474|      png_ptr->transformations |= PNG_INTERLACE;
  ------------------
  |  |  635|    474|#define PNG_INTERLACE           0x0002U
  ------------------
  105|    474|      return 7;
  106|    474|   }
  107|       |
  108|  1.17k|   return 1;
  109|  1.64k|}
OSS_FUZZ_png_set_filler:
  120|    268|{
  121|    268|   png_debug(1, "in png_set_filler");
  ------------------
  |  |  148|    268|#  define png_debug(l, m) ((void)0)
  ------------------
  122|       |
  123|    268|   if (png_ptr == NULL)
  ------------------
  |  Branch (123:8): [True: 0, False: 268]
  ------------------
  124|      0|      return;
  125|       |
  126|       |   /* In libpng 1.6 it is possible to determine whether this is a read or write
  127|       |    * operation and therefore to do more checking here for a valid call.
  128|       |    */
  129|    268|   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
  ------------------
  |  |  631|    268|#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */
  ------------------
  |  Branch (129:8): [True: 268, False: 0]
  ------------------
  130|    268|   {
  131|    268|#     ifdef PNG_READ_FILLER_SUPPORTED
  132|       |         /* On read png_set_filler is always valid, regardless of the base PNG
  133|       |          * format, because other transformations can give a format where the
  134|       |          * filler code can execute (basically an 8 or 16-bit component RGB or G
  135|       |          * format.)
  136|       |          *
  137|       |          * NOTE: usr_channels is not used by the read code!  (This has led to
  138|       |          * confusion in the past.)  The filler is only used in the read code.
  139|       |          */
  140|    268|         png_ptr->filler = (png_uint_16)filler;
  141|       |#     else
  142|       |         png_app_error(png_ptr, "png_set_filler not supported on read");
  143|       |         PNG_UNUSED(filler) /* not used in the write case */
  144|       |         return;
  145|       |#     endif
  146|    268|   }
  147|       |
  148|      0|   else /* write */
  149|      0|   {
  150|       |#     ifdef PNG_WRITE_FILLER_SUPPORTED
  151|       |         /* On write the usr_channels parameter must be set correctly at the
  152|       |          * start to record the number of channels in the app-supplied data.
  153|       |          */
  154|       |         switch (png_ptr->color_type)
  155|       |         {
  156|       |            case PNG_COLOR_TYPE_RGB:
  157|       |               png_ptr->usr_channels = 4;
  158|       |               break;
  159|       |
  160|       |            case PNG_COLOR_TYPE_GRAY:
  161|       |               if (png_ptr->bit_depth >= 8)
  162|       |               {
  163|       |                  png_ptr->usr_channels = 2;
  164|       |                  break;
  165|       |               }
  166|       |
  167|       |               else
  168|       |               {
  169|       |                  /* There simply isn't any code in libpng to strip out bits
  170|       |                   * from bytes when the components are less than a byte in
  171|       |                   * size!
  172|       |                   */
  173|       |                  png_app_error(png_ptr,
  174|       |                      "png_set_filler is invalid for"
  175|       |                      " low bit depth gray output");
  176|       |                  return;
  177|       |               }
  178|       |
  179|       |            default:
  180|       |               png_app_error(png_ptr,
  181|       |                   "png_set_filler: inappropriate color type");
  182|       |               return;
  183|       |         }
  184|       |#     else
  185|      0|         png_app_error(png_ptr, "png_set_filler not supported on write");
  ------------------
  |  |   82|      0|#define png_app_error OSS_FUZZ_png_app_error
  ------------------
  186|      0|         return;
  187|      0|#     endif
  188|      0|   }
  189|       |
  190|       |   /* Here on success - libpng supports the operation, set the transformation
  191|       |    * and the flag to say where the filler channel is.
  192|       |    */
  193|    268|   png_ptr->transformations |= PNG_FILLER;
  ------------------
  |  |  649|    268|#define PNG_FILLER              0x8000U
  ------------------
  194|       |
  195|    268|   if (filler_loc == PNG_FILLER_AFTER)
  ------------------
  |  | 1262|    268|#  define PNG_FILLER_AFTER 1
  ------------------
  |  Branch (195:8): [True: 268, False: 0]
  ------------------
  196|    268|      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
  ------------------
  |  |  678|    268|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  197|       |
  198|      0|   else
  199|      0|      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
  ------------------
  |  |  678|      0|#define PNG_FLAG_FILLER_AFTER             0x0080U
  ------------------
  200|    268|}
OSS_FUZZ_png_set_add_alpha:
  205|    268|{
  206|    268|   png_debug(1, "in png_set_add_alpha");
  ------------------
  |  |  148|    268|#  define png_debug(l, m) ((void)0)
  ------------------
  207|       |
  208|    268|   if (png_ptr == NULL)
  ------------------
  |  Branch (208:8): [True: 0, False: 268]
  ------------------
  209|      0|      return;
  210|       |
  211|    268|   png_set_filler(png_ptr, filler, filler_loc);
  ------------------
  |  |  391|    268|#define png_set_filler OSS_FUZZ_png_set_filler
  ------------------
  212|       |   /* The above may fail to do anything. */
  213|    268|   if ((png_ptr->transformations & PNG_FILLER) != 0)
  ------------------
  |  |  649|    268|#define PNG_FILLER              0x8000U
  ------------------
  |  Branch (213:8): [True: 268, False: 0]
  ------------------
  214|    268|      png_ptr->transformations |= PNG_ADD_ALPHA;
  ------------------
  |  |  659|    268|#define PNG_ADD_ALPHA        0x1000000U /* Added to libpng-1.2.7 */
  ------------------
  215|    268|}

